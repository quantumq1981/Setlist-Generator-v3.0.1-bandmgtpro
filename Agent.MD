
AGENT.MD latest report



	â€¢	Your print formatting is already correct âœ… (Times New Roman, 19pt, line-height 1.0, per-set page breaks).
	â€¢	Your manual edit mode is implemented correctly âœ….
	â€¢	Your CSV hardening work is solid âœ….

The remaining issue â€” duplicates still appearing â€” is real, reproducible, and caused by two subtle but critical logic leaks in the generator.

Iâ€™ll be precise and concrete so you (or Rob) can fix this in one pass.

â¸»

ğŸ”´ Why duplicates are STILL happening (root cause)

You did add a globalUsedSongKeys Set, which is correct.
However, duplicates can still enter through two backdoors:

â¸»

âŒ LEAK #1 â€” Force Closer ignores earlier set usage

This block is the biggest offender:

// closer
if (forceCloser && setSongs.length){
  const last = setSongs[setSongs.length-1];
  const e = ENERGY_MAP[last.style] || 3;
  if (!(e >= 5 || last.style === 'ballad')){
    const closers = pool.filter(s => (
      allowSongReuse ? true : !getSongDedupKeys(s).some(key => globalUsedSongKeys.has(key))
    ) && (s.style === 'uptempo' || s.style === 'ballad'));

The bug

At this point in the loop:
	â€¢	globalUsedSongKeys already includes all songs used earlier in this same set
	â€¢	BUT:
	â€¢	You already pushed all keys from the selected closer
	â€¢	You do not remove the previously added last song
	â€¢	Result: the closer can duplicate a song already used earlier in the same set

This is how youâ€™re seeing duplicates even with No Reuse enabled.

â¸»

âœ… REQUIRED FIX (Force Closer)

You must remove the current last songâ€™s keys from the dedupe set before searching for a replacement, exactly like you do in swapSong.

Fix:

// BEFORE selecting closers
if (!allowSongReuse) {
  getSongDedupKeys(last).forEach(key => globalUsedSongKeys.delete(key));
}

Then, after pushing the closer, re-add its keys:

if (!allowSongReuse){
  getSongDedupKeys(closer).forEach(key => globalUsedSongKeys.add(key));
}

Without this, forceCloser will always leak duplicates under certain durations.

â¸»

âŒ LEAK #2 â€” Cross-set exhaustion fallback still allows reuse

This block is dangerous:

if (candidates.length === 0){
  candidates = pool.filter(song => (
    isAvailable(song)
  ));
  if (candidates.length === 0){
    if (!allowSongReuse){
      generationWarnings.add('Unable to generate requested sets without repeating songs.');
      setFailed = true;
      generationAborted = true;
    }
    break;
  }
}

The problem

Once Set 1 consumes too much of the pool, Set 2 can enter a state where:
	â€¢	Duration constraints fail
	â€¢	isAvailable(song) becomes too permissive
	â€¢	You break out after partially generating a set

This leaves previously used songs intact and allows later logic to reinsert them.

â¸»

âœ… REQUIRED FIX (Hard stop, not soft break)

When allowSongReuse === false and no candidates exist:

ğŸ‘‰ You must abort generation entirely, not just break the inner loop

Replace:

break;

With:

generationAborted = true;
break;

And after the while loop:

if (generationAborted) break;

You partially do this â€” but not consistently across all branches.

This is why duplicates appear intermittently depending on:
	â€¢	number of sets
	â€¢	duration
	â€¢	energy curve on/off

â¸»

ğŸŸ¢ What is already CORRECT (no changes needed)

âœ… Print export

Your implementation is spot-on:
	â€¢	@page size: letter
	â€¢	.set-page { page-break-after: always }
	â€¢	Times New Roman
	â€¢	19pt
	â€¢	line-height 1.0
	â€¢	Each set on its own page

This meets your spec exactly.

âœ… Manual Edit Mode
	â€¢	Toggle logic is correct
	â€¢	Generate disabled during manual mode
	â€¢	Move up/down recalculates duration correctly

No changes needed.

â¸»

âœ… Minimal Patch Summary (what to actually change)

You do not need a refactor.

Fix only these two things:
	1.	Force Closer
	â€¢	Temporarily remove last song from globalUsedSongKeys
	â€¢	Add selected closer back after insertion
	2.	Hard abort generation
	â€¢	When dedupe makes generation impossible, abort all remaining sets
	â€¢	Do not allow partial fallback logic to continue

Thatâ€™s it.

â¸»

ğŸ§ª How youâ€™ll know itâ€™s fixed

After patching:
	â€¢	2 sets Ã— 30 min â†’ no duplicates
	â€¢	3 sets Ã— 45 min â†’ no duplicates
	â€¢	Energy curve ON / OFF â†’ no duplicates
	â€¢	Strong opener / closer ON â†’ no duplicates
	â€¢	Manual edit does not reintroduce duplicates

At that point, your generator is correct by construction, not by luck.

â¸»

If you want, next step we can:
	â€¢	add a â€œRemaining songs availableâ€ meter
	â€¢	or add soft warnings before generation if the library is too small

But first: patch the two leaks above. This is the real fix.