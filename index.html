<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Setlist Generator v3.7.0 â€” Phase 6: Energy Curve + Tonal Gravity Overhaul, SA Optimizer, Templates</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>

  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Manrope:wght@400;500;600;700&family=Oswald:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --primary: #1a1a1a;
      --secondary: #2d2d2d;
      --accent: #ff6b35;
      --accent-dark: #e85a28;
      --text: #ffffff;
      --text-muted: #9aa0a6;
      --border: #404040;
      --success: #4ade80;
      --warning: #fbbf24;
      --error: #ef4444;
      --ballad: #60a5fa;
      --uptempo: #f87171;
      --midtempo: #fbbf24;
      --funk: #a78bfa;
      --shuffle: #34d399;
      --swing: #fb923c;
      --groove: #ec4899;
      --locked: #4ade80;
      --toast-bg: rgba(45,45,45,.95);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Manrope', system-ui, -apple-system, Arial, sans-serif;
      background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
      color: var(--text);
      min-height: 100vh; overflow-x: hidden;
    }
    .app-container { max-width: 1600px; margin: 0 auto; padding: 1.25rem; }
    header.header { text-align: center; margin: 1rem 0 2rem; position: relative; }
    header.header::before {
      content: ''; position: absolute; top: -16px; left: 50%; transform: translateX(-50%);
      width: 100px; height: 4px; background: linear-gradient(90deg, var(--accent), var(--accent-dark)); border-radius: 2px;
    }
    h1 {
      font-family: 'Space Mono', monospace; font-size: 2.2rem; font-weight: 700; letter-spacing: -0.02em; margin-bottom: .25rem;
      background: linear-gradient(135deg, var(--text) 0%, var(--text-muted) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .subtitle { color: var(--text-muted); font-size: .95rem; letter-spacing: .08em; text-transform: uppercase; }
    .band-bar {
      background: var(--secondary); border: 1px solid var(--border); border-radius: 10px;
      padding: .75rem 1rem; margin: 0 0 1rem; display: flex; gap: .75rem; align-items: center; justify-content: space-between;
    }
    .band-left { display: flex; align-items: center; gap: .75rem; }
    .band-pill {
      display: inline-flex; gap: .5rem; align-items: center; background: var(--primary);
      border: 1px solid var(--border); border-radius: 999px; padding: .4rem .75rem; font-size: .9rem;
    }
    .band-pill .swatch { width: 12px; height: 12px; border-radius: 999px; border: 1px solid var(--border); }
    .btn {
      padding: .65rem 1rem; border: 1px solid var(--border); border-radius: 8px; background: var(--primary); color: var(--text);
      font-weight: 600; font-size: .85rem; letter-spacing: .04em; cursor: pointer; transition: .2s ease;
    }
    .btn:hover { border-color: var(--accent); }
    .btn:disabled { opacity: .55; cursor: not-allowed; }
    .btn-primary { background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%); border-color: transparent; }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.35); }
    .btn-small { padding: .45rem .75rem; font-size: .75rem; }
    .btn-toggle-active { border-color: var(--accent); color: var(--text); }
    .btn-toggle-active.btn-primary { box-shadow: 0 4px 12px rgba(255, 107, 53, 0.35); }

    .main-grid { display: grid; grid-template-columns: 420px 1fr; gap: 1rem; }
    .panel {
      background: var(--secondary); border: 1px solid var(--border); border-radius: 12px; padding: 1rem;
      box-shadow: 0 6px 24px rgba(0,0,0,.35);
    }
    .panel-header { display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border);
      padding-bottom: .6rem; margin-bottom: 1rem; }
    .panel-title { font-family: 'Space Mono', monospace; color: var(--accent); font-weight: 700; }

    label { display:block; margin-bottom: .35rem; font-size: .8rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .05em; }
    input, select, textarea {
      width: 100%; padding: .65rem .75rem; background: var(--primary); border: 1px solid var(--border); border-radius: 8px;
      color: var(--text); font-size: .9rem;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(255,107,53,.12); }
    .input-group { margin-bottom: .8rem; }
    .set-config { display:grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
    .toolbar { display:flex; gap:.6rem; flex-wrap: wrap; align-items:center; }

    .song-list { max-height: 420px; overflow:auto; }
    .song-item {
      background: var(--primary); border: 1px solid var(--border); border-radius: 8px; padding: .75rem;
      display:flex; align-items:center; justify-content: space-between; margin-bottom:.6rem;
    }
    .song-title { font-weight:700; margin-bottom: .2rem; }
    .song-meta { font-size: .8rem; color: var(--text-muted); display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .song-badge { padding: .15rem .4rem; border-radius: 4px; font-size: .7rem; font-weight:700; text-transform: uppercase; letter-spacing: .04em; }
    .style-ballad{background:var(--ballad); color:#111;} .style-uptempo{background:var(--uptempo); color:#111;}
    .style-midtempo{background:var(--midtempo); color:#111;} .style-funk{background:var(--funk); color:#111;}
    .style-shuffle{background:var(--shuffle); color:#111;} .style-swing{background:var(--swing); color:#111;}
    .style-groove{background:var(--groove); color:#111;}

    .setlists-container { display:grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 1rem; }
    .setlist { background: var(--secondary); border: 1px solid var(--border); border-radius: 12px; padding: 1rem; }
    .setlist-header { display:flex; align-items:center; justify-content: space-between; border-bottom:2px solid var(--accent); padding-bottom:.5rem; margin-bottom:.75rem; }
    .setlist-song {
      display:grid; grid-template-columns: 20px 32px 1fr 54px 60px; gap:.6rem; align-items:center;
      background: var(--primary); border:1px solid var(--border); border-left:3px solid transparent; border-radius: 8px; padding: .6rem; margin-bottom:.5rem;
      transition: opacity 0.2s, border-color 0.2s;
    }
    .setlist-song.locked { border-left-color: var(--locked); background: rgba(74,222,128,.06); }
    .song-number { color: var(--accent); font-family:'Space Mono', monospace; font-weight:700; text-align:center; }
    .song-time { font-size: .8rem; color: var(--text-muted); text-align:right; font-family:'Space Mono', monospace; }
    .song-actions { display:flex; gap:.4rem; justify-content:flex-end; }
    .action-btn {
      width:26px; height:26px; display:flex; align-items:center; justify-content:center;
      border:1px solid var(--border); border-radius:6px; background: transparent; color:var(--text-muted); cursor:pointer;
    }
    .action-btn:hover { background: var(--border); color: var(--text); }
    .action-btn:disabled { opacity:.5; cursor:not-allowed; }
    .action-btn.locked { color: var(--locked); }

    /* Drag and Drop */
    .setlist-song[draggable="true"] { cursor: grab; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }
    .setlist-song[draggable="true"]:active { cursor: grabbing; }
    .setlist-song.dragging { opacity: 0.4; border: 1px dashed var(--accent); pointer-events: none; }
    .setlist-song.drag-over-top { border-top: 3px solid var(--accent); margin-top: -2px; }
    .setlist-song.drag-over-bottom { border-bottom: 3px solid var(--accent); margin-bottom: -2px; }
    .drag-handle { cursor: grab; color: var(--text-muted); font-size: 1rem; user-select: none; -webkit-user-select: none; display: flex; align-items: center; touch-action: none; }
    .drag-handle:active { cursor: grabbing; }
    .drop-zone-between { padding: .6rem; border: 2px dashed var(--border); border-radius: 8px; text-align: center; color: var(--text-muted); font-size: .8rem; margin-top: .35rem; transition: .2s; }
    .drop-zone-between:hover, .drop-zone-between.drag-over { border-color: var(--accent); color: var(--accent); background: rgba(255,107,53,.06); }
    .setlist.drag-target { outline: 2px solid var(--accent); outline-offset: 2px; }
    .move-to-set-select { font-size: .7rem; padding: .1rem .2rem; background: var(--primary); color: var(--text-muted); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; max-width: 70px; }
    .move-to-set-select:hover { border-color: var(--accent); color: var(--text); }
    .reset-balance-bar { display: flex; gap: .5rem; align-items: center; }
    .reset-balance-bar .btn { font-size: .8rem; }

    /* Optimized Removal Zone (drag-to-delete) */
    .optimized-removal-zone {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      padding: 1.5rem 3rem; background: rgba(239, 68, 68, 0.9);
      color: white; border-radius: 12px; border: 2px dashed #ffb3b3;
      z-index: 9999; font-weight: bold; font-size: 1.1rem;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5); cursor: alias;
      text-align: center; user-select: none; -webkit-user-select: none;
      animation: removal-zone-pulse 1.5s ease-in-out infinite;
    }
    .optimized-removal-zone:hover {
      background: rgba(220, 38, 38, 0.95); border-color: #fff;
    }
    @keyframes removal-zone-pulse {
      0%, 100% { box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
      50% { box-shadow: 0 10px 35px rgba(239,68,68,0.6); }
    }

    .toast-container { position: fixed; bottom: 1.25rem; left: 50%; transform: translateX(-50%); z-index: 2000; }
    .toast {
      background: var(--toast-bg); border: 1px solid var(--border); color: var(--text);
      border-radius: 8px; padding: .75rem 1rem; display:flex; gap:.6rem; align-items:center; min-width: 240px;
    }

    .alert { margin:.6rem 0; padding:.6rem .75rem; border-radius:8px; border:1px solid transparent; font-size:.9rem; display:flex; gap:.45rem; align-items:baseline; }
    .alert-error{ border-color: var(--error); background: rgba(239,68,68,.12); color: var(--error); }
    .alert-success{ border-color: var(--success); background: rgba(74,222,128,.12); color: var(--success); }
    .alert-warning{ border-color: var(--warning); background: rgba(251,191,36,.12); color: var(--warning); }

    .modal-backdrop { position:fixed; inset:0; background: rgba(0,0,0,.5); display:flex; justify-content:center; align-items:center; z-index:1500; }
    .modal { width:min(520px, 92vw); background:var(--secondary); border:1px solid var(--border); border-radius:12px; padding:1rem; }

    .band-row { display:flex; align-items:center; justify-content: space-between; padding:.5rem; border:1px solid var(--border);
      border-radius:8px; margin-bottom:.5rem; background: var(--primary); }
    .band-id { font-family:'Space Mono', monospace; color: var(--text-muted); font-size: .75rem; }

    .print-only { display: none; }
    .generation-stats { background: var(--primary); border-radius: 8px; padding: .5rem .75rem; margin-top: .5rem; font-size: .8rem; color: var(--text-muted); }
    .generation-stats strong { color: var(--accent); }

    @media print {
      @page { size: letter portrait; margin: 0.25in; }
      body { background: #fff; color: #000; }
      .no-print { display: none !important; }
      .print-only { display: block; }
      .set-page {
        page-break-after: always; break-after: page;
        font-family: 'Oswald', 'Helvetica Neue', Arial, sans-serif; font-size: 20pt; font-weight: bold; line-height: 1.0;
        position: relative; overflow: hidden;
      }
      .set-page:last-child { page-break-after: auto; break-after: auto; }
      .set-page img { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    }
    /* Import Modal Styles */
    .import-modal { width: min(720px, 95vw); max-height: 90vh; overflow-y: auto; background: var(--secondary); border: 1px solid var(--border); border-radius: 12px; padding: 1.25rem; }
    .import-steps { display: flex; gap: .5rem; margin-bottom: 1rem; }
    .import-step { flex: 1; text-align: center; padding: .5rem; border-radius: 8px; font-size: .75rem; font-weight: 600; text-transform: uppercase; letter-spacing: .05em; background: var(--primary); color: var(--text-muted); border: 1px solid var(--border); }
    .import-step.active { border-color: var(--accent); color: var(--accent); }
    .import-step.completed { border-color: var(--success); color: var(--success); }
    .import-tabs { display: flex; gap: .5rem; margin-bottom: 1rem; }
    .import-tab { padding: .5rem .75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--primary); color: var(--text-muted); font-size: .8rem; font-weight: 600; cursor: pointer; }
    .import-tab.active { border-color: var(--accent); color: var(--text); }
    .import-preview-table { width: 100%; border-collapse: collapse; font-size: .8rem; margin: .75rem 0; }
    .import-preview-table th, .import-preview-table td { padding: .4rem .5rem; border: 1px solid var(--border); text-align: left; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .import-preview-table th { background: var(--primary); color: var(--accent); font-weight: 700; text-transform: uppercase; font-size: .7rem; letter-spacing: .05em; }
    .import-preview-table tr:nth-child(even) td { background: rgba(255,255,255,.02); }
    .import-mapping-grid { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; margin: .75rem 0; }
    .import-mapping-item label { margin-bottom: .25rem; }
    .import-mapping-item .confidence { font-size: .7rem; color: var(--success); margin-left: .5rem; }
    .import-options { display: grid; grid-template-columns: 1fr 1fr; gap: .5rem; margin: .75rem 0; }
    .import-option { display: flex; align-items: center; gap: .5rem; font-size: .8rem; color: var(--text-muted); cursor: pointer; }
    .import-option input[type="checkbox"] { width: auto; accent-color: var(--accent); }
    .import-results-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: .75rem; margin: .75rem 0; }
    .import-stat { background: var(--primary); border: 1px solid var(--border); border-radius: 8px; padding: .75rem; text-align: center; }
    .import-stat .number { font-size: 1.5rem; font-weight: 700; font-family: 'Space Mono', monospace; }
    .import-stat .label { font-size: .7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .05em; }
    .import-stat.success .number { color: var(--success); }
    .import-stat.warning .number { color: var(--warning); }
    .import-stat.error .number { color: var(--error); }
    .import-warnings-list { max-height: 200px; overflow-y: auto; margin: .75rem 0; }
    .import-warning-item { display: flex; gap: .5rem; align-items: baseline; padding: .35rem .5rem; font-size: .8rem; border-bottom: 1px solid var(--border); }
    .import-warning-item:last-child { border-bottom: none; }
    .import-warning-code { font-family: 'Space Mono', monospace; font-size: .7rem; color: var(--warning); min-width: 160px; }
    .import-guardrail { background: rgba(74,222,128,.08); border: 1px solid var(--success); border-radius: 8px; padding: .75rem; margin: .75rem 0; font-size: .85rem; color: var(--success); }
    .import-rejected-table { width: 100%; border-collapse: collapse; font-size: .8rem; margin: .5rem 0; }
    .import-rejected-table th, .import-rejected-table td { padding: .35rem .5rem; border: 1px solid var(--border); text-align: left; }
    .import-rejected-table th { background: rgba(239,68,68,.15); color: var(--error); font-size: .7rem; text-transform: uppercase; }
    .import-footer { display: flex; gap: .75rem; justify-content: flex-end; margin-top: 1rem; padding-top: .75rem; border-top: 1px solid var(--border); }
    .import-textarea { width: 100%; min-height: 150px; font-family: 'Space Mono', monospace; font-size: .8rem; resize: vertical; }
    .import-drop-zone { border: 2px dashed var(--border); border-radius: 12px; padding: 2rem; text-align: center; color: var(--text-muted); cursor: pointer; transition: .2s; }
    .import-drop-zone:hover, .import-drop-zone.dragover { border-color: var(--accent); color: var(--text); }
    .import-drop-zone input[type="file"] { display: none; }

    .info-trigger {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--primary);
      color: var(--text-muted);
      font-size: .72rem;
      font-weight: 700;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: .4rem;
      transition: all .18s ease;
    }
    .info-trigger:hover { color: var(--text); border-color: var(--accent); transform: translateY(-1px); }

    .info-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(8, 8, 12, .62);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1200;
      animation: infoFadeIn .2s ease;
      padding: 1rem;
    }
    .info-modal {
      width: min(580px, 95vw);
      border-radius: 14px;
      background: linear-gradient(155deg, rgba(45, 45, 45, .86), rgba(27, 27, 27, .92));
      border: 1px solid rgba(255, 255, 255, .14);
      box-shadow: 0 18px 55px rgba(0, 0, 0, .45);
      animation: infoPopIn .2s ease;
      overflow: hidden;
    }
    .info-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: .85rem 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, .1);
    }
    .info-modal-header h4 {
      margin: 0;
      color: var(--accent);
      font-size: .95rem;
      letter-spacing: .02em;
    }
    .info-modal-close {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 1.2rem;
      cursor: pointer;
      line-height: 1;
    }
    .info-modal-content {
      padding: 1rem;
      font-size: .87rem;
      color: #f1f3f4;
      line-height: 1.45;
    }
    @keyframes infoFadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes infoPopIn { from { opacity: .1; transform: translateY(8px) scale(.985); } to { opacity: 1; transform: translateY(0) scale(1); } }

    @media (max-width: 1100px){ .main-grid{ grid-template-columns: 1fr; } }
    @media (max-width: 700px){
      h1{ font-size: 1.8rem; }
      .setlist-song{ grid-template-columns: 18px 26px 1fr 46px 50px; }
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" src="./featureHelp.js"></script>
  <script type="text/babel" src="./InfoModal.jsx"></script>
  <script type="text/babel" src="./InfoTrigger.jsx"></script>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    /******************* UTILITIES & GUARDS *******************/
    const genId = () => (window.crypto && crypto.randomUUID) ? crypto.randomUUID() :
      ('id-' + Math.random().toString(36).slice(2) + Date.now().toString(36));

    const sanitizeInput = (input) => {
      if (typeof input !== 'string') return input;
      let cleaned = input;
      cleaned = cleaned.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
      cleaned = cleaned.replace(/<\/?[^>]+>/g, '');
      cleaned = cleaned.replace(/javascript:|data:|vbscript:/gi, '');
      return cleaned.trim();
    };

    const guardCSVCell = (s) => {
      if (s == null) return '';
      const str = String(s);
      return /^[=+\-@]/.test(str) ? `'${str}` : str;
    };

    // Define tuning constants for algorithm thresholds.
    // MAX_GUARD sets an upper bound on loop iterations when filling a set to avoid infinite loops.
    // DURATION_TOLERANCE_POSITIVE and DURATION_TOLERANCE_NEGATIVE expand the acceptable range when
    // choosing songs to fill a remaining duration. DEFAULT_PASSES controls the number of
    // refinement passes when optimizing tonal smoothness. Expose these as constants for easy
    // tuning rather than embedding magic numbers throughout the code.
    const MAX_GUARD = 10000;
    const DURATION_TOLERANCE_POSITIVE = 2.0;
    const DURATION_TOLERANCE_NEGATIVE = 6.0;
    const DEFAULT_PASSES = 4;
    const TONAL_SWAP_THRESHOLD = 1;

    // PHASE 2: CSV Quoting Fix
    function csvEscapeCell(value) {
      const s = guardCSVCell(value == null ? '' : String(value));
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    // Default song duration in minutes used when a duration is missing or zero.
    const DEFAULT_DURATION_MINUTES = 4;

    /**
     * Parse a duration string or number into minutes. Supports "m:ss" format or plain
     * numbers. If the value is missing, invalid, or evaluates to zero, a default
     * duration is returned. This prevents zero-length songs from consuming an entire
     * setlist in the generator.
     *
     * @param {string|number|null|undefined} v The raw duration value.
     * @returns {number} Duration in minutes, with a sensible default when necessary.
     */
    const parseDuration = (v) => {
      // If a positive number is provided directly, use it.
      if (typeof v === 'number') {
        return v > 0 ? v : DEFAULT_DURATION_MINUTES;
      }
      // Non-string values return the default duration.
      if (typeof v !== 'string') return DEFAULT_DURATION_MINUTES;
      const cleaned = v.replace(/[^\d.:]/g, '').trim();
      if (!cleaned) {
        return DEFAULT_DURATION_MINUTES;
      }
      if (cleaned.includes(':')) {
        const [minsStr, secsStr] = cleaned.split(':');
        const mins = Number(minsStr);
        const secs = Number(secsStr);
        const total = (mins || 0) + ((secs || 0) / 60);
        return total > 0 ? total : DEFAULT_DURATION_MINUTES;
      }
      const parsed = parseFloat(cleaned);
      return (parsed && parsed > 0) ? parsed : DEFAULT_DURATION_MINUTES;
    };

    const LS = {
      // Add logging for localStorage getter failures. Swallowing exceptions silently hides
      // corrupted data or JSON parse errors. Logging aids debugging without breaking runtime.
      get: (k) => {
        try {
          return JSON.parse(localStorage.getItem(k));
        } catch (err) {
          console.warn('LS.get error:', err);
          return null;
        }
      },
      set: (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch (err) { console.error('LS.set error:', err); } },
      remove: (k) => { try { localStorage.removeItem(k); } catch (err) { console.error('LS.remove error:', err); } }
    };

    const LS_KEYS = {
      bands: 'setlist_bands_v3',
      active: 'setlist_activeBandId_v3',
      bandSongs: (id) => `setlist_band_songs_v3_${id}`,
      bandSettings: (id) => `setlist_band_settings_v3_${id}`,
      bandHistory: (id) => `setlist_band_history_v3_${id}`,
      bandImports: (id) => `setlist_band_imports_v3_${id}`,
      bandGigs: (id) => `setlist_band_gigs_v3_${id}`,
      bandWatermark: (id) => `setlist_band_watermark_v3_${id}`
    };

    const ENERGY_MAP = {
      ballad: 2, acoustic: 2.5, waltz: 3, bossa: 3.5, blues: 3.5, jazz: 3.5,
      'slow blues': 2.5, latin: 4,
      swing: 4, country: 4, reggae: 4, midtempo: 4.5, soul: 4.5, rnb: 4.5,
      shuffle: 5, groove: 5.5, funk: 6, rock: 6.5, uptempo: 7, ska: 6.5,
      punk: 8, metal: 9, edm: 8.5, pop: 5
    };

    // Continuous energy curve: smooth sinusoidal arc replacing the old 4-zone step function.
    // curveType selects a preset shape; each preset has amplitude, frequency, phase, and baseline.
    const ENERGY_CURVE_PRESETS = {
      standard:    { amp: 1.5, freq: 1.0, phase: -0.3, base: 3.8, label: 'Standard' },
      party:       { amp: 1.0, freq: 0.8, phase: 0.0,  base: 4.8, label: 'Party / Club' },
      jazz:        { amp: 1.0, freq: 1.0, phase: -0.5, base: 3.2, label: 'Jazz Club' },
      festival:    { amp: 1.8, freq: 1.5, phase: -0.2, base: 4.2, label: 'Festival' },
      wedding:     { amp: 1.2, freq: 1.0, phase: -0.3, base: 4.0, label: 'Wedding / Corporate' },
      acoustic:    { amp: 0.8, freq: 1.0, phase: -0.4, base: 3.0, label: 'Acoustic / Coffeehouse' }
    };

    function targetEnergyCurve(position, curveType) {
      const c = ENERGY_CURVE_PRESETS[curveType] || ENERGY_CURVE_PRESETS.standard;
      return Math.max(1, Math.min(10, c.base + c.amp * Math.sin(Math.PI * position * c.freq + c.phase)));
    }

    // Composite energy: blend style-based energy with BPM-derived energy when available.
    function getCompositeEnergy(song) {
      const styleE = ENERGY_MAP[(song.style || '').toLowerCase()] || null;
      const bpm = parseFloat(song.bpm);
      const bpmE = (bpm && bpm > 0) ? Math.min(10, Math.max(1, (bpm - 60) / 20 + 2)) : null;
      if (styleE !== null && bpmE !== null) return 0.6 * styleE + 0.4 * bpmE;
      if (styleE !== null) return styleE;
      if (bpmE !== null) return bpmE;
      return 4; // neutral default for songs with no data
    }


    /******************* CSV IMPORT: NORMALIZATION ENGINE *******************/

    const IMPORT_VALID_KEYS = new Set([
      "C","Db","D","Eb","E","F","F#","G","Ab","A","Bb","B",
      "Cm","Dbm","Dm","Ebm","Em","Fm","F#m","Gm","Abm","Am","Bbm","Bm"
    ]);

    const IMPORT_DESCRIPTOR_TOKENS = [
      "instrumental","slow","blues","shuffle","ballad","funk","reggae",
      "dom","dominant","mixolydian","dorian","phrygian","lydian","locrian",
      "major","minor","maj","min"
    ];

    const IMPORT_COLUMN_SYNONYMS = {
      title: ["title","song","song title","name","tune","track"],
      artist: ["artist","band","performer","by","group"],
      duration: ["duration","dur","time","length","minutes","min"],
      style: ["style","genre","type","feel","category"],
      key: ["key","tonality","pitch","root"],
      tempo: ["tempo","bpm","speed"],
      vocalist: ["vocalist","singer","lead","vox","vocal"]
    };

    function importNormalizeWhitespace(s) {
      const original = s ?? "";
      const trimmed = String(original).replace(/\s+/g, " ").trim();
      const warnings = [];
      if (trimmed !== original) warnings.push("title_trimmed");
      return { value: trimmed, warnings, original };
    }

    function importNormalizeSmartPunct(s) {
      const original = s ?? "";
      const converted = String(original)
        .replace(/[\u201C\u201D]/g, '"')
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u2014\u2013]/g, "-")
        .replace(/\u00A0/g, " ");
      const warnings = [];
      if (converted !== original) warnings.push("title_smart_punct");
      return { value: converted, warnings, original };
    }

    function importStripMetaParenEnd(title) {
      const original = title ?? "";
      const metaRe = /\s*\((demo|live|alt\.?\s*version|version|edit|radio\s*edit|\d{4})\)\s*$/i;
      const stripped = String(original).replace(metaRe, "").trim();
      const warnings = [];
      if (stripped !== original) warnings.push("title_meta_paren_stripped");
      return { value: stripped, warnings, original };
    }

    function importNormalizeTitle(title, opts) {
      const res1 = importNormalizeWhitespace(title);
      const res2 = importNormalizeSmartPunct(res1.value);
      let warnings = [...res1.warnings, ...res2.warnings];
      let val = res2.value;
      if (opts.stripMetaParen) {
        const res3 = importStripMetaParenEnd(val);
        val = res3.value;
        warnings.push(...res3.warnings);
      }
      return { value: val, warnings, original: title ?? "" };
    }

    function importNormalizeKeySingle(k) {
      const original = k ?? "";
      let s = String(original).replace(/\s+/g, " ").trim();
      const warnings = [];
      if (!s) return { value: "", warnings, original };
      s = s.replace(/\([^)]*\)/g, " ").replace(/\s+/g, " ").trim();
      const tokens = s.split(" ").filter(Boolean);
      const cleaned = tokens.filter(t => !IMPORT_DESCRIPTOR_TOKENS.includes(t.toLowerCase()));
      s = cleaned.join(" ").trim();
      s = s.replace(/maj(or)?$/i, "");
      s = s.replace(/min(or)?$/i, "m");
      const m = s.match(/^([A-Ga-g])\s*(#|b)?\s*(m)?$/);
      if (!m) return { value: "", warnings, original };
      let root = m[1].toUpperCase();
      let accidental = m[2] ? m[2] : "";
      let minor = m[3] ? "m" : "";
      const out = root + (accidental === "b" ? "b" : accidental) + minor;
      if (!IMPORT_VALID_KEYS.has(out)) return { value: "", warnings, original };
      return { value: out, warnings, original };
    }

    function importNormalizeKey(rawKey) {
      const original = rawKey ?? "";
      let s = String(original).trim();
      const warnings = [];
      if (!s) return { value: "", warnings, original };
      const parts = s.replace(/\bor\b/gi, "/").split(/[/,;|]+/).map(p => p.trim()).filter(Boolean);
      for (let i = 0; i < parts.length; i++) {
        const candidate = importNormalizeKeySingle(parts[i]);
        if (candidate.value) {
          if (parts.length > 1) warnings.push("multi_key_first_selected");
          return { value: candidate.value, warnings: [...warnings, ...candidate.warnings], original };
        }
      }
      warnings.push("key_invalid");
      return { value: "", warnings, original };
    }

    function importNormalizeTempo(rawTempo, opts) {
      const original = rawTempo ?? "";
      const warnings = [];
      let s = String(original).trim();
      if (!s) {
        if (opts.defaultTempo != null) {
          warnings.push("tempo_default_applied");
          return { value: String(opts.defaultTempo), warnings, original };
        }
        return { value: "", warnings, original };
      }
      const rangeMatch = s.match(/(\d+)\s*[-\u2013]\s*(\d+)/);
      if (rangeMatch) {
        warnings.push("tempo_range_first_selected");
        s = rangeMatch[1];
      }
      const intMatch = s.match(/(\d+)/);
      if (!intMatch) {
        if (opts.defaultTempo != null) {
          warnings.push("tempo_default_applied");
          return { value: String(opts.defaultTempo), warnings, original };
        }
        return { value: "", warnings, original };
      }
      const bpm = parseInt(intMatch[1], 10);
      if (bpm < 1 || bpm > 300) {
        warnings.push("tempo_out_of_range");
        return { value: "", warnings, original };
      }
      return { value: String(bpm), warnings, original };
    }

    function importNormalizeVocalist(rawVox, opts) {
      const original = rawVox ?? "";
      const warnings = [];
      let s = String(original).trim();
      if (!s) {
        warnings.push("vocalist_default_all");
        return { value: opts.defaultVocalist || "ALL", warnings, original };
      }
      if (/[/,&]+/.test(s)) {
        warnings.push("multi_vocalist_first_selected");
        s = s.split(/[/,&]+/)[0].trim();
      }
      return { value: s, warnings, original };
    }

    function importNormalizeRow(rowObj, mapping, opts) {
      const warnings = [];
      const changes = [];
      const rawTitle = rowObj[mapping.titleCol] ?? "";
      const rawArtist = mapping.artistCol != null ? (rowObj[mapping.artistCol] ?? "") : "";
      const rawDuration = mapping.durationCol != null ? (rowObj[mapping.durationCol] ?? "") : "";
      const rawStyle = mapping.styleCol != null ? (rowObj[mapping.styleCol] ?? "") : "";
      const rawKey = mapping.keyCol != null ? (rowObj[mapping.keyCol] ?? "") : "";
      const rawTempo = mapping.tempoCol != null ? (rowObj[mapping.tempoCol] ?? "") : "";
      const rawVox = mapping.vocalistCol != null ? (rowObj[mapping.vocalistCol] ?? "") : "";

      const t = importNormalizeTitle(rawTitle, opts);
      warnings.push(...t.warnings);
      if (t.original !== t.value) changes.push({ field: "title", original: t.original, normalized: t.value });

      // Artist: trim whitespace and normalize
      const artistVal = importNormalizeWhitespace(rawArtist);
      warnings.push(...artistVal.warnings.map(w => w.replace('title_', 'artist_')));
      if (artistVal.original !== artistVal.value) changes.push({ field: "artist", original: artistVal.original, normalized: artistVal.value });

      // Duration: parse m:ss or plain number
      let durationVal = String(rawDuration).trim();
      if (durationVal && durationVal.includes(':')) {
        const [m, s] = durationVal.split(':').map(Number);
        durationVal = String(Math.round(((m || 0) + ((s || 0) / 60)) * 100) / 100);
      } else if (durationVal) {
        const num = parseFloat(durationVal);
        durationVal = (num > 0) ? String(num) : "";
      }

      // Style: normalize to lowercase, map known aliases
      const STYLE_ALIASES = {
        'classic rock': 'rock', 'hard rock': 'rock', 'soft rock': 'midtempo',
        'slow blues': 'blues', 'fast blues': 'shuffle', 'r&b': 'rnb', 'r and b': 'rnb',
        'hip hop': 'groove', 'hip-hop': 'groove', 'bossa nova': 'bossa',
        'folk': 'acoustic', 'singer-songwriter': 'acoustic', 'alternative': 'rock',
        'indie': 'midtempo', 'grunge': 'rock', 'heavy metal': 'metal',
        'electronic': 'edm', 'dance': 'edm', 'disco': 'funk'
      };
      let styleVal = String(rawStyle).trim().toLowerCase();
      if (STYLE_ALIASES[styleVal]) {
        const originalStyle = styleVal;
        styleVal = STYLE_ALIASES[styleVal];
        changes.push({ field: "style", original: originalStyle, normalized: styleVal });
        warnings.push("style_aliased");
      }
      // Validate against known styles
      const KNOWN_STYLES = new Set(Object.keys(ENERGY_MAP));
      if (styleVal && !KNOWN_STYLES.has(styleVal)) {
        warnings.push("style_unknown");
      }

      const k = opts.normalizeKeys ? importNormalizeKey(rawKey) : { value: String(rawKey).trim(), warnings: [], original: String(rawKey) };
      warnings.push(...k.warnings);
      if (k.original !== k.value) changes.push({ field: "key", original: k.original, normalized: k.value });

      const p = opts.normalizeTempo ? importNormalizeTempo(rawTempo, opts) : { value: String(rawTempo).trim(), warnings: [], original: String(rawTempo) };
      warnings.push(...p.warnings);
      if (p.original !== p.value) changes.push({ field: "tempo", original: p.original, normalized: p.value });

      const v = opts.normalizeVocalist ? importNormalizeVocalist(rawVox, opts) : { value: String(rawVox).trim(), warnings: [], original: String(rawVox) };
      warnings.push(...v.warnings);
      if (v.original !== v.value) changes.push({ field: "vocalist", original: v.original, normalized: v.value });

      const out = { title: t.value, artist: artistVal.value, duration: durationVal, style: styleVal, key: k.value, tempo: p.value, vocalist: v.value };
      const rejectReason = !out.title ? "empty_title" : null;
      return { out, rejectReason, warnings, changes };
    }

    function importNormalizeAll(parsedRows, mapping, opts) {
      const rows = [];
      const rejected = [];
      const warningCounts = {};
      const rowChanges = [];
      parsedRows.forEach((rowObj, idx) => {
        const res = importNormalizeRow(rowObj, mapping, opts);
        res.warnings.forEach(w => warningCounts[w] = (warningCounts[w] || 0) + 1);
        if (res.rejectReason) {
          rejected.push({ rowIndex: idx + 1, reason: res.rejectReason, raw: rowObj });
          return;
        }
        rows.push(res.out);
        if (rowChanges.length < 200 && res.changes.length) {
          rowChanges.push({ rowIndex: idx + 1, changes: res.changes });
        }
      });
      return {
        rows, rejected,
        report: { rowsParsed: parsedRows.length, rowsImported: rows.length, rowsRejected: rejected.length, warningCounts, sampleChanges: rowChanges }
      };
    }

    function importToCanonicalCSV(rows) {
      const header = ["Title","Artist","Duration","Style","Key","BPM","Vocalist"];
      const esc = (s) => `"${String(s ?? "").replace(/"/g,'""')}"`;
      const lines = [header.join(",")];
      for (const r of rows) {
        lines.push([
          esc(r.title), esc(r.artist || ""), r.duration || "", esc(r.style || ""),
          esc(r.key), r.tempo ? String(parseInt(r.tempo, 10)) : "", esc(r.vocalist)
        ].join(","));
      }
      return lines.join("\n");
    }

    function importDetectDelimiter(text) {
      const lines = text.split(/\r?\n/).slice(0, 10).filter(l => l.trim());
      const delimiters = [",", "\t", "|", ";"];
      let best = ",";
      let bestScore = -1;
      for (const d of delimiters) {
        const counts = lines.map(l => l.split(d).length - 1);
        if (counts.length === 0) continue;
        const min = Math.min(...counts);
        const max = Math.max(...counts);
        const stability = min > 0 && (max - min) <= 1 ? 1 : 0;
        const score = min * 10 + stability * 100;
        if (score > bestScore) { bestScore = score; best = d; }
      }
      return best;
    }

    function importAutoMapColumns(headers) {
      const mapping = { titleCol: null, artistCol: null, durationCol: null, styleCol: null, keyCol: null, tempoCol: null, vocalistCol: null };
      const confidences = {};
      const used = new Set();

      for (const [field, synonyms] of Object.entries(IMPORT_COLUMN_SYNONYMS)) {
        let bestIdx = null;
        let bestScore = 0;
        headers.forEach((h, idx) => {
          if (used.has(idx)) return;
          const lh = h.toLowerCase().trim();
          let score = 0;
          for (const syn of synonyms) {
            if (lh === syn) { score = Math.max(score, 100); break; }
            if (lh.startsWith(syn)) score = Math.max(score, 70);
            else if (lh.includes(syn)) score = Math.max(score, 60);
          }
          if (score > bestScore) { bestScore = score; bestIdx = idx; }
        });
        if (bestIdx !== null && bestScore >= 50) {
          const colKey = field + "Col";
          mapping[colKey] = bestIdx;
          confidences[colKey] = bestScore;
          used.add(bestIdx);
        }
      }
      return { mapping, confidences };
    }

    /******************* END CSV IMPORT ENGINE *******************/


    /******************* PDF IMPORT ENGINE *******************/

    /**
     * Extract text content from a PDF file using pdf.js.
     * Returns an array of strings, one per page.
     */
    async function pdfExtractText(arrayBuffer) {
      if (!window.pdfjsLib) throw new Error('PDF.js not loaded');
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const pages = [];
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        // Group items by Y position to reconstruct rows
        const items = content.items.filter(item => item.str.trim());
        const rows = [];
        let currentY = null;
        let currentRow = [];
        // Sort by Y (descending, since PDF Y is bottom-up) then by X
        items.sort((a, b) => {
          const yDiff = b.transform[5] - a.transform[5];
          if (Math.abs(yDiff) > 3) return yDiff;
          return a.transform[4] - b.transform[4];
        });
        for (const item of items) {
          const y = Math.round(item.transform[5]);
          if (currentY === null || Math.abs(y - currentY) > 3) {
            if (currentRow.length) rows.push(currentRow.join('\t'));
            currentRow = [item.str.trim()];
            currentY = y;
          } else {
            currentRow.push(item.str.trim());
          }
        }
        if (currentRow.length) rows.push(currentRow.join('\t'));
        pages.push(rows.join('\n'));
      }
      return pages;
    }

    // Known style values for BandHelper / Zemba-style PDFs
    const PDF_KNOWN_STYLES = new Set([
      'uptempo','ballad','midtempo','groove','shuffle','swing','funk',
      'slow blues','rock','blues','country','jazz','reggae','latin','pop'
    ]);

    /**
     * Detect column header row and return column index mapping.
     * Matches headers like: "# TITLE ARTIST DURATION STYLE KEY BPM VOCALIST"
     * Returns { detected: true, map: { title, artist, duration, style, key, bpm, vocalist } }
     * or { detected: false }
     */
    function pdfDetectHeaderRow(allLines) {
      for (let i = 0; i < Math.min(allLines.length, 15); i++) {
        const line = allLines[i];
        const parts = line.split(/\t/).map(s => s.trim().toLowerCase());
        // Need at least title and one other recognizable column
        const titleIdx = parts.findIndex(p => /^(title|song|song\s*title|tune)$/.test(p));
        if (titleIdx < 0) continue;

        const artistIdx = parts.findIndex(p => /^(artist|band|performer)$/.test(p));
        const durationIdx = parts.findIndex(p => /^(duration|dur|time|length)$/.test(p));
        const styleIdx = parts.findIndex(p => /^(style|genre|type|feel)$/.test(p));
        const keyIdx = parts.findIndex(p => /^(key|tonality|pitch)$/.test(p));
        const bpmIdx = parts.findIndex(p => /^(bpm|tempo|speed)$/.test(p));
        const vocalistIdx = parts.findIndex(p => /^(vocalist|singer|vox|vocal|vocals|lead)$/.test(p));
        const numIdx = parts.findIndex(p => /^(#|no\.?|number|num)$/.test(p));

        // Must have at least title + artist or title + 2 other columns
        const found = [artistIdx, durationIdx, styleIdx, keyIdx, bpmIdx].filter(i => i >= 0).length;
        if (found < 1) continue;

        return {
          detected: true,
          headerLineIdx: i,
          map: {
            num: numIdx,
            title: titleIdx,
            artist: artistIdx,
            duration: durationIdx,
            style: styleIdx,
            key: keyIdx,
            bpm: bpmIdx,
            vocalist: vocalistIdx
          }
        };
      }
      return { detected: false };
    }

    /**
     * Parse a row using detected column positions (header-mapped mode).
     * Used for BandHelper / Zemba-style PDFs with clear column structure.
     */
    function pdfParseWithColumnMap(line, colMap) {
      const trimmed = line.trim();
      if (!trimmed) return null;

      const parts = trimmed.split(/\t/).map(s => s.trim());
      if (parts.length < 2) return null;

      // Get title - required
      const title = colMap.title >= 0 && colMap.title < parts.length ? parts[colMap.title] : '';
      if (!title || /^(title|#|number)\b/i.test(title)) return null;

      // Skip non-data rows (headers repeated on new pages, summary rows)
      if (/^\d+\s+songs?[,\s]/i.test(trimmed)) return null;

      const get = (idx) => (idx >= 0 && idx < parts.length) ? parts[idx] : '';

      const artist = get(colMap.artist);
      const rawDuration = get(colMap.duration);
      const style = get(colMap.style);
      const rawKey = get(colMap.key);
      const rawBpm = get(colMap.bpm);
      const vocalist = get(colMap.vocalist);

      // Parse duration: could be M:SS, plain minutes, or decimal
      let duration = '';
      if (rawDuration) {
        if (/^\d{1,2}:\d{2}$/.test(rawDuration)) {
          const [m, s] = rawDuration.split(':').map(Number);
          duration = String(Math.round((m + s / 60) * 100) / 100);
        } else {
          const num = parseFloat(rawDuration);
          if (num > 0) duration = String(num);
        }
      }

      // Parse BPM: strip decimal (122.0 -> 122)
      let bpm = '';
      if (rawBpm) {
        const bpmMatch = rawBpm.match(/(\d+)/);
        if (bpmMatch) bpm = bpmMatch[1];
      }

      // Normalize key: handle Cmaj, Bbm, F#, etc.
      let key = '';
      if (rawKey) {
        let k = rawKey.trim();
        k = k.replace(/maj(or)?$/i, '');
        if (/^[A-Ga-g][b#]?m?$/i.test(k)) {
          key = k.charAt(0).toUpperCase() + k.slice(1);
        } else {
          key = rawKey.trim();
        }
      }

      if (!title) return null;

      return {
        number: 0,
        title: title.trim(),
        artist: artist.trim(),
        vocalist: vocalist.trim(),
        duration,
        style: style.trim().toLowerCase(),
        key: key.trim(),
        bpm: bpm.trim()
      };
    }

    /**
     * Parse a line using heuristic detection (no header row found).
     * Works for DSJ-style PDFs with numbered rows and M:SS durations.
     * Returns { number, title, artist, vocalist, duration, key, bpm, style } or null
     */
    function pdfParseBandListLine(line) {
      // Skip header rows and empty lines
      const trimmed = line.trim();
      if (!trimmed) return null;
      if (/^(title|#|number)\b/i.test(trimmed)) return null;
      if (/^\d+\s+songs?,/i.test(trimmed)) return null; // "56 songs, 4:04" summary

      // Try to detect a numbered row: starts with digits
      const numberedMatch = trimmed.match(/^(\d+)\s+(.+)/);
      if (!numberedMatch) return null;

      const rowNum = parseInt(numberedMatch[1], 10);
      const rest = numberedMatch[2];

      // Split by tab or 2+ spaces
      const parts = rest.split(/\t|  +/).map(s => s.trim()).filter(Boolean);

      if (parts.length < 2) return null;

      // Heuristic detection of fields (scan from right to left)
      let durationIdx = -1;
      let keyIdx = -1;
      let bpmIdx = -1;
      let styleIdx = -1;

      for (let i = parts.length - 1; i >= 0; i--) {
        const p = parts[i];
        const pLower = p.toLowerCase();

        // BPM: 2-3 digits, optionally with .0 decimal
        if (bpmIdx === -1 && /^\d{2,3}(\.\d)?$/.test(p)) {
          bpmIdx = i;
        // Key: musical key notation (A-G with optional accidental and minor)
        } else if (keyIdx === -1 && /^[A-G][b#]?(m|maj|min)?$/i.test(p) && p.length <= 4) {
          keyIdx = i;
        // Key: multi-key like "C / F / F /"
        } else if (keyIdx === -1 && /^[A-G][b#]?\s*\/\s*[A-G]/.test(p)) {
          keyIdx = i;
        // Style: known style value
        } else if (styleIdx === -1 && PDF_KNOWN_STYLES.has(pLower)) {
          styleIdx = i;
        // Duration: M:SS format
        } else if (durationIdx === -1 && /^\d{1,2}:\d{2}$/.test(p)) {
          durationIdx = i;
        // Duration: plain number 1-20 (minutes) - only if no M:SS found yet
        } else if (durationIdx === -1 && /^\d{1,2}(\.\d+)?$/.test(p)) {
          const num = parseFloat(p);
          if (num > 0 && num <= 20) durationIdx = i;
        }
      }

      // Parse duration
      let duration = '';
      if (durationIdx >= 0) {
        const dp = parts[durationIdx];
        if (/^\d{1,2}:\d{2}$/.test(dp)) {
          const [m, s] = dp.split(':').map(Number);
          duration = String(Math.round((m + s / 60) * 100) / 100);
        } else {
          const num = parseFloat(dp);
          if (num > 0) duration = String(num);
        }
      }

      let key = keyIdx >= 0 ? parts[keyIdx].replace(/\s*\/\s*/g, '/').replace(/maj(or)?$/i, '').trim() : '';
      let bpm = bpmIdx >= 0 ? parts[bpmIdx].replace(/\.0$/, '') : '';
      let style = styleIdx >= 0 ? parts[styleIdx].toLowerCase() : '';

      // Collect remaining text parts (title, artist, vocalist)
      const metaIndices = new Set([durationIdx, keyIdx, bpmIdx, styleIdx].filter(i => i >= 0));
      const textParts = parts.filter((_, i) => !metaIndices.has(i));

      let title = '', artist = '', vocalist = '';

      if (textParts.length >= 3) {
        title = textParts[0];
        artist = textParts[1];
        vocalist = textParts.slice(2).join(' ');
      } else if (textParts.length === 2) {
        title = textParts[0];
        artist = textParts[1];
      } else if (textParts.length === 1) {
        title = textParts[0];
      }

      if (!title) return null;

      return {
        number: rowNum,
        title: title.trim(),
        artist: artist.trim(),
        vocalist: vocalist.trim(),
        duration,
        style,
        key: key.trim(),
        bpm: bpm.trim()
      };
    }

    /**
     * Parse all pages of extracted PDF text into song rows.
     * First tries header-detection (BandHelper/Zemba format),
     * then falls back to heuristic parsing (DSJ format).
     */
    function pdfParseAllPages(pageTexts) {
      const allLines = pageTexts.join('\n').split('\n');

      // Try header-based detection first
      const headerResult = pdfDetectHeaderRow(allLines);
      if (headerResult.detected) {
        const songs = [];
        for (let i = 0; i < allLines.length; i++) {
          if (i === headerResult.headerLineIdx) continue;
          // Skip repeated header rows on subsequent pages
          const lower = allLines[i].toLowerCase();
          if (/\btitle\b/.test(lower) && /\bartist\b/.test(lower)) continue;
          const parsed = pdfParseWithColumnMap(allLines[i], headerResult.map);
          if (parsed) songs.push(parsed);
        }
        if (songs.length > 0) return songs;
      }

      // Fallback: heuristic line-by-line parsing (DSJ-style)
      const songs = [];
      for (const line of allLines) {
        const parsed = pdfParseBandListLine(line);
        if (parsed) songs.push(parsed);
      }
      return songs;
    }

    /**
     * Convert parsed PDF songs into the standard CSV format string.
     */
    function pdfSongsToCSV(songs) {
      const headers = ['Title', 'Artist', 'Duration', 'Style', 'Key', 'BPM', 'Vocalist'];
      const esc = (s) => {
        const str = String(s ?? '');
        if (/[",\n\r]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
        return str;
      };
      const lines = [headers.join(',')];
      for (const s of songs) {
        lines.push([
          esc(s.title), esc(s.artist), esc(s.duration), esc(s.style || ''), esc(s.key), esc(s.bpm), esc(s.vocalist)
        ].join(','));
      }
      return lines.join('\n');
    }

    /******************* END PDF IMPORT ENGINE *******************/


/******************* PHASE 3B: TONAL GRAVITY (CIRCLE OF FIFTHS) *******************/
// Canonical internal tonics are taken from the fixed circle ordering below.
// Display tonics are musician-friendly (F# instead of Gb), but distances always use canonical tonics.

const CIRCLE_OF_FIFTHS = ["C","G","D","A","E","B","F#","Db","Ab","Eb","Bb","F"];
const SHARP_TO_FLAT = { "C#":"Db","D#":"Eb","F#":"Gb","G#":"Ab","A#":"Bb" };
const CANONICAL_SET = new Set(["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B","F#"]); // include F# for direct user input
const DISPLAY_OVERRIDES = { "Gb":"F#" };

function normalizeKey_TG(keyString, songTags = []) {
  if (!keyString || typeof keyString !== 'string') return null;
  const raw = keyString.trim().replace(/â™¯/g,'#').replace(/â™­/g,'b');
  if (!raw) return null;

  // detect tonic letter + accidental
  const m = raw.match(/^([A-G])\s*([#b]?)/);
  if (!m) { console.warn('[TonalGravity] Invalid key:', keyString); return null; }

  let tonic = (m[1] || '').toUpperCase() + (m[2] || '');
  // convert sharp to canonical flat where required (except F# which is explicitly on the circle)
  if (SHARP_TO_FLAT[tonic] && tonic !== 'F#') tonic = SHARP_TO_FLAT[tonic];

  // allow Gb internally even though circle uses F#
  if (tonic === 'Gb') tonic = 'F#';

  if (!CIRCLE_OF_FIFTHS.includes(tonic)) {
    // allow naturals that may parse oddly
    if (!CANONICAL_SET.has(tonic)) {
      console.warn('[TonalGravity] Unsupported tonic:', tonic, 'from', keyString);
      return null;
    }
  }

  const tags = Array.isArray(songTags) ? songTags.map(t => String(t).toLowerCase()) : [];
  const isMinor =
    /\bminor\b/i.test(raw) ||
    /\bmin\b/i.test(raw) ||
    (/m$/i.test(raw) && !/maj/i.test(raw)) ||
    tags.includes('minor') || tags.includes('dark');

  const mode = isMinor ? 'minor' : 'major';
  const displayTonic = DISPLAY_OVERRIDES[tonic] || tonic;

  return { tonic, mode, displayTonic };
}

function getCircleIndex_TG(tonic) {
  return CIRCLE_OF_FIFTHS.indexOf(tonic);
}

function circleDistance_TG(a, b) {
  const ia = getCircleIndex_TG(a);
  const ib = getCircleIndex_TG(b);
  if (ia < 0 || ib < 0) return 6;
  const diff = Math.abs(ia - ib);
  return Math.min(diff, 12 - diff);
}

function areRelativeKeys_TG(k1, k2) {
  if (!k1 || !k2) return false;
  if (k1.mode === k2.mode) return false;
  return circleDistance_TG(k1.tonic, k2.tonic) === 3;
}

function areParallelKeys_TG(k1, k2) {
  if (!k1 || !k2) return false;
  return k1.tonic === k2.tonic && k1.mode !== k2.mode;
}

// Directional harmonic movement: clockwise on the circle of fifths provides an energy
// boost, counterclockwise drains energy. Returns 'clockwise', 'counterclockwise', or 'same'.
function circleDirection_TG(fromTonic, toTonic) {
  const ia = getCircleIndex_TG(fromTonic);
  const ib = getCircleIndex_TG(toTonic);
  if (ia < 0 || ib < 0 || ia === ib) return 'same';
  const clockwise = (ib - ia + 12) % 12;
  const counterclockwise = (ia - ib + 12) % 12;
  return clockwise <= counterclockwise ? 'clockwise' : 'counterclockwise';
}

// Anchor key bonus: songs near the anchor key at set boundaries receive a small bonus.
function anchorKeyBonus_TG(songKey, anchorKey, position, setLength) {
  if (!songKey || !anchorKey) return 0;
  const dist = circleDistance_TG(songKey.tonic, anchorKey.tonic);
  const isNearBoundary = position < 2 || position > setLength - 3;
  if (isNearBoundary && dist <= 1) return 3;
  if (isNearBoundary && dist <= 2) return 1;
  return 0;
}

function determineAnchorKey_TG(songs, userAnchor = '') {
  const manual = userAnchor && typeof userAnchor === 'string' ? userAnchor.trim() : '';
  if (manual) {
    const nk = normalizeKey_TG(manual);
    if (nk) return nk;
  }

  const counts = {};
  for (const s of songs) {
    const nk = s.normalizedKey;
    if (!nk) continue;
    counts[nk.tonic] = (counts[nk.tonic] || 0) + 1;
  }
  const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([t])=>t);
  if (top.length === 0) return normalizeKey_TG('A'); // safe default

  let best = top[0], bestAvg = Infinity;
  for (const cand of top) {
    const avg = top.reduce((sum,t)=>sum+circleDistance_TG(cand,t),0) / top.length;
    if (avg < bestAvg) { bestAvg = avg; best = cand; }
  }
  return normalizeKey_TG(best);
}

function isContrastSlot_TG(pos, setLen, tonalSmoothness) {
  if (tonalSmoothness > 50) return false; // <=50 means allow contrast
  const cp = Math.floor(setLen * 0.66);
  return Math.abs(pos - cp) <= 1;
}

function calculateTonalTransitionScore_TG(prevSong, nextSong, pos, setLen, tonalSmoothness, opts) {
  // Null-safe: missing keys simply contribute 0 tonal score
  if (!prevSong?.normalizedKey || !nextSong?.normalizedKey) return 0;

  const a = prevSong.normalizedKey;
  const b = nextSong.normalizedKey;
  const dist = circleDistance_TG(a.tonic, b.tonic);

  let base = 0;
  if (dist <= 1) base = 10;
  else if (dist === 2) base = 6;
  else if (dist === 3) base = 2;
  else base = -4;

  // planned contrast slot
  if (isContrastSlot_TG(pos, setLen, tonalSmoothness) && dist >= 4) {
    base = Math.max(0, base);
  }

  let modeBonus = 0;
  if (areRelativeKeys_TG(a, b)) modeBonus += 5;
  if (areParallelKeys_TG(a, b)) modeBonus += 4;

  // repetition penalty (simple, fast)
  let repetitionPenalty = 0;
  if (a.tonic === b.tonic && a.mode === b.mode) repetitionPenalty -= 5;

  // Directional harmonic movement bonus: prefer clockwise during build phases,
  // counterclockwise during cool-down phases (Phase 4 enhancement)
  let directionBonus = 0;
  if (dist >= 1 && dist <= 2) {
    const dir = circleDirection_TG(a.tonic, b.tonic);
    const normalizedPos = setLen > 0 ? pos / setLen : 0.5;
    if (normalizedPos < 0.65 && dir === 'clockwise') directionBonus += 2;
    else if (normalizedPos >= 0.65 && dir === 'counterclockwise') directionBonus += 2;
  }

  // Anchor key proximity bonus at set boundaries
  let anchorBonus = 0;
  if (opts && opts.anchorKey) {
    anchorBonus = anchorKeyBonus_TG(b, opts.anchorKey, pos, setLen);
  }

  return base + modeBonus + repetitionPenalty + directionBonus + anchorBonus;
}

// generateTonalDiagnostics_TG analyses tonal transitions across the provided setlists.
// Previously unused parameters anchorKey and tonalSmoothness were removed to simplify
// the signature. The function now derives all needed context from the setlists
// themselves.
function generateTonalDiagnostics_TG(setlists) {
  const out = [];
  for (let setIdx = 0; setIdx < setlists.length; setIdx++) {
    const set = setlists[setIdx];
    const keyPath = set.songs.map(s => {
      const nk = s.normalizedKey;
      return nk ? { tonicCanonical: nk.tonic, tonicDisplay: nk.displayTonic, mode: nk.mode } : null;
    }).filter(Boolean);

    let sum = 0;
    let edges = 0;
    const contrastJumps = [];

    for (let i = 0; i < set.songs.length - 1; i++) {
      const a = set.songs[i].normalizedKey;
      const b = set.songs[i+1].normalizedKey;
      if (!a || !b) continue;
      const dist = circleDistance_TG(a.tonic, b.tonic);
      sum += dist; edges++;
      if (dist >= 4) {
        contrastJumps.push({
          position: i + 2,
          from: a.displayTonic + (a.mode === 'minor' ? 'm' : ''),
          to: b.displayTonic + (b.mode === 'minor' ? 'm' : ''),
          distance: dist
        });
      }
    }

    const avg = edges ? (sum / edges) : 0;
    const qualityScore = avg <= 2 ? "Excellent" : avg <= 3 ? "Good" : avg <= 4 ? "Fair" : "Needs Review";

    out.push({
      avgCircleDistance: Math.round(avg * 10) / 10,
      qualityScore,
      keyPath: keyPath.map(k => ({ tonic: k.tonicDisplay, mode: k.mode })), // safe for UI
      contrastJumps
    });
  }
  return out;
}

// Tonal Gravity generator wrapper: preserve Phase 2 validity, then refine ordering locally.
// Enhanced with lock-awareness, bidirectional sweeps, energy-aware swaps, anchor key
// integration, and directional harmonic movement.
function generateSetlistsCore_WithTonalGravity(songs, opts) {
  const enriched = (songs || []).map(s => ({
    ...s,
    normalizedKey: normalizeKey_TG(s.key, s.tags || [])
  }));

  const anchor = determineAnchorKey_TG(enriched, opts.anchorKey || '');
  const tonalOpts = { anchorKey: anchor };
  const smoothness = opts.tonalSmoothness ?? 70;

  // Always use core generator to satisfy duration/energy/locks robustly
  const base = generateSetlistsCore(enriched, opts);

  // Build a set of locked song IDs from the lockPlan so we skip them during tonal swaps
  const lockedIds = new Set();
  if (Array.isArray(opts.lockPlan)) {
    for (const plan of opts.lockPlan) {
      if (!Array.isArray(plan)) continue;
      for (const entry of plan) {
        if (entry && entry.song && entry.song.id) lockedIds.add(entry.song.id);
      }
    }
  }

  // Enhanced refinement: bidirectional sweeps with lock-awareness and energy checks
  base.forEach(set => {
    const len = set.songs.length;
    if (len < 3) return;

    const isLocked = (idx) => lockedIds.has(set.songs[idx]?.id);
    const curveType = opts.energyCurveType || 'standard';

    const PASSES = DEFAULT_PASSES; // now 4
    for (let pass = 0; pass < PASSES; pass++) {
      // Alternate sweep direction each pass for better convergence
      const forward = pass % 2 === 0;
      const start = forward ? 1 : len - 2;
      const end = forward ? len - 1 : 0;
      const step = forward ? 1 : -1;

      for (let i = start; forward ? i < end : i > end; i += step) {
        // Skip locked songs â€” they must not be repositioned
        if (isLocked(i) || isLocked(i + (forward ? 1 : -1))) continue;

        const j = forward ? i + 1 : i - 1;
        if (j < 0 || j >= len) continue;

        const prev = set.songs[Math.min(i, j) - 1];
        const curr = set.songs[Math.min(i, j)];
        const next = set.songs[Math.max(i, j)];
        const after = set.songs[Math.max(i, j) + 1];

        if (!prev || !curr || !next) continue;

        // Score current arrangement
        let currentScore = calculateTonalTransitionScore_TG(prev, curr, Math.min(i, j), len, smoothness, tonalOpts)
          + calculateTonalTransitionScore_TG(curr, next, Math.max(i, j), len, smoothness, tonalOpts);
        if (after) currentScore += calculateTonalTransitionScore_TG(next, after, Math.max(i, j) + 1, len, smoothness, tonalOpts);

        // Score swapped arrangement
        let swappedScore = calculateTonalTransitionScore_TG(prev, next, Math.min(i, j), len, smoothness, tonalOpts)
          + calculateTonalTransitionScore_TG(next, curr, Math.max(i, j), len, smoothness, tonalOpts);
        if (after) swappedScore += calculateTonalTransitionScore_TG(curr, after, Math.max(i, j) + 1, len, smoothness, tonalOpts);

        // Energy-aware swap check: penalize swaps that worsen energy curve adherence
        if (opts.useEnergyCurve) {
          const setDur = opts.setDuration || 45;
          const posA = Math.min(i, j) / len;
          const posB = Math.max(i, j) / len;
          const targetA = targetEnergyCurve(posA, curveType);
          const targetB = targetEnergyCurve(posB, curveType);
          const eA = getCompositeEnergy(curr);
          const eB = getCompositeEnergy(next);

          const currentEnergyFit = Math.abs(eA - targetA) + Math.abs(eB - targetB);
          const swappedEnergyFit = Math.abs(eB - targetA) + Math.abs(eA - targetB);
          // Apply energy degradation as a tonal score penalty
          const energyDelta = (swappedEnergyFit - currentEnergyFit) * 0.8;
          swappedScore -= energyDelta;
        }

        if (swappedScore > currentScore + TONAL_SWAP_THRESHOLD) {
          const lo = Math.min(i, j);
          const hi = Math.max(i, j);
          [set.songs[lo], set.songs[hi]] = [set.songs[hi], set.songs[lo]];
        }
      }
    }

    // Non-adjacent swap exploration (distance 2-3) for additional optimization
    for (let gap = 2; gap <= Math.min(3, Math.floor(len / 2)); gap++) {
      for (let i = 1; i < len - gap; i++) {
        const j = i + gap;
        if (isLocked(i) || isLocked(j)) continue;
        if (j >= len - 1 && (opts.forceCloser)) continue; // don't displace closer

        // Calculate local scores around both positions before and after swap
        const neighborScore = (arr) => {
          let sc = 0;
          for (let k = 1; k < arr.length; k++) {
            sc += calculateTonalTransitionScore_TG(
              { normalizedKey: arr[k-1].normalizedKey },
              { normalizedKey: arr[k].normalizedKey },
              k, len, smoothness, tonalOpts
            );
          }
          return sc;
        };

        // Gather affected window
        const minIdx = Math.max(0, i - 1);
        const maxIdx = Math.min(len - 1, j + 1);
        const window = set.songs.slice(minIdx, maxIdx + 1);
        const currentWindowScore = neighborScore(window);

        // Simulate swap
        const swapped = [...window];
        const relI = i - minIdx;
        const relJ = j - minIdx;
        [swapped[relI], swapped[relJ]] = [swapped[relJ], swapped[relI]];
        const swappedWindowScore = neighborScore(swapped);

        if (swappedWindowScore > currentWindowScore + TONAL_SWAP_THRESHOLD + 1) {
          [set.songs[i], set.songs[j]] = [set.songs[j], set.songs[i]];
        }
      }
    }

    set.totalTime = set.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);
  });

  // Simulated annealing deep optimization pass (when enabled)
  if (opts.optimizationLevel === 'deep') {
    const lockedIdSet = new Set();
    if (Array.isArray(opts.lockPlan)) {
      for (const plan of opts.lockPlan) {
        if (!Array.isArray(plan)) continue;
        for (const entry of plan) {
          if (entry && entry.song && entry.song.id) lockedIdSet.add(entry.song.id);
        }
      }
    }

    base.forEach(set => {
      if (set.songs.length < 4) return;
      set.songs = simulatedAnnealingOptimize(set.songs, {
        ...opts,
        _anchorKey: anchor,
        _lockedIds: lockedIdSet
      });
      set.totalTime = set.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);
    });
  }

  // Attach diagnostics and quality scores (non-breaking) when enabled
  try {
    base.diagnostics = generateTonalDiagnostics_TG(base);
    base.anchorKey = anchor?.displayTonic || anchor?.tonic || null;
    // Calculate unified quality score for each set
    base.qualityScores = base.map(set => calculateSetlistQualityScore(set, {
      ...opts,
      _anchorKey: anchor
    }));
  } catch (e) {
    console.warn('[TonalGravity] Diagnostics failed:', e);
  }

  return base;
}


    /******************* PHASE 4: SIMULATED ANNEALING OPTIMIZER *******************/
    // Deep optimization mode: uses simulated annealing to escape local optima and find
    // globally better setlist orderings. Operates on a fully generated setlist as input.
    function simulatedAnnealingOptimize(setlistSongs, opts) {
      const songs = [...setlistSongs];
      const len = songs.length;
      if (len < 4) return songs;

      const smoothness = opts.tonalSmoothness ?? 70;
      const curveType = opts.energyCurveType || 'standard';
      const useTonal = opts.useTonalGravity;
      const useEnergy = opts.useEnergyCurve;
      const anchorKey = opts._anchorKey || null;
      const affinities = opts.songAffinities || [];
      const antiAffinities = opts.songAntiAffinities || [];

      // PERF: Pre-cache composite energy values (avoids recalculating per iteration)
      const energyCache = new Map();
      for (const s of songs) {
        if (!energyCache.has(s.id)) energyCache.set(s.id, getCompositeEnergy(s));
      }
      const cachedEnergy = (s) => energyCache.get(s.id) ?? getCompositeEnergy(s);

      // PERF: Pre-cache energy curve targets for each position
      const targetEnergyCache = new Float64Array(len);
      for (let i = 0; i < len; i++) {
        targetEnergyCache[i] = targetEnergyCurve(len > 1 ? i / (len - 1) : 0.5, curveType);
      }

      // PERF: Pre-build affinity lookup maps (O(1) instead of O(k) per pair check)
      const affinitySet = new Set();
      for (const pair of affinities) {
        affinitySet.add(`${pair[0]}|${pair[1]}`);
        affinitySet.add(`${pair[1]}|${pair[0]}`);
      }
      const antiAffinitySet = new Set();
      for (const pair of antiAffinities) {
        antiAffinitySet.add(`${pair[0]}|${pair[1]}`);
        antiAffinitySet.add(`${pair[1]}|${pair[0]}`);
      }

      // Cost function: lower = better
      const cost = (arr) => {
        let c = 0;
        for (let i = 0; i < arr.length; i++) {
          // Energy curve adherence
          if (useEnergy) {
            const actual = cachedEnergy(arr[i]);
            c += Math.abs(actual - targetEnergyCache[i]) * 0.4;
          }

          // Energy transition smoothness
          if (useEnergy && i > 0) {
            const jump = Math.abs(cachedEnergy(arr[i]) - cachedEnergy(arr[i - 1]));
            if (jump > 2.5) c += (jump - 2.5) * 0.35;
          }

          // Tonal transitions
          if (useTonal && i > 0) {
            const score = calculateTonalTransitionScore_TG(
              arr[i - 1], arr[i], i, len, smoothness, { anchorKey }
            );
            c -= score * 0.3;
          }

          // Diversity: penalize consecutive same style/artist
          if (i > 0) {
            if (arr[i].style === arr[i - 1].style) c += 1.0;
            if (arr[i].artist === arr[i - 1].artist) c += 1.2;
          }

          // PERF: Check affinities inline using O(1) Set lookups
          if (i > 0) {
            const pairKey = `${arr[i - 1].id}|${arr[i].id}`;
            if (affinitySet.has(pairKey)) c -= 3; // adjacent affinity bonus
            if (antiAffinitySet.has(pairKey)) c += 4; // adjacent anti-affinity penalty
          }
        }

        // Check non-adjacent affinity/anti-affinity pairs (gap 2-3)
        for (let i = 0; i < arr.length - 2; i++) {
          for (let g = 2; g <= Math.min(3, arr.length - 1 - i); g++) {
            const pairKey = `${arr[i].id}|${arr[i + g].id}`;
            if (affinitySet.has(pairKey)) c -= 1; // close but not adjacent: small bonus
            if (g <= 2 && antiAffinitySet.has(pairKey)) c += 4; // too close penalty
          }
        }

        return c;
      };

      // Build set of locked indices (opener at 0, closer at len-1 if forced)
      const lockedIndices = new Set();
      if (opts.forceOpener) lockedIndices.add(0);
      if (opts.forceCloser) lockedIndices.add(len - 1);
      if (opts._lockedIds) {
        songs.forEach((s, idx) => {
          if (opts._lockedIds.has(s.id)) lockedIndices.add(idx);
        });
      }

      // PERF: Pre-build unlocked indices array (constant across iterations)
      const unlocked = [];
      for (let k = 0; k < len; k++) {
        if (!lockedIndices.has(k)) unlocked.push(k);
      }
      if (unlocked.length < 2) return songs;

      let current = [...songs];
      let currentCost = cost(current);
      let best = [...current];
      let bestCost = currentCost;

      // SA parameters
      const T0 = 10;
      const Tmin = 0.1;
      const alpha = 0.97;
      const iterations = Math.min(800, len * 60);
      const unlockedLen = unlocked.length;

      let T = T0;
      for (let iter = 0; iter < iterations && T > Tmin; iter++) {
        // PERF: Direct random index into pre-built unlocked array
        const ai = Math.floor(Math.random() * unlockedLen);
        let bi = Math.floor(Math.random() * (unlockedLen - 1));
        if (bi >= ai) bi++;
        const idxA = unlocked[ai];
        const idxB = unlocked[bi];

        const neighbor = [...current];
        [neighbor[idxA], neighbor[idxB]] = [neighbor[idxB], neighbor[idxA]];

        const neighborCost = cost(neighbor);
        const delta = neighborCost - currentCost;

        if (delta < 0 || Math.random() < Math.exp(-delta / T)) {
          current = neighbor;
          currentCost = neighborCost;
          if (currentCost < bestCost) {
            best = [...current];
            bestCost = currentCost;
          }
        }

        T *= alpha;
      }

      return best;
    }

    /******************* PHASE 4: UNIFIED QUALITY SCORE *******************/
    // Returns a 0-100 quality score for a generated setlist based on energy adherence,
    // tonal flow, diversity, and duration accuracy.
    function calculateSetlistQualityScore(set, opts) {
      const songs = set.songs || [];
      if (songs.length === 0) return 0;

      const curveType = opts.energyCurveType || 'standard';
      const smoothness = opts.tonalSmoothness ?? 70;
      const anchorKey = opts._anchorKey || null;
      let energyScore = 100;
      let tonalScore = 100;
      let diversityScore = 100;
      let durationScore = 100;

      // Energy adherence: how well songs match the target curve
      if (opts.useEnergyCurve) {
        let totalDeviation = 0;
        let maxDeviation = 0;
        for (let i = 0; i < songs.length; i++) {
          const pos = songs.length > 1 ? i / (songs.length - 1) : 0.5;
          const target = targetEnergyCurve(pos, curveType);
          const actual = getCompositeEnergy(songs[i]);
          const dev = Math.abs(actual - target);
          totalDeviation += dev;
          maxDeviation = Math.max(maxDeviation, dev);
        }
        const avgDev = totalDeviation / songs.length;
        energyScore = Math.max(0, 100 - avgDev * 15 - maxDeviation * 5);
      }

      // Tonal flow: average tonal transition quality
      if (opts.useTonalGravity) {
        let totalTonal = 0;
        let edges = 0;
        for (let i = 0; i < songs.length - 1; i++) {
          if (songs[i].normalizedKey && songs[i + 1].normalizedKey) {
            const sc = calculateTonalTransitionScore_TG(
              songs[i], songs[i + 1], i + 1, songs.length, smoothness, { anchorKey }
            );
            totalTonal += sc;
            edges++;
          }
        }
        if (edges > 0) {
          const avgTonal = totalTonal / edges;
          // Scale: -4 to 15 â†’ 0 to 100
          tonalScore = Math.max(0, Math.min(100, ((avgTonal + 4) / 19) * 100));
        }
      }

      // Diversity: check for consecutive same style/artist
      let sameStyleRuns = 0;
      let sameArtistRuns = 0;
      for (let i = 1; i < songs.length; i++) {
        if (songs[i].style === songs[i - 1].style) sameStyleRuns++;
        if (songs[i].artist === songs[i - 1].artist) sameArtistRuns++;
      }
      const maxRuns = Math.max(1, songs.length - 1);
      diversityScore = Math.max(0, 100 - (sameStyleRuns / maxRuns) * 60 - (sameArtistRuns / maxRuns) * 40);

      // Duration accuracy
      const targetDur = opts.setDuration || 45;
      const actualDur = set.totalTime || songs.reduce((s, song) => s + (song.duration || 0), 0);
      const durError = Math.abs(actualDur - targetDur);
      durationScore = Math.max(0, 100 - durError * 5);

      // Weighted composite
      const weights = { energy: 0.3, tonal: 0.25, diversity: 0.2, duration: 0.25 };
      const composite = weights.energy * energyScore
        + weights.tonal * tonalScore
        + weights.diversity * diversityScore
        + weights.duration * durationScore;

      return {
        overall: Math.round(composite),
        energy: Math.round(energyScore),
        tonal: Math.round(tonalScore),
        diversity: Math.round(diversityScore),
        duration: Math.round(durationScore)
      };
    }

    /******************* PHASE 4: SET STRUCTURE TEMPLATES *******************/
    const SET_STRUCTURE_TEMPLATES = {
      classic: {
        label: 'Classic Arc',
        description: 'Opener â†’ Build â†’ Peak â†’ Cool â†’ Closer',
        zones: [
          { start: 0, end: 0.1, preferStyles: ['uptempo', 'rock', 'funk'], label: 'Opener' },
          { start: 0.1, end: 0.35, preferStyles: ['midtempo', 'groove', 'shuffle'], label: 'Build' },
          { start: 0.35, end: 0.7, preferStyles: ['uptempo', 'funk', 'rock', 'groove'], label: 'Peak' },
          { start: 0.7, end: 0.9, preferStyles: ['midtempo', 'swing', 'soul'], label: 'Cool Down' },
          { start: 0.9, end: 1.0, preferStyles: ['ballad', 'midtempo', 'swing'], label: 'Closer' }
        ]
      },
      doublePeak: {
        label: 'Double Peak',
        description: 'Opener â†’ Peak1 â†’ Valley â†’ Peak2 â†’ Closer',
        zones: [
          { start: 0, end: 0.1, preferStyles: ['uptempo', 'groove', 'funk'], label: 'Opener' },
          { start: 0.1, end: 0.35, preferStyles: ['uptempo', 'funk', 'rock'], label: 'Peak 1' },
          { start: 0.35, end: 0.5, preferStyles: ['ballad', 'midtempo', 'swing'], label: 'Valley' },
          { start: 0.5, end: 0.8, preferStyles: ['uptempo', 'funk', 'groove', 'rock'], label: 'Peak 2' },
          { start: 0.8, end: 1.0, preferStyles: ['ballad', 'midtempo'], label: 'Closer' }
        ]
      },
      slowBurn: {
        label: 'Slow Burn',
        description: 'Mellow start â†’ Gradual build â†’ Big finish',
        zones: [
          { start: 0, end: 0.3, preferStyles: ['ballad', 'midtempo', 'swing', 'bossa'], label: 'Mellow' },
          { start: 0.3, end: 0.6, preferStyles: ['midtempo', 'groove', 'shuffle'], label: 'Warming Up' },
          { start: 0.6, end: 0.9, preferStyles: ['uptempo', 'funk', 'rock', 'groove'], label: 'Peak' },
          { start: 0.9, end: 1.0, preferStyles: ['uptempo', 'rock'], label: 'Big Finish' }
        ]
      },
      highEnergy: {
        label: 'High Energy',
        description: 'Constant high energy with one mid-set breather',
        zones: [
          { start: 0, end: 0.45, preferStyles: ['uptempo', 'funk', 'rock', 'groove', 'ska'], label: 'Full Throttle' },
          { start: 0.45, end: 0.55, preferStyles: ['midtempo', 'swing', 'shuffle'], label: 'Breather' },
          { start: 0.55, end: 1.0, preferStyles: ['uptempo', 'funk', 'rock', 'groove'], label: 'Full Throttle' }
        ]
      },
      freeform: {
        label: 'Freeform',
        description: 'No structural constraints â€” pure algorithm optimization',
        zones: []
      }
    };

    // Returns a style bonus/penalty for a candidate at a given position in a template
    function templateStylePenalty(style, position, templateName) {
      const template = SET_STRUCTURE_TEMPLATES[templateName];
      if (!template || !template.zones.length) return 0;
      const zone = template.zones.find(z => position >= z.start && position < z.end);
      if (!zone) return 0;
      return zone.preferStyles.includes(style) ? -0.8 : 0.4; // bonus for match, penalty for mismatch
    }

    /******************* CORE GENERATOR (PHASE 2 OPTIMIZED) *******************/
    function generateSetlistsCore(songs, opts) {
      const {
        numSets = 2,
        setDuration = 45,
        allowSongReuse = false,
        useEnergyCurve = true,
        forceOpener = false,
        forceCloser = true,
        lockedOpeners = [],
        lockedClosers = [],
        lockPlan = null
      } = opts || {};

      const pool = [...songs].map(s => ({ ...s, duration: parseDuration(s.duration) }));
      const used = new Map();
      const generationWarnings = new Set();
      let totalAttempts = 0;
      let generationAborted = false;

      // PERF: Pre-cache composite energy for all songs in the pool
      const energyCache = new Map();
      for (const s of pool) {
        if (!energyCache.has(s.id)) energyCache.set(s.id, getCompositeEnergy(s));
      }
      const cachedEnergy = (s) => energyCache.get(s.id) ?? getCompositeEnergy(s);

      const getSongDedupKeys = (s) => {
        const k = [];
        if (s.id) k.push(`id:${s.id}`);
        if (s.title && s.artist) k.push(`ta:${s.title.toLowerCase().trim()}|${s.artist.toLowerCase().trim()}`);
        return k;
      };

      const markUsed = (song) => {
        const keys = getSongDedupKeys(song);
        for (const k of keys) {
          used.set(k, (used.get(k) || 0) + 1);
        }
      };

      const unmarkUsed = (song) => {
        const keys = getSongDedupKeys(song);
        for (const k of keys) {
          const count = used.get(k) || 0;
          if (count <= 1) used.delete(k);
          else used.set(k, count - 1);
        }
      };

      const isAvailable = (song) => {
        if (allowSongReuse) return true;
        const keys = getSongDedupKeys(song);
        return !keys.some(k => used.has(k) && used.get(k) > 0);
      };

      const results = [];

      for (let setNum = 0; setNum < numSets; setNum++) {
        if (generationAborted) break;
        const lockedSlots = new Map(); // idx -> song
        const plan = Array.isArray(lockPlan) && Array.isArray(lockPlan[setNum]) ? lockPlan[setNum] : null;

        if (plan && plan.length) {
          for (const entry of plan) {
            if (!entry || !entry.song) continue;
            const idx = Math.max(0, Math.floor(entry.index));
            const song = entry.song;

            if (!allowSongReuse && !isAvailable(song)) continue;
            lockedSlots.set(idx, song);
            markUsed(song);
          }
        }

        let setArr = [];
        let current = 0;
        const setUsedIds = new Set(); // O(1) dedup within a single set

        if (lockedSlots.size > 0) {
          const maxIdx = Math.max(...lockedSlots.keys());
          setArr = new Array(maxIdx + 1).fill(null);
          for (const [idx, song] of lockedSlots.entries()) {
            setArr[idx] = song;
            setUsedIds.add(song.id);
            current += song.duration || 0;
          }
        } else {
          setArr = [];
        }

        if (lockedSlots.size === 0 && forceOpener) {
          let opener = null;

          // Prefer user-selected locked openers
          if (lockedOpeners.length > 0) {
            const availableLockedOpeners = lockedOpeners
              .map(id => pool.find(s => s.id === id))
              .filter(s => s && isAvailable(s));
            if (availableLockedOpeners.length > 0) {
              opener = availableLockedOpeners[Math.floor(Math.random() * availableLockedOpeners.length)];
            }
          }

          // Fallback to style-based opener if no locked opener available
          if (!opener) {
            const openerStyles = ['uptempo', 'swing', 'midtempo', 'groove'];
            const openers = pool.filter(s => isAvailable(s) && openerStyles.includes(s.style));
            if (openers.length > 0) {
              // When tonal gravity is active, prefer openers near the anchor key
              if (opts.useTonalGravity && opts._anchorKey) {
                const scoredOpeners = openers.map(s => {
                  const nk = s.normalizedKey || normalizeKey_TG(s.key, s.tags || []);
                  const dist = nk ? circleDistance_TG(nk.tonic, opts._anchorKey.tonic) : 6;
                  return { s, dist };
                }).sort((a, b) => a.dist - b.dist);
                const topOpeners = scoredOpeners.slice(0, Math.min(3, scoredOpeners.length));
                opener = topOpeners[Math.floor(Math.random() * topOpeners.length)].s;
              } else {
                opener = openers[Math.floor(Math.random() * openers.length)];
              }
            }
          }

          if (opener) {
            setArr[0] = opener;
            setUsedIds.add(opener.id);
            markUsed(opener);
            current += opener.duration || 0;
          }
        }

        let lastAddedSong = null;
        // Track last added song directly instead of scanning backwards each iteration
        if (lockedSlots.size > 0) {
          for (let i = setArr.length - 1; i >= 0; i--) {
            if (setArr[i]) { lastAddedSong = setArr[i]; break; }
          }
        }

        let guard = 0;
        const maxGuard = MAX_GUARD;

        // Pre-build available pool index for faster candidate lookup
        while (current < setDuration - 0.5 && guard < maxGuard) {
          guard++;
          const remaining = setDuration - current;

          let insertIndex = setArr.indexOf(null);
          if (insertIndex === -1) insertIndex = setArr.length;

          const durMin = Math.max(0.5, remaining - DURATION_TOLERANCE_NEGATIVE);
          const durMax = remaining + DURATION_TOLERANCE_POSITIVE;

          let candidates = pool.filter(song => {
            if (setUsedIds.has(song.id)) return false;
            if (!isAvailable(song)) return false;
            const dur = song.duration;
            return dur <= durMax && dur >= durMin;
          });

          if (candidates.length === 0) {
            candidates = pool.filter(s => !setUsedIds.has(s.id) && isAvailable(s));
            if (candidates.length === 0) {
              if (!allowSongReuse) {
                generationWarnings.add(`Set ${setNum + 1}: Ran out of unique songs at ${Math.round(current)}min.`);
                generationAborted = true;
              }
              break;
            }
          }

          const last = lastAddedSong;
          const curveType = opts.energyCurveType || 'standard';
          const energyWeight = opts.energyWeight ?? 0.35;
          const tonalWeight = opts.tonalWeight ?? 0.25;
          const diversityWeight = opts.diversityWeight ?? 1.0;
          const randomness = opts.randomness ?? 50;

          const scored = candidates.map(s => {
            const dur = s.duration || 0;
            const timePenalty = Math.abs(remaining - dur);

            let diversityPenalty = 0;
            if (last) {
              if (s.style === last.style) diversityPenalty += 1.25;
              if (s.artist === last.artist) diversityPenalty += 1.0;
            }
            diversityPenalty *= diversityWeight;

            // Continuous energy curve with composite (style + BPM) energy
            let energyPenalty = 0;
            if (useEnergyCurve) {
              const pos = (setDuration - remaining) / setDuration;
              const targetE = targetEnergyCurve(pos, curveType);
              const actualE = cachedEnergy(s);
              energyPenalty = Math.abs(actualE - targetE) * energyWeight;

              // Transition smoothness: penalize large energy jumps between consecutive songs
              if (last) {
                const jump = Math.abs(cachedEnergy(s) - cachedEnergy(last));
                if (jump > 2.5) energyPenalty += (jump - 2.5) * 0.3;
              }
            }

            // Integrated tonal scoring: consider key compatibility during initial selection
            let tonalPenalty = 0;
            if (opts.useTonalGravity && last?.normalizedKey && s.normalizedKey) {
              const songCount = setArr.filter(Boolean).length;
              const tonalScore = calculateTonalTransitionScore_TG(
                last, s, songCount, Math.ceil(setDuration / 4), opts.tonalSmoothness ?? 70,
                { anchorKey: opts._anchorKey || null }
              );
              tonalPenalty = -tonalScore * tonalWeight; // higher tonal score = lower penalty
            }

            // Set structure template preference
            let templatePenalty = 0;
            if (opts.setTemplate && opts.setTemplate !== 'freeform') {
              const pos = (setDuration - remaining) / setDuration;
              templatePenalty = templateStylePenalty(s.style, pos, opts.setTemplate);
            }

            // Song affinity: bonus for placing next to an affinity partner
            let affinityPenalty = 0;
            if (last && opts.songAffinities && opts.songAffinities.length > 0) {
              const isAffinity = opts.songAffinities.some(
                pair => (pair[0] === last.id && pair[1] === s.id) || (pair[1] === last.id && pair[0] === s.id)
              );
              if (isAffinity) affinityPenalty = -2.0; // bonus
            }
            if (last && opts.songAntiAffinities && opts.songAntiAffinities.length > 0) {
              const isAnti = opts.songAntiAffinities.some(
                pair => (pair[0] === last.id && pair[1] === s.id) || (pair[1] === last.id && pair[0] === s.id)
              );
              if (isAnti) affinityPenalty = 2.5; // penalty
            }

            const score = timePenalty + diversityPenalty + energyPenalty + tonalPenalty + templatePenalty + affinityPenalty;
            return { s, score };
          });

          scored.sort((a, b) => a.score - b.score);

          // Temperature-controlled selection: randomness 0=deterministic, 50=top-6, 100=softmax-all
          let pick;
          if (randomness <= 10) {
            pick = scored[0].s;
          } else if (randomness >= 80 && scored.length > 3) {
            // Softmax selection over all candidates
            const temp = (randomness / 100) * 2 + 0.1;
            const maxScore = scored[0].score;
            const weights = scored.map(c => Math.exp(-(c.score - maxScore) / temp));
            const totalW = weights.reduce((a, b) => a + b, 0);
            let r = Math.random() * totalW;
            let pickIdx = 0;
            for (let wi = 0; wi < weights.length; wi++) {
              r -= weights[wi];
              if (r <= 0) { pickIdx = wi; break; }
            }
            pick = scored[pickIdx].s;
          } else {
            const topK = scored.slice(0, Math.min(6, scored.length));
            pick = topK[Math.floor(Math.random() * topK.length)].s;
          }

          setArr[insertIndex] = pick;
          setUsedIds.add(pick.id);
          markUsed(pick);
          current += pick.duration;
          lastAddedSong = pick;
          totalAttempts++;

          if (current > setDuration + 8) break;
        }

        const setSongs = setArr.filter(Boolean);

        if (forceCloser && setSongs.length > 0) {
          const lastIdx = setSongs.length - 1;
          const lastSong = setSongs[lastIdx];
          const closerStyles = ['ballad', 'midtempo', 'swing'];

          // Check if a locked closer should be used
          let useLockedCloser = false;
          let lockedCloserSong = null;

          if (lockedClosers.length > 0) {
            const availableLockedClosers = lockedClosers
              .map(id => pool.find(s => s.id === id))
              .filter(s => s && (s.id === lastSong.id || (allowSongReuse || !setSongs.some((x, xi) => xi !== lastIdx && x.id === s.id))));

            // Find one that's available globally
            if (!allowSongReuse) unmarkUsed(lastSong);
            const reallyAvailable = availableLockedClosers.filter(s => s.id === lastSong.id || isAvailable(s));
            if (reallyAvailable.length > 0) {
              lockedCloserSong = reallyAvailable[Math.floor(Math.random() * reallyAvailable.length)];
              useLockedCloser = true;
            }
            if (!useLockedCloser && !allowSongReuse) markUsed(lastSong);
          }

          if (useLockedCloser && lockedCloserSong) {
            if (lockedCloserSong.id !== lastSong.id) {
              setSongs[lastIdx] = lockedCloserSong;
              markUsed(lockedCloserSong);
            } else {
              // Locked closer is already the last song, re-mark it
              if (!allowSongReuse) markUsed(lastSong);
            }
          } else if (!closerStyles.includes(lastSong.style)) {
            // Fallback to style-based closer selection
            if (!allowSongReuse) unmarkUsed(lastSong);

            const closerCandidates = pool.filter(s =>
              isAvailable(s) && closerStyles.includes(s.style) && s.id !== lastSong.id
              && !setSongs.some((x, xi) => xi !== lastIdx && x.id === s.id)
            );
            if (closerCandidates.length > 0) {
              let closer;
              // Tonal-aware closer: prefer closers harmonically close to the penultimate song
              const penultimate = setSongs.length > 1 ? setSongs[lastIdx - 1] : null;
              if (opts.useTonalGravity && penultimate?.normalizedKey && closerCandidates.length > 1) {
                const scoredClosers = closerCandidates.map(s => {
                  const nk = s.normalizedKey || normalizeKey_TG(s.key, s.tags || []);
                  const dist = nk && penultimate.normalizedKey
                    ? circleDistance_TG(nk.tonic, penultimate.normalizedKey.tonic)
                    : 6;
                  return { s, dist };
                }).sort((a, b) => a.dist - b.dist);
                const topClosers = scoredClosers.slice(0, Math.min(3, scoredClosers.length));
                closer = topClosers[Math.floor(Math.random() * topClosers.length)].s;
              } else {
                closer = closerCandidates[Math.floor(Math.random() * closerCandidates.length)];
              }
              setSongs[lastIdx] = closer;
              markUsed(closer);
            } else {
              if (!allowSongReuse) markUsed(lastSong);
            }
          }
        }

        const totalTime = setSongs.reduce((sum, s) => sum + (s.duration || 0), 0);
        results.push({
          id: genId(),
          name: `Set ${setNum + 1}`,
          songs: setSongs,
          totalTime
        });
      }

      const songsUsed = new Set(results.flatMap(r => r.songs.map(s => s.id))).size;
      results.stats = { songsUsed, attempts: totalAttempts };
      results.generationWarnings = Array.from(generationWarnings);

      return results;
    }

    /******************* REACT COMPONENTS *******************/
    function ErrorBoundary({ children }) {
      const [hasError, setHasError] = useState(false);
      const [error, setError] = useState(null);

      useEffect(() => {
        const handler = (event) => {
          setHasError(true);
          setError(event.error);
        };
        window.addEventListener('error', handler);
        return () => window.removeEventListener('error', handler);
      }, []);

      if (hasError) {
        return (
          <div style={{ padding: '2rem', textAlign: 'center' }}>
            <h2 style={{ color: 'var(--error)' }}>Something went wrong</h2>
            <pre style={{ color: 'var(--text-muted)', marginTop: '1rem', whiteSpace: 'pre-wrap', textAlign: 'left' }}>
              {error?.toString() || 'Unknown error'}
            </pre>
          </div>
        );
      }
      return children;
    }

    function Toast({ message, type, onClose }) {
      useEffect(() => {
        const t = setTimeout(onClose, 3500);
        return () => clearTimeout(t);
      }, [onClose]);

      return (
        <div className="toast">
          <span>{type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : 'âš ï¸'}</span>
          <span>{message}</span>
        </div>
      );
    }

    // PHASE 3A: Active / Cold tabs + Shelf / Restore
    function SongLibrary({
      songs,
      activeCount,
      coldCount,
      libraryTab,
      onSetLibraryTab,
      onAddSong,
      onDeleteSong,
      onShelfSong,
      onRestoreSong,
      onExportCSV,
      onImportCSVRobust,
      onOpenImportModal,
      onDownloadSampleCSV,
      onClearAll,
      latestImport
    }) {
      const [form, setForm] = useState({ title: '', artist: '', duration: '', style: 'midtempo', key: '', bpm: '' });

      const handleAdd = () => {
        if (!form.title || !form.artist || !form.duration) return;
        onAddSong(form);
        setForm({ title: '', artist: '', duration: '', style: 'midtempo', key: '', bpm: '' });
      };

      const visibleSongs = useMemo(() => {
        const tab = libraryTab || 'active';
        return songs.filter(s => ((s.status || 'active') === tab));
      }, [songs, libraryTab]);

      return (
        <div className="panel">
          <div className="panel-header">
            <h3 className="panel-title">
              Song Library (Active {activeCount} â€¢ Cold {coldCount})
            </h3>
            <div className="toolbar">
              <button
                className={`btn btn-small ${libraryTab === 'active' ? 'btn-toggle-active' : ''}`}
                onClick={() => onSetLibraryTab('active')}
              >
                Active
              </button>
              <button
                className={`btn btn-small ${libraryTab === 'cold' ? 'btn-toggle-active' : ''}`}
                onClick={() => onSetLibraryTab('cold')}
              >
                Cold
              </button>
            </div>
          </div>

          <div className="input-group">
            <label>Title*</label>
            <input value={form.title} onChange={e => setForm({ ...form, title: e.target.value })} placeholder="Enter song title" />
          </div>

          <div className="input-group">
            <label>Artist*</label>
            <input value={form.artist} onChange={e => setForm({ ...form, artist: e.target.value })} placeholder="Enter artist name" />
          </div>

          <div className="set-config">
            <div className="input-group">
              <label>Duration*</label>
              <input value={form.duration} onChange={e => setForm({ ...form, duration: e.target.value })} placeholder="4.5" />
            </div>
            <div className="input-group">
              <label>Style</label>
              <select value={form.style} onChange={e => setForm({ ...form, style: e.target.value })}>
                <option value="ballad">Ballad</option>
                <option value="uptempo">Uptempo</option>
                <option value="midtempo">Midtempo</option>
                <option value="funk">Funk</option>
                <option value="shuffle">Shuffle</option>
                <option value="swing">Swing</option>
                <option value="groove">Groove</option>
              </select>
            </div>
          </div>

          <div className="set-config">
            <div className="input-group">
              <label>Key</label>
              <input value={form.key} onChange={e => setForm({ ...form, key: e.target.value })} placeholder="C" />
            </div>
            <div className="input-group">
              <label>BPM</label>
              <input value={form.bpm} onChange={e => setForm({ ...form, bpm: e.target.value })} placeholder="120" />
            </div>
          </div>

          <button className="btn btn-primary" onClick={handleAdd} style={{ width: '100%', marginBottom: '1rem' }}>
            Add Song (to Active)
          </button>

          <div className="toolbar" style={{ marginBottom: '1rem' }}>
            <label className="btn btn-small" style={{ margin: 0, cursor: 'pointer' }}>
              Quick Import
              <input type="file" accept=".csv,.pdf,.txt" onChange={onImportCSVRobust} style={{ display: 'none' }} />
            </label>
            <button className="btn btn-small" onClick={onOpenImportModal} style={{ borderColor: 'var(--accent)', color: 'var(--accent)' }}>Import + Normalize</button>
            <button className="btn btn-small" onClick={onExportCSV} disabled={songs.length === 0}>Export CSV</button>
            <button className="btn btn-small" onClick={onDownloadSampleCSV}>Sample CSV</button>
            <button className="btn btn-small" onClick={onClearAll} disabled={songs.length === 0}>Clear All</button>
          </div>

          {latestImport && (
            <div className="alert alert-success">
              âœ… Imported {latestImport.count} songs on {new Date(latestImport.ts).toLocaleString()}
            </div>
          )}

          <div className="song-list">
            {visibleSongs.length === 0 ? (
              <div style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '2rem 1rem' }}>
                {libraryTab === 'active'
                  ? 'No Active songs yet. Add manually or import CSV.'
                  : 'Cold List is empty.'}
              </div>
            ) : (
              visibleSongs.map(song => (
                <div key={song.id} className="song-item">
                  <div>
                    <div className="song-title">{song.title}</div>
                    <div className="song-meta">
                      <span>{song.artist}</span>
                      <span className={`song-badge style-${song.style}`}>{song.style}</span>
                      <span>{parseDuration(song.duration)}min</span>
                      {song.key && <span>{song.key}</span>}
                      {song.bpm && <span>{song.bpm}bpm</span>}
                    </div>
                  </div>
                  <div className="toolbar" style={{ justifyContent: 'flex-end' }}>
                    {(song.status || 'active') === 'active' ? (
                      <button className="btn btn-small" onClick={() => onShelfSong(song.id)} title="Move to Cold List">ðŸ§Š Shelf</button>
                    ) : (
                      <button className="btn btn-small" onClick={() => onRestoreSong(song.id)} title="Restore to Active">ðŸ”¥ Restore</button>
                    )}
                    <button className="btn btn-small" onClick={() => onDeleteSong(song.id)}>Delete</button>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      );
    }

    function SetConfiguration({ settings, onChange, onGenerate, onCopy, onExportPDF, songCount, libraryTime, watermarkImg, onWatermarkUpload, onClearWatermark, activeSongs }) {
      const [activeHelpKey, setActiveHelpKey] = useState(null);
      const activeHelp = activeHelpKey ? window.featureDefinitions?.[activeHelpKey] : null;
      const openHelp = (featureKey) => setActiveHelpKey(featureKey);
      const closeHelp = () => setActiveHelpKey(null);

      return (
        <div className="panel">
          <div className="panel-header">
            <h3 className="panel-title">Setlist Configuration</h3>
          </div>

          <div className="set-config">
            <div className="input-group">
              <label>Number of Sets</label>
              <input type="number" min="1" max="10" value={settings.numSets}
                onChange={e => onChange({ ...settings, numSets: parseInt(e.target.value) || 1 })} />
            </div>
            <div className="input-group">
              <label>Set Duration (min)</label>
              <input type="number" min="15" max="180" value={settings.setDuration}
                onChange={e => onChange({ ...settings, setDuration: parseInt(e.target.value) || 45 })} />
            </div>
          </div>

          <div className="input-group">
            <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
              <input type="checkbox" checked={settings.allowSongReuse}
                onChange={e => onChange({ ...settings, allowSongReuse: e.target.checked })}
                style={{ width: 'auto' }} />
              Allow Song Reuse Across Sets
            </label>
          </div>

          <div className="input-group">
            <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
              <input type="checkbox" checked={settings.useEnergyCurve}
                onChange={e => onChange({ ...settings, useEnergyCurve: e.target.checked })}
                style={{ width: 'auto' }} />
              Energy Curve Optimization
              <InfoTrigger featureKey="energyCurve" onClick={openHelp} label="Learn about Energy Curve Optimization" />
            </label>
          </div>

          {settings.useEnergyCurve && (
            <div style={{ marginBottom: '.8rem', paddingLeft: '.5rem', borderLeft: '2px solid var(--accent)', marginLeft: '.25rem' }}>
              <div className="input-group">
                <label style={{ textTransform: 'none', fontSize: '.75rem', display: 'flex', alignItems: 'center' }}>
                  Curve Preset
                  <InfoTrigger featureKey="presets" onClick={openHelp} label="Learn about curve presets" />
                </label>
                <select value={settings.energyCurveType || 'standard'}
                  onChange={e => onChange({ ...settings, energyCurveType: e.target.value })}
                  style={{ fontSize: '.8rem' }}>
                  {Object.entries(ENERGY_CURVE_PRESETS).map(([key, preset]) => (
                    <option key={key} value={key}>{preset.label}</option>
                  ))}
                </select>
              </div>
              <div className="input-group">
                <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
                  Energy Weight: {(settings.energyWeight ?? 0.35).toFixed(2)}
                </label>
                <input type="range" min="0" max="100" value={Math.round((settings.energyWeight ?? 0.35) * 100)}
                  onChange={e => onChange({ ...settings, energyWeight: parseInt(e.target.value, 10) / 100 })} />
              </div>
            </div>
          )}

          <div className="set-config">
            <div className="input-group">
              <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
                <input type="checkbox" checked={settings.forceOpener}
                  onChange={e => onChange({ ...settings, forceOpener: e.target.checked })}
                  style={{ width: 'auto' }} />
                Force Opener
              </label>
            </div>
            <div className="input-group">
              <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
                <input type="checkbox" checked={settings.forceCloser}
                  onChange={e => onChange({ ...settings, forceCloser: e.target.checked })}
                  style={{ width: 'auto' }} />
                Force Closer
              </label>
            </div>
          </div>

          {/* Locked Openers Selection */}
          {settings.forceOpener && (
            <div className="input-group" style={{ marginTop: '.5rem' }}>
              <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
                Locked Set Openers ({(settings.lockedOpeners || []).length} selected)
              </label>
              <select
                value=""
                onChange={e => {
                  if (!e.target.value) return;
                  const id = e.target.value;
                  const current = settings.lockedOpeners || [];
                  if (!current.includes(id)) {
                    onChange({ ...settings, lockedOpeners: [...current, id] });
                  }
                }}
                style={{ fontSize: '.8rem' }}
              >
                <option value="">+ Add a locked opener...</option>
                {(activeSongs || []).filter(s => !(settings.lockedOpeners || []).includes(s.id)).map(s => (
                  <option key={s.id} value={s.id}>{s.title} - {s.artist}</option>
                ))}
              </select>
              {(settings.lockedOpeners || []).length > 0 && (
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '.3rem', marginTop: '.3rem' }}>
                  {(settings.lockedOpeners || []).map(id => {
                    const song = (activeSongs || []).find(s => s.id === id);
                    return song ? (
                      <span key={id} style={{ display: 'inline-flex', alignItems: 'center', gap: '.25rem', background: 'var(--primary)', border: '1px solid var(--success)', borderRadius: '6px', padding: '.2rem .5rem', fontSize: '.75rem', color: 'var(--success)' }}>
                        {song.title}
                        <span style={{ cursor: 'pointer', opacity: 0.7 }} onClick={() => onChange({ ...settings, lockedOpeners: (settings.lockedOpeners || []).filter(x => x !== id) })}>x</span>
                      </span>
                    ) : null;
                  })}
                </div>
              )}
            </div>
          )}

          {/* Locked Closers Selection */}
          {settings.forceCloser && (
            <div className="input-group" style={{ marginTop: '.5rem' }}>
              <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
                Locked Set Closers ({(settings.lockedClosers || []).length} selected)
              </label>
              <select
                value=""
                onChange={e => {
                  if (!e.target.value) return;
                  const id = e.target.value;
                  const current = settings.lockedClosers || [];
                  if (!current.includes(id)) {
                    onChange({ ...settings, lockedClosers: [...current, id] });
                  }
                }}
                style={{ fontSize: '.8rem' }}
              >
                <option value="">+ Add a locked closer...</option>
                {(activeSongs || []).filter(s => !(settings.lockedClosers || []).includes(s.id)).map(s => (
                  <option key={s.id} value={s.id}>{s.title} - {s.artist}</option>
                ))}
              </select>
              {(settings.lockedClosers || []).length > 0 && (
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '.3rem', marginTop: '.3rem' }}>
                  {(settings.lockedClosers || []).map(id => {
                    const song = (activeSongs || []).find(s => s.id === id);
                    return song ? (
                      <span key={id} style={{ display: 'inline-flex', alignItems: 'center', gap: '.25rem', background: 'var(--primary)', border: '1px solid var(--ballad)', borderRadius: '6px', padding: '.2rem .5rem', fontSize: '.75rem', color: 'var(--ballad)' }}>
                        {song.title}
                        <span style={{ cursor: 'pointer', opacity: 0.7 }} onClick={() => onChange({ ...settings, lockedClosers: (settings.lockedClosers || []).filter(x => x !== id) })}>x</span>
                      </span>
                    ) : null;
                  })}
                </div>
              )}
            </div>
          )}


{/* PHASE 3B: Tonal Gravity */}
<div style={{ 
  marginTop: '1rem', 
  paddingTop: '1rem', 
  borderTop: '1px solid var(--border)' 
}}>
  <div className="input-group">
    <label style={{ 
      display: 'flex', 
      alignItems: 'center', 
      gap: '.5rem', 
      cursor: 'pointer', 
      textTransform: 'none' 
    }}>
      <input
        type="checkbox"
        checked={!!settings.useTonalGravity}
        onChange={e => onChange({ ...settings, useTonalGravity: e.target.checked })}
        style={{ width: 'auto' }}
      />
      ðŸŽµ Tonal Gravity (Circle of Fifths)
      <InfoTrigger featureKey="tonalGravity" onClick={openHelp} label="Learn about Tonal Gravity" />
    </label>
  </div>

  {settings.useTonalGravity && (
    <div style={{ marginTop: '.5rem' }}>
      <div className="input-group">
        <label style={{ textTransform: 'none' }}>
          Tonal Smoothness: {settings.tonalSmoothness ?? 70}
        </label>
        <input
          type="range"
          min="0"
          max="100"
          value={settings.tonalSmoothness ?? 70}
          onChange={e => onChange({ ...settings, tonalSmoothness: parseInt(e.target.value, 10) || 0 })}
        />
        <div style={{ fontSize: '.8rem', color: 'var(--text-muted)', marginTop: '.25rem' }}>
          {(settings.tonalSmoothness ?? 70) > 70 ? 'Smooth' :
           (settings.tonalSmoothness ?? 70) > 50 ? 'Balanced' : 'Contrast'}
        </div>
      </div>

      <div className="set-config">
        <div className="input-group">
          <label style={{ textTransform: 'none' }}>Anchor Key</label>
          <select
            value={settings.anchorKey || ''}
            onChange={e => onChange({ ...settings, anchorKey: e.target.value })}
          >
            <option value="">Auto-detect</option>
            <option value="C">C</option><option value="G">G</option><option value="D">D</option><option value="A">A</option>
            <option value="E">E</option><option value="B">B</option><option value="F#">F#</option>
            <option value="F">F</option><option value="Bb">Bb</option><option value="Eb">Eb</option>
            <option value="Ab">Ab</option><option value="Db">Db</option>
          </select>
        </div>

        <div className="input-group">
          <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
            <input
              type="checkbox"
              checked={!!settings.showDetailedDiagnostics}
              onChange={e => onChange({ ...settings, showDetailedDiagnostics: e.target.checked })}
              style={{ width: 'auto' }}
            />
            Detailed diagnostics
          </label>
        </div>
      </div>
    </div>
  )}
</div>

{/* Advanced Algorithm Settings */}
<div style={{ marginTop: '1rem', paddingTop: '1rem', borderTop: '1px solid var(--border)' }}>
  <div style={{ fontSize: '.75rem', fontWeight: 600, textTransform: 'uppercase', letterSpacing: '.05em', color: 'var(--text-muted)', marginBottom: '.6rem' }}>
    Advanced Settings
  </div>

  <div className="set-config">
    <div className="input-group">
      <label style={{ textTransform: 'none', fontSize: '.75rem' }}>Set Template</label>
      <select value={settings.setTemplate || 'freeform'}
        onChange={e => onChange({ ...settings, setTemplate: e.target.value })}
        style={{ fontSize: '.8rem' }}>
        {Object.entries(SET_STRUCTURE_TEMPLATES).map(([key, t]) => (
          <option key={key} value={key}>{t.label}</option>
        ))}
      </select>
      {settings.setTemplate && settings.setTemplate !== 'freeform' && (
        <div style={{ fontSize: '.7rem', color: 'var(--text-muted)', marginTop: '.2rem' }}>
          {SET_STRUCTURE_TEMPLATES[settings.setTemplate]?.description}
        </div>
      )}
    </div>
    <div className="input-group">
      <label style={{ textTransform: 'none', fontSize: '.75rem', display: 'flex', alignItems: 'center' }}>
        Optimization
        <InfoTrigger featureKey="optimizationMode" onClick={openHelp} label="Learn about optimization modes" />
      </label>
      <select value={settings.optimizationLevel || 'standard'}
        onChange={e => onChange({ ...settings, optimizationLevel: e.target.value })}
        style={{ fontSize: '.8rem' }}>
        <option value="standard">Standard</option>
        <option value="deep">Deep (SA)</option>
      </select>
    </div>
  </div>

  <div className="input-group">
    <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
      Randomness: {settings.randomness ?? 50}
      <span style={{ fontSize: '.65rem', color: 'var(--text-muted)', marginLeft: '.4rem' }}>
        {(settings.randomness ?? 50) <= 10 ? 'Predictable' : (settings.randomness ?? 50) >= 80 ? 'Adventurous' : 'Balanced'}
      </span>
    </label>
    <input type="range" min="0" max="100" value={settings.randomness ?? 50}
      onChange={e => onChange({ ...settings, randomness: parseInt(e.target.value, 10) })} />
  </div>

  <div className="input-group">
    <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
      Diversity Weight: {(settings.diversityWeight ?? 1.0).toFixed(1)}
    </label>
    <input type="range" min="0" max="200" value={Math.round((settings.diversityWeight ?? 1.0) * 100)}
      onChange={e => onChange({ ...settings, diversityWeight: parseInt(e.target.value, 10) / 100 })} />
  </div>

  {settings.useTonalGravity && (
    <div className="input-group">
      <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
        Tonal Weight: {(settings.tonalWeight ?? 0.25).toFixed(2)}
      </label>
      <input type="range" min="0" max="100" value={Math.round((settings.tonalWeight ?? 0.25) * 100)}
        onChange={e => onChange({ ...settings, tonalWeight: parseInt(e.target.value, 10) / 100 })} />
    </div>
  )}

  {/* Song Affinity Manager */}
  <div className="input-group" style={{ marginTop: '.5rem' }}>
    <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
      Song Pairings ({(settings.songAffinities || []).length} affinity, {(settings.songAntiAffinities || []).length} anti)
    </label>
    <div style={{ display: 'flex', gap: '.3rem' }}>
      <select id="affinityA" style={{ fontSize: '.75rem', flex: 1 }}>
        <option value="">Song A...</option>
        {(activeSongs || []).map(s => (
          <option key={s.id} value={s.id}>{s.title}</option>
        ))}
      </select>
      <select id="affinityB" style={{ fontSize: '.75rem', flex: 1 }}>
        <option value="">Song B...</option>
        {(activeSongs || []).map(s => (
          <option key={s.id} value={s.id}>{s.title}</option>
        ))}
      </select>
    </div>
    <div style={{ display: 'flex', gap: '.3rem', marginTop: '.3rem' }}>
      <button className="btn btn-small" style={{ fontSize: '.65rem', flex: 1 }} onClick={() => {
        const a = document.getElementById('affinityA')?.value;
        const b = document.getElementById('affinityB')?.value;
        if (!a || !b || a === b) return;
        const existing = settings.songAffinities || [];
        if (existing.some(p => (p[0] === a && p[1] === b) || (p[0] === b && p[1] === a))) return;
        onChange({ ...settings, songAffinities: [...existing, [a, b]] });
      }}>+ Pair Together</button>
      <button className="btn btn-small" style={{ fontSize: '.65rem', flex: 1 }} onClick={() => {
        const a = document.getElementById('affinityA')?.value;
        const b = document.getElementById('affinityB')?.value;
        if (!a || !b || a === b) return;
        const existing = settings.songAntiAffinities || [];
        if (existing.some(p => (p[0] === a && p[1] === b) || (p[0] === b && p[1] === a))) return;
        onChange({ ...settings, songAntiAffinities: [...existing, [a, b]] });
      }}>+ Keep Apart</button>
    </div>
    {(settings.songAffinities || []).length > 0 && (
      <div style={{ marginTop: '.3rem' }}>
        {(settings.songAffinities || []).map((pair, idx) => {
          const sA = (activeSongs || []).find(s => s.id === pair[0]);
          const sB = (activeSongs || []).find(s => s.id === pair[1]);
          return (
            <div key={idx} style={{ display: 'flex', alignItems: 'center', gap: '.3rem', fontSize: '.7rem', color: 'var(--success)', marginBottom: '.15rem' }}>
              <span>{sA?.title || '?'} + {sB?.title || '?'}</span>
              <span style={{ cursor: 'pointer', opacity: 0.7 }} onClick={() => {
                onChange({ ...settings, songAffinities: (settings.songAffinities || []).filter((_, i) => i !== idx) });
              }}>x</span>
            </div>
          );
        })}
      </div>
    )}
    {(settings.songAntiAffinities || []).length > 0 && (
      <div style={{ marginTop: '.2rem' }}>
        {(settings.songAntiAffinities || []).map((pair, idx) => {
          const sA = (activeSongs || []).find(s => s.id === pair[0]);
          const sB = (activeSongs || []).find(s => s.id === pair[1]);
          return (
            <div key={idx} style={{ display: 'flex', alignItems: 'center', gap: '.3rem', fontSize: '.7rem', color: 'var(--error)', marginBottom: '.15rem' }}>
              <span>{sA?.title || '?'} / {sB?.title || '?'}</span>
              <span style={{ cursor: 'pointer', opacity: 0.7 }} onClick={() => {
                onChange({ ...settings, songAntiAffinities: (settings.songAntiAffinities || []).filter((_, i) => i !== idx) });
              }}>x</span>
            </div>
          );
        })}
      </div>
    )}
  </div>
</div>

          <button className="btn btn-primary" onClick={onGenerate} disabled={songCount === 0} style={{ width: '100%', marginTop: '.5rem' }}>
            Generate Setlists
          </button>

          <div className="toolbar" style={{ marginTop: '1rem' }}>
            <button className="btn btn-small" onClick={onCopy}>Copy Text</button>
            <button className="btn btn-small" onClick={onExportPDF}>Export PDF</button>
          </div>

          <div style={{ marginTop: '.75rem', padding: '.5rem', background: 'var(--primary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
            <div style={{ fontSize: '.75rem', fontWeight: 600, textTransform: 'uppercase', letterSpacing: '.05em', color: 'var(--text-muted)', marginBottom: '.4rem' }}>
              PDF Watermark
            </div>
            {watermarkImg ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>
                <img src={watermarkImg} alt="Watermark" style={{ width: 40, height: 40, objectFit: 'contain', borderRadius: 4, opacity: 0.7 }} />
                <span style={{ fontSize: '.8rem', color: 'var(--text-muted)', flex: 1 }}>Watermark set</span>
                <button className="btn btn-small" onClick={onClearWatermark} style={{ fontSize: '.7rem' }}>Remove</button>
              </div>
            ) : (
              <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', fontSize: '.8rem', color: 'var(--text-muted)' }}>
                <input type="file" accept="image/*" onChange={onWatermarkUpload} style={{ display: 'none' }} />
                <span className="btn btn-small" style={{ fontSize: '.7rem' }}>Upload Image</span>
                <span>No watermark</span>
              </label>
            )}
          </div>

          <div style={{ marginTop: '1rem', fontSize: '.85rem', color: 'var(--text-muted)' }}>
            Active Library: {songCount} songs â€¢ {Math.round(libraryTime)} min total
          </div>

          <InfoModal isOpen={!!activeHelp} onClose={closeHelp} data={activeHelp} />
        </div>
      );
    }

    function SetlistView({ setIdx, setlist, locked, setLocked: setLockedSet, onToggleLock, onSwap, onMoveSong, onRemoveSong, onLockEntireSet, onDragStart, onDragEnd, onDragOverSong, onDragOverSet, onDropOnSong, onDropOnSet, onMoveToSet, dragState, totalSets, isReorderMode }) {
      let runningTime = 0;
      const allLocked = setlist.songs.length > 0 && setlist.songs.every(s => locked.has(`${setIdx}:${s.id}`));
      const isSetDragTarget = dragState && dragState.active && dragState.overSetIdx === setIdx && dragState.fromSetIdx !== setIdx;

      return (
        <div
          className={`setlist${isSetDragTarget ? ' drag-target' : ''}`}
          onDragOver={(e) => onDragOverSet(e, setIdx)}
          onDragEnter={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }}
          onDrop={(e) => onDropOnSet(e, setIdx)}
        >
          <div className="setlist-header">
            <div>
              <h4>{setlist.name}</h4>
              <div style={{ fontSize: '.85rem', color: 'var(--text-muted)' }}>
                {setlist.songs.length} songs â€¢ {Math.round(setlist.totalTime)} min
              </div>
            </div>
            <div style={{ display: 'flex', gap: '.4rem', alignItems: 'center' }}>
              <button
                className={`btn btn-small ${allLocked ? 'btn-toggle-active' : ''}`}
                onClick={() => onLockEntireSet(setIdx, !allLocked)}
                title={allLocked ? 'Unlock entire set' : 'Lock entire set'}
                style={allLocked ? { borderColor: 'var(--locked)', color: 'var(--locked)' } : {}}
              >
                {allLocked ? 'Unlock Set' : 'Lock Set'}
              </button>
            </div>
          </div>

          {setlist.songs.map((song, songIdx) => {
            const startTime = runningTime;
            runningTime += Number(song.duration) || 0;
            const isLocked = locked.has(`${setIdx}:${song.id}`);
            const isDragging = dragState && dragState.active && dragState.fromSetIdx === setIdx && dragState.fromSongIdx === songIdx;
            const isOver = dragState && dragState.active && dragState.overSetIdx === setIdx && dragState.overSongIdx === songIdx;

            let dragClass = '';
            if (isDragging) dragClass = 'dragging';
            if (isOver) dragClass += ' drag-over-bottom';

            return (
              <div
                key={`${song.id}-${songIdx}`}
                className={`setlist-song ${isLocked ? 'locked' : ''} ${dragClass}`}
                draggable={!isLocked && isReorderMode}
                onDragStart={(e) => onDragStart(e, song, setIdx, songIdx)}
                onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); }}
                onDragOver={(e) => onDragOverSong(e, setIdx, songIdx)}
                onDrop={(e) => onDropOnSong(e, setIdx, songIdx)}
                onDragEnd={onDragEnd}
              >
                <div className="drag-handle" title={!isReorderMode ? 'Enable Reorder Mode to drag' : isLocked ? 'Locked - cannot drag' : 'Drag to reorder or move to another set'}>
                  {isReorderMode && !isLocked ? 'â ¿' : ''}
                </div>
                <div className="song-number">{songIdx + 1}</div>
                <div>
                  <div className="song-title">{song.title}</div>
                  <div className="song-meta">
                    <span>{song.artist}</span>
                    <span className={`song-badge style-${song.style}`}>{song.style}</span>
                    <span>{parseDuration(song.duration)}min</span>
                    {song.key && <span style={{ fontSize: '.7rem', color: 'var(--text-muted)' }}>{song.key}</span>}
                  </div>
                </div>
                <div className="song-time">+{Math.round(startTime)}m</div>
                <div className="song-actions">
                  {totalSets > 1 && !isLocked && (
                    <select
                      className="move-to-set-select"
                      value=""
                      onChange={(e) => { if (e.target.value !== '') onMoveToSet(setIdx, songIdx, Number(e.target.value)); }}
                      title="Move to another set"
                    >
                      <option value="" disabled>Set</option>
                      {Array.from({ length: totalSets }, (_, i) => i).filter(i => i !== setIdx).map(i => (
                        <option key={i} value={i}>Set {i + 1}</option>
                      ))}
                    </select>
                  )}
                  <button className={`action-btn ${isLocked ? 'locked' : ''}`} onClick={() => onToggleLock(setIdx, song.id)} title={isLocked ? 'Unlock' : 'Lock'}>
                    {isLocked ? 'ðŸ”’' : 'ðŸ”“'}
                  </button>
                  <button className="action-btn" onClick={() => onRemoveSong(setIdx, songIdx)} title="Remove (send to Cold List)" style={{ color: 'var(--error)' }}>
                    âœ•
                  </button>
                </div>
              </div>
            );
          })}

          {dragState && dragState.active && dragState.fromSetIdx !== setIdx && (
            <div
              className={`drop-zone-between${dragState.overSetIdx === setIdx && dragState.overSongIdx === null ? ' drag-over' : ''}`}
              onDragOver={(e) => { e.preventDefault(); onDragOverSet(e, setIdx); }}
              onDragLeave={() => {}}
              onDrop={(e) => onDropOnSet(e, setIdx)}
            >
              Drop here to add to {setlist.name}
            </div>
          )}
        </div>
      );
    }

    /******************* IMPORT SONGS MODAL *******************/
    function ImportSongsModal({ open, onClose, onImport, existingSongs }) {
      const STEPS = ["input", "map", "normalize", "import"];
      const STEP_LABELS = { input: "1. Input", map: "2. Map Columns", normalize: "3. Review", import: "4. Import" };

      const [step, setStep] = useState("input");
      const [inputTab, setInputTab] = useState("upload");
      const [rawText, setRawText] = useState("");
      const [fileName, setFileName] = useState("");
      const [hasHeaders, setHasHeaders] = useState(true);
      const [delimiter, setDelimiter] = useState("auto");

      // Parsed data
      const [parsedColumns, setParsedColumns] = useState([]);
      const [parsedRows, setParsedRows] = useState([]);

      // Mapping
      const [mapping, setMapping] = useState({ titleCol: null, artistCol: null, durationCol: null, styleCol: null, keyCol: null, tempoCol: null, vocalistCol: null });
      const [confidences, setConfidences] = useState({});

      // Options
      const [opts, setOpts] = useState({
        trimWhitespace: true, normalizeKeys: true, normalizeTempo: true, normalizeVocalist: true,
        stripMetaParen: false, defaultTempo: null, defaultVocalist: "ALL"
      });

      // Results
      const [normalizedResult, setNormalizedResult] = useState(null);
      const [dragover, setDragover] = useState(false);

      if (!open) return null;

      const reset = () => {
        setStep("input"); setInputTab("upload"); setRawText(""); setFileName("");
        setHasHeaders(true); setDelimiter("auto");
        setParsedColumns([]); setParsedRows([]);
        setMapping({ titleCol: null, artistCol: null, durationCol: null, styleCol: null, keyCol: null, tempoCol: null, vocalistCol: null });
        setConfidences({});
        setNormalizedResult(null);
      };

      const handleClose = () => { reset(); onClose(); };

      const parseText = (text, fname) => {
        if (!text || !text.trim()) return;
        const effectiveDelimiter = delimiter === "auto" ? importDetectDelimiter(text) : delimiter;
        const result = Papa.parse(text, {
          delimiter: effectiveDelimiter, header: hasHeaders, skipEmptyLines: "greedy", dynamicTyping: false
        });
        if (!result.data || result.data.length === 0) return;

        let columns, rows;
        if (hasHeaders && result.meta && result.meta.fields) {
          columns = result.meta.fields;
          rows = result.data;
        } else {
          const maxCols = result.data.reduce((max, row) => Math.max(max, Array.isArray(row) ? row.length : 0), 0);
          columns = Array.from({ length: maxCols }, (_, i) => `Column ${i + 1}`);
          rows = result.data.map(row => {
            if (Array.isArray(row)) {
              const obj = {};
              columns.forEach((c, i) => obj[c] = row[i] ?? "");
              return obj;
            }
            return row;
          });
        }

        setParsedColumns(columns);
        setParsedRows(rows);
        if (fname) setFileName(fname);

        // Auto-map
        const autoMap = importAutoMapColumns(columns);
        setMapping(autoMap.mapping);
        setConfidences(autoMap.confidences);
        setStep("map");
      };

      const handleFileUpload = async (file) => {
        if (!file) return;

        // PDF handling
        if (file.name.toLowerCase().endsWith('.pdf') || file.type === 'application/pdf') {
          try {
            const arrayBuffer = await file.arrayBuffer();
            const pageTexts = await pdfExtractText(arrayBuffer);
            const songs = pdfParseAllPages(pageTexts);
            if (songs.length === 0) {
              alert('No song data found in PDF. The PDF may not be in a recognized format.');
              return;
            }
            // Convert to CSV and feed into existing pipeline
            const csvText = pdfSongsToCSV(songs);
            parseText(csvText, file.name);
          } catch (err) {
            console.error('PDF parse error:', err);
            alert('Failed to parse PDF: ' + (err.message || 'Unknown error'));
          }
          return;
        }

        // Regular text/CSV handling
        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target?.result;
          if (text) parseText(String(text), file.name);
        };
        reader.readAsText(file);
      };

      const handleDrop = (e) => {
        e.preventDefault(); setDragover(false);
        const file = e.dataTransfer?.files?.[0];
        if (file) handleFileUpload(file);
      };

      const runNormalization = () => {
        if (mapping.titleCol == null) return;
        // Convert column indices to column names
        const colMapping = {
          titleCol: parsedColumns[mapping.titleCol],
          artistCol: mapping.artistCol != null ? parsedColumns[mapping.artistCol] : null,
          durationCol: mapping.durationCol != null ? parsedColumns[mapping.durationCol] : null,
          styleCol: mapping.styleCol != null ? parsedColumns[mapping.styleCol] : null,
          keyCol: mapping.keyCol != null ? parsedColumns[mapping.keyCol] : null,
          tempoCol: mapping.tempoCol != null ? parsedColumns[mapping.tempoCol] : null,
          vocalistCol: mapping.vocalistCol != null ? parsedColumns[mapping.vocalistCol] : null
        };
        const result = importNormalizeAll(parsedRows, colMapping, opts);
        setNormalizedResult(result);
        setStep("normalize");
      };

      const handleImport = () => {
        if (!normalizedResult || normalizedResult.rows.length === 0) return;
        onImport(normalizedResult.rows, normalizedResult.report);
        handleClose();
      };

      const downloadCanonicalCSV = () => {
        if (!normalizedResult) return;
        const csv = importToCanonicalCSV(normalizedResult.rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `canonical-import-${new Date().toISOString().slice(0, 10)}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
      };

      const stepIndex = STEPS.indexOf(step);
      const sampleRows = parsedRows.slice(0, 5);

      const WARNING_LABELS = {
        multi_key_first_selected: "Multiple keys found, used first valid",
        key_invalid: "Key could not be recognized",
        tempo_range_first_selected: "Tempo range found, used first value",
        tempo_out_of_range: "Tempo out of range (1-300)",
        tempo_default_applied: "Default tempo applied",
        vocalist_default_all: "Empty vocalist defaulted to ALL",
        multi_vocalist_first_selected: "Multiple vocalists, used first",
        title_trimmed: "Title whitespace trimmed",
        title_smart_punct: "Smart punctuation converted",
        title_meta_paren_stripped: "Meta parenthetical stripped",
        style_aliased: "Style name mapped to standard vocabulary",
        style_unknown: "Style not in known styles list",
        artist_trimmed: "Artist whitespace trimmed"
      };

      return (
        <div className="modal-backdrop" onClick={handleClose}>
          <div className="import-modal" onClick={(e) => e.stopPropagation()}>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: ".75rem" }}>
              <h3 className="panel-title">Import Songs</h3>
              <button className="btn btn-small" onClick={handleClose}>Close</button>
            </div>

            {/* Step indicators */}
            <div className="import-steps">
              {STEPS.map((s, i) => (
                <div key={s} className={`import-step ${s === step ? "active" : ""} ${i < stepIndex ? "completed" : ""}`}>
                  {STEP_LABELS[s]}
                </div>
              ))}
            </div>

            {/* STEP 1: INPUT */}
            {step === "input" && (
              <div>
                <div className="import-tabs">
                  <button className={`import-tab ${inputTab === "upload" ? "active" : ""}`} onClick={() => setInputTab("upload")}>Upload File</button>
                  <button className={`import-tab ${inputTab === "paste" ? "active" : ""}`} onClick={() => setInputTab("paste")}>Paste Text</button>
                </div>

                {inputTab === "upload" && (
                  <div
                    className={`import-drop-zone ${dragover ? "dragover" : ""}`}
                    onDragOver={(e) => { e.preventDefault(); setDragover(true); }}
                    onDragLeave={() => setDragover(false)}
                    onDrop={handleDrop}
                    onClick={() => document.getElementById("import-file-input")?.click()}
                  >
                    <div style={{ fontSize: "2rem", marginBottom: ".5rem" }}>Drop file here or click to browse</div>
                    <div style={{ fontSize: ".85rem" }}>Supports CSV, TSV, TXT, and PDF</div>
                    <input id="import-file-input" type="file" accept=".csv,.tsv,.txt,.tab,.pdf" onChange={(e) => handleFileUpload(e.target.files?.[0])} />
                  </div>
                )}

                {inputTab === "paste" && (
                  <div>
                    <textarea
                      className="import-textarea"
                      placeholder={"Paste your song data here...\n\nExamples:\ntitle,key,tempo,vocalist\nCome Together,Dm,82,John\nSweet Home Alabama,D,100,ALL"}
                      value={rawText}
                      onChange={(e) => setRawText(e.target.value)}
                    />
                    <div className="import-footer">
                      <button className="btn btn-primary" onClick={() => parseText(rawText, "pasted-text")} disabled={!rawText.trim()}>
                        Parse Text
                      </button>
                    </div>
                  </div>
                )}

                <div className="set-config" style={{ marginTop: ".75rem" }}>
                  <div className="input-group">
                    <label>Delimiter</label>
                    <select value={delimiter} onChange={(e) => setDelimiter(e.target.value)}>
                      <option value="auto">Auto-detect</option>
                      <option value=",">Comma (,)</option>
                      <option value="&#9;">Tab</option>
                      <option value="|">Pipe (|)</option>
                      <option value=";">Semicolon (;)</option>
                    </select>
                  </div>
                  <div className="input-group">
                    <label style={{ display: "flex", alignItems: "center", gap: ".5rem" }}>
                      <input type="checkbox" checked={hasHeaders} onChange={(e) => setHasHeaders(e.target.checked)} style={{ width: "auto" }} />
                      First row is headers
                    </label>
                  </div>
                </div>
              </div>
            )}

            {/* STEP 2: MAP COLUMNS */}
            {step === "map" && (
              <div>
                <div style={{ marginBottom: ".75rem", fontSize: ".85rem", color: "var(--text-muted)" }}>
                  Parsed <strong style={{ color: "var(--accent)" }}>{parsedRows.length}</strong> rows with <strong style={{ color: "var(--accent)" }}>{parsedColumns.length}</strong> columns
                  {fileName && <span> from <strong>{fileName}</strong></span>}
                </div>

                {/* Preview table */}
                <div style={{ overflowX: "auto" }}>
                  <table className="import-preview-table">
                    <thead>
                      <tr>{parsedColumns.map((c, i) => <th key={i}>{c}</th>)}</tr>
                    </thead>
                    <tbody>
                      {sampleRows.map((row, ri) => (
                        <tr key={ri}>{parsedColumns.map((c, ci) => <td key={ci}>{String(row[c] ?? "")}</td>)}</tr>
                      ))}
                    </tbody>
                  </table>
                </div>

                {/* Column mapping */}
                <h4 style={{ color: "var(--accent)", margin: ".75rem 0 .5rem", fontSize: ".9rem" }}>Column Mapping</h4>
                <div className="import-mapping-grid">
                  {[
                    { key: "titleCol", label: "Title *", required: true },
                    { key: "artistCol", label: "Artist" },
                    { key: "durationCol", label: "Duration" },
                    { key: "styleCol", label: "Style / Genre" },
                    { key: "keyCol", label: "Key" },
                    { key: "tempoCol", label: "Tempo / BPM" },
                    { key: "vocalistCol", label: "Vocalist" }
                  ].map(({ key, label, required }) => (
                    <div key={key} className="import-mapping-item">
                      <label>
                        {label}
                        {confidences[key] && <span className="confidence">{confidences[key]}% match</span>}
                      </label>
                      <select
                        value={mapping[key] ?? "none"}
                        onChange={(e) => setMapping({ ...mapping, [key]: e.target.value === "none" ? null : parseInt(e.target.value) })}
                      >
                        <option value="none">{required ? "-- Select --" : "None"}</option>
                        {parsedColumns.map((c, i) => <option key={i} value={i}>{c}</option>)}
                      </select>
                    </div>
                  ))}
                </div>

                {/* Normalization options */}
                <h4 style={{ color: "var(--accent)", margin: ".75rem 0 .5rem", fontSize: ".9rem" }}>Normalization Options</h4>
                <div className="import-options">
                  {[
                    { key: "normalizeKeys", label: "Normalize keys (Cmaj -> C)" },
                    { key: "normalizeTempo", label: "Normalize tempo" },
                    { key: "normalizeVocalist", label: "Normalize vocalist" },
                    { key: "stripMetaParen", label: "Strip meta parens e.g. (demo)" }
                  ].map(({ key, label }) => (
                    <label key={key} className="import-option">
                      <input type="checkbox" checked={opts[key]} onChange={(e) => setOpts({ ...opts, [key]: e.target.checked })} />
                      {label}
                    </label>
                  ))}
                </div>

                <div className="set-config" style={{ marginTop: ".5rem" }}>
                  <div className="input-group">
                    <label>Default Tempo (blank = none)</label>
                    <input
                      type="number" min="1" max="300" placeholder="e.g. 120"
                      value={opts.defaultTempo ?? ""}
                      onChange={(e) => setOpts({ ...opts, defaultTempo: e.target.value ? parseInt(e.target.value) : null })}
                    />
                  </div>
                  <div className="input-group">
                    <label>Default Vocalist</label>
                    <input
                      value={opts.defaultVocalist}
                      onChange={(e) => setOpts({ ...opts, defaultVocalist: e.target.value || "ALL" })}
                    />
                  </div>
                </div>

                <div className="import-footer">
                  <button className="btn btn-small" onClick={() => { setStep("input"); }}>Back</button>
                  <button className="btn btn-primary" onClick={runNormalization} disabled={mapping.titleCol == null}>
                    Normalize & Preview
                  </button>
                </div>
              </div>
            )}

            {/* STEP 3: NORMALIZE / REVIEW */}
            {step === "normalize" && normalizedResult && (
              <div>
                {/* Guardrail banner */}
                <div className="import-guardrail">
                  Nothing is silently dropped. Only rows with empty titles are rejected. All other rows are imported even if key/tempo/vocalist are blank.
                </div>

                {/* Summary stats */}
                <div className="import-results-summary">
                  <div className="import-stat success">
                    <div className="number">{normalizedResult.report.rowsParsed}</div>
                    <div className="label">Rows Parsed</div>
                  </div>
                  <div className="import-stat success">
                    <div className="number">{normalizedResult.report.rowsImported}</div>
                    <div className="label">Will Import</div>
                  </div>
                  <div className={`import-stat ${normalizedResult.report.rowsRejected > 0 ? "error" : "success"}`}>
                    <div className="number">{normalizedResult.report.rowsRejected}</div>
                    <div className="label">Rejected</div>
                  </div>
                </div>

                {/* Equation check */}
                <div style={{ textAlign: "center", fontSize: ".8rem", color: "var(--text-muted)", margin: ".25rem 0 .75rem" }}>
                  {normalizedResult.report.rowsParsed} parsed = {normalizedResult.report.rowsImported} imported + {normalizedResult.report.rowsRejected} rejected
                  {normalizedResult.report.rowsParsed === normalizedResult.report.rowsImported + normalizedResult.report.rowsRejected
                    ? <span style={{ color: "var(--success)", marginLeft: ".5rem" }}>&#10003; Verified</span>
                    : <span style={{ color: "var(--error)", marginLeft: ".5rem" }}>Mismatch!</span>
                  }
                </div>

                {/* Warning counts */}
                {Object.keys(normalizedResult.report.warningCounts).length > 0 && (
                  <div>
                    <h4 style={{ color: "var(--warning)", fontSize: ".85rem", marginBottom: ".5rem" }}>Normalization Warnings</h4>
                    <div className="import-warnings-list">
                      {Object.entries(normalizedResult.report.warningCounts).map(([code, count]) => (
                        <div key={code} className="import-warning-item">
                          <span className="import-warning-code">{code}</span>
                          <span>{WARNING_LABELS[code] || code}</span>
                          <span style={{ marginLeft: "auto", color: "var(--accent)", fontWeight: 700 }}>x{count}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Sample changes */}
                {normalizedResult.report.sampleChanges.length > 0 && (
                  <div style={{ marginTop: ".75rem" }}>
                    <h4 style={{ color: "var(--accent)", fontSize: ".85rem", marginBottom: ".5rem" }}>
                      Sample Changes (showing {Math.min(normalizedResult.report.sampleChanges.length, 20)} of {normalizedResult.report.sampleChanges.length})
                    </h4>
                    <div style={{ maxHeight: "160px", overflowY: "auto" }}>
                      <table className="import-preview-table">
                        <thead><tr><th>Row</th><th>Field</th><th>Original</th><th>Normalized</th></tr></thead>
                        <tbody>
                          {normalizedResult.report.sampleChanges.slice(0, 20).flatMap((rc) =>
                            rc.changes.map((c, ci) => (
                              <tr key={`${rc.rowIndex}-${ci}`}>
                                <td>{rc.rowIndex}</td>
                                <td>{c.field}</td>
                                <td style={{ color: "var(--error)" }}>{c.original || "(empty)"}</td>
                                <td style={{ color: "var(--success)" }}>{c.normalized || "(empty)"}</td>
                              </tr>
                            ))
                          )}
                        </tbody>
                      </table>
                    </div>
                  </div>
                )}

                {/* Rejected rows */}
                {normalizedResult.rejected.length > 0 && (
                  <div style={{ marginTop: ".75rem" }}>
                    <h4 style={{ color: "var(--error)", fontSize: ".85rem", marginBottom: ".5rem" }}>
                      Rejected Rows ({normalizedResult.rejected.length})
                    </h4>
                    <table className="import-rejected-table">
                      <thead><tr><th>Row #</th><th>Reason</th><th>Raw Data</th></tr></thead>
                      <tbody>
                        {normalizedResult.rejected.map((r, i) => (
                          <tr key={i}>
                            <td>{r.rowIndex}</td>
                            <td>{r.reason}</td>
                            <td style={{ maxWidth: "300px", overflow: "hidden", textOverflow: "ellipsis" }}>
                              {JSON.stringify(r.raw).slice(0, 100)}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

                {/* Normalized data preview */}
                <div style={{ marginTop: ".75rem" }}>
                  <h4 style={{ color: "var(--accent)", fontSize: ".85rem", marginBottom: ".5rem" }}>
                    Import Preview (first 10 rows)
                  </h4>
                  <div style={{ overflowX: "auto" }}>
                    <table className="import-preview-table">
                      <thead><tr><th>Title</th><th>Artist</th><th>Dur</th><th>Style</th><th>Key</th><th>BPM</th><th>Vocalist</th></tr></thead>
                      <tbody>
                        {normalizedResult.rows.slice(0, 10).map((r, i) => (
                          <tr key={i}>
                            <td>{r.title}</td>
                            <td>{r.artist}</td>
                            <td>{r.duration}</td>
                            <td>{r.style}</td>
                            <td>{r.key}</td>
                            <td>{r.tempo}</td>
                            <td>{r.vocalist}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>

                <div className="import-footer">
                  <button className="btn btn-small" onClick={() => setStep("map")}>Back</button>
                  <button className="btn btn-small" onClick={downloadCanonicalCSV}>Download Canonical CSV</button>
                  <button className="btn btn-primary" onClick={handleImport} disabled={normalizedResult.rows.length === 0}>
                    Import {normalizedResult.rows.length} Songs
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function BandModal({ open, onClose, bands, onCreate, onDelete, onDuplicate }) {
      const [form, setForm] = useState({ name: '', icon: 'ðŸŽµ', color: '#ff6b35' });
      if (!open) return null;

      const handleCreate = () => {
        if (!form.name.trim()) return;
        onCreate(form);
        setForm({ name: '', icon: 'ðŸŽµ', color: '#ff6b35' });
      };

      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal" onClick={e => e.stopPropagation()}>
            <div className="panel-header">
              <h3 className="panel-title">Manage Bands</h3>
              <button className="btn btn-small" onClick={onClose}>Close</button>
            </div>

            <div className="input-group">
              <label>Band Name</label>
              <input value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} placeholder="Enter band name" />
            </div>

            <div className="set-config">
              <div className="input-group">
                <label>Icon</label>
                <input value={form.icon} onChange={e => setForm({ ...form, icon: e.target.value })} placeholder="ðŸŽµ" />
              </div>
              <div className="input-group">
                <label>Color</label>
                <input type="color" value={form.color} onChange={e => setForm({ ...form, color: e.target.value })} />
              </div>
            </div>

            <button className="btn btn-primary" onClick={handleCreate} style={{ width: '100%', marginBottom: '1rem' }}>
              Create Band
            </button>

            <div style={{ maxHeight: '300px', overflowY: 'auto' }}>
              {bands.map(band => (
                <div key={band.id} className="band-row">
                  <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>
                    <span style={{ fontSize: '1.2rem' }}>{band.icon}</span>
                    <div>
                      <div style={{ fontWeight: 600 }}>{band.name}</div>
                      <div className="band-id">{band.id}</div>
                    </div>
                    <span className="swatch" style={{ background: band.color, marginLeft: '.5rem', width: 12, height: 12, borderRadius: 999, border: '1px solid var(--border)' }}></span>
                  </div>
                  <div style={{ display: 'flex', gap: '.5rem' }}>
                    <button className="btn btn-small" onClick={() => onDuplicate(band)}>Duplicate</button>
                    <button className="btn btn-small" onClick={() => onDelete(band)}>Delete</button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    function PrintView({ setlists, watermarkImg }) {
      return (
        <div className="print-only">
          {setlists.map((set, setIdx) => (
            <div key={set.id} className="set-page" style={{ position: 'relative' }}>
              {watermarkImg && (
                <div style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: '100%',
                  opacity: 0.12,
                  pointerEvents: 'none',
                  zIndex: 0
                }}>
                  <img src={watermarkImg} alt="" style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
                </div>
              )}
              <div style={{ position: 'relative', zIndex: 1, padding: '0.25in' }}>
                <div style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '20pt', fontWeight: 'bold', textTransform: 'uppercase', textDecoration: 'underline', marginBottom: '12px' }}>
                  {set.name}
                </div>
                <div style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '14pt', fontWeight: 'bold', marginBottom: '6px' }}>
                  {set.songs.length} songs | {Math.round(set.totalTime)} minutes
                  {setlists.qualityScores && setlists.qualityScores[setIdx] && (
                    <span style={{ marginLeft: '12px', fontSize: '11pt', fontWeight: 'normal' }}>
                      Quality: {setlists.qualityScores[setIdx].overall}/100
                    </span>
                  )}
                </div>
                {/* Column headers */}
                <div style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '9pt', fontWeight: 'bold', color: '#666', display: 'grid', gridTemplateColumns: '30px 1fr 50px 50px 70px', gap: '4px', borderBottom: '1px solid #ccc', paddingBottom: '4px', marginBottom: '8px' }}>
                  <span>#</span>
                  <span>TITLE / ARTIST</span>
                  <span>KEY</span>
                  <span>BPM</span>
                  <span>STYLE</span>
                </div>
                <div>
                  {set.songs.map((song, idx) => (
                    <div key={`print-${song.id}-${idx}`} style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '18pt', fontWeight: 'bold', lineHeight: 1.0, marginBottom: '6px', display: 'grid', gridTemplateColumns: '30px 1fr 50px 50px 70px', gap: '4px', alignItems: 'baseline' }}>
                      <span style={{ fontSize: '14pt', color: '#666' }}>{idx + 1}</span>
                      <span>{song.title}{song.artist ? ` - ${song.artist}` : ''}</span>
                      <span style={{ fontSize: '12pt' }}>{song.key || ''}</span>
                      <span style={{ fontSize: '12pt' }}>{song.bpm || ''}</span>
                      <span style={{ fontSize: '10pt', textTransform: 'capitalize' }}>{song.style || ''}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ))}
        </div>
      );
    }

    /******************* GIG PROFILES *******************/
    function GigProfileModal({ open, onClose, gigs, onCreateGig, onDeleteGig, onLoadGig, onSaveToGig, onExportGigCSV, setlists, bandName }) {
      const [form, setForm] = useState({
        name: '', venue: '', date: '', notes: '',
        // Venue info fields (common across GigSalad, Sonicbids, Bands in Town, Gigmit, etc.)
        venueCity: '', venueState: '', venueZip: '',
        venueType: '', // bar, club, festival, private, corporate, theater, outdoor
        venueCapacity: '',
        contactName: '', contactEmail: '', contactPhone: '',
        loadInTime: '', soundCheckTime: '', setStartTime: '',
        compensation: '', // flat fee, door split, percentage, etc.
        eventType: '', // wedding, corporate, festival, bar gig, private party
        ageRestriction: '', // all ages, 18+, 21+
        backlineProvided: false,
        paProvided: false
      });
      const [showVenueDetails, setShowVenueDetails] = useState(false);

      if (!open) return null;

      const handleCreate = () => {
        if (!form.name.trim()) return;
        onCreateGig(form);
        setForm({
          name: '', venue: '', date: '', notes: '',
          venueCity: '', venueState: '', venueZip: '',
          venueType: '', venueCapacity: '',
          contactName: '', contactEmail: '', contactPhone: '',
          loadInTime: '', soundCheckTime: '', setStartTime: '',
          compensation: '', eventType: '', ageRestriction: '',
          backlineProvided: false, paProvided: false
        });
      };

      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal" onClick={e => e.stopPropagation()} style={{ width: 'min(720px, 95vw)', maxHeight: '90vh', overflowY: 'auto' }}>
            <div className="panel-header">
              <h3 className="panel-title">Gig Profiles â€” {bandName}</h3>
              <button className="btn btn-small" onClick={onClose}>Close</button>
            </div>

            <div style={{ marginBottom: '1rem', fontSize: '.85rem', color: 'var(--text-muted)' }}>
              Create gig profiles for specific venues and dates. Save and load setlists for each gig. Export gig setlists as CSV.
            </div>

            {/* Basic Gig Info */}
            <div className="set-config">
              <div className="input-group">
                <label>Gig Name*</label>
                <input value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} placeholder="e.g. Friday at The Roxy" />
              </div>
              <div className="input-group">
                <label>Venue Name</label>
                <input value={form.venue} onChange={e => setForm({ ...form, venue: e.target.value })} placeholder="e.g. The Roxy" />
              </div>
            </div>
            <div className="set-config">
              <div className="input-group">
                <label>Date</label>
                <input type="date" value={form.date} onChange={e => setForm({ ...form, date: e.target.value })} />
              </div>
              <div className="input-group">
                <label>Event Type</label>
                <select value={form.eventType} onChange={e => setForm({ ...form, eventType: e.target.value })}>
                  <option value="">Select...</option>
                  <option value="bar_gig">Bar / Club Gig</option>
                  <option value="festival">Festival</option>
                  <option value="corporate">Corporate Event</option>
                  <option value="wedding">Wedding / Reception</option>
                  <option value="private_party">Private Party</option>
                  <option value="theater">Theater / Concert Hall</option>
                  <option value="outdoor">Outdoor Event</option>
                  <option value="house_concert">House Concert</option>
                  <option value="charity">Charity / Benefit</option>
                  <option value="other">Other</option>
                </select>
              </div>
            </div>

            {/* Expandable Venue Details */}
            <button
              className="btn btn-small"
              onClick={() => setShowVenueDetails(!showVenueDetails)}
              style={{ width: '100%', marginBottom: '.75rem', textAlign: 'left' }}
            >
              {showVenueDetails ? 'â–¾' : 'â–¸'} Venue Details &amp; Contact Info
            </button>

            {showVenueDetails && (
              <div style={{ background: 'var(--primary)', border: '1px solid var(--border)', borderRadius: '8px', padding: '.75rem', marginBottom: '.75rem' }}>
                <div className="set-config">
                  <div className="input-group">
                    <label>City</label>
                    <input value={form.venueCity} onChange={e => setForm({ ...form, venueCity: e.target.value })} placeholder="City" />
                  </div>
                  <div className="input-group">
                    <label>State/Region</label>
                    <input value={form.venueState} onChange={e => setForm({ ...form, venueState: e.target.value })} placeholder="State" />
                  </div>
                </div>
                <div className="set-config">
                  <div className="input-group">
                    <label>ZIP/Postal Code</label>
                    <input value={form.venueZip} onChange={e => setForm({ ...form, venueZip: e.target.value })} placeholder="ZIP" />
                  </div>
                  <div className="input-group">
                    <label>Venue Type</label>
                    <select value={form.venueType} onChange={e => setForm({ ...form, venueType: e.target.value })}>
                      <option value="">Select...</option>
                      <option value="bar">Bar / Pub</option>
                      <option value="club">Night Club</option>
                      <option value="restaurant">Restaurant</option>
                      <option value="theater">Theater</option>
                      <option value="arena">Arena / Stadium</option>
                      <option value="outdoor_amphitheater">Outdoor Amphitheater</option>
                      <option value="festival_grounds">Festival Grounds</option>
                      <option value="hotel_ballroom">Hotel / Ballroom</option>
                      <option value="community_center">Community Center</option>
                      <option value="private_residence">Private Residence</option>
                      <option value="winery_brewery">Winery / Brewery</option>
                      <option value="coffeehouse">Coffeehouse</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                </div>
                <div className="set-config">
                  <div className="input-group">
                    <label>Capacity</label>
                    <input value={form.venueCapacity} onChange={e => setForm({ ...form, venueCapacity: e.target.value })} placeholder="e.g. 200" />
                  </div>
                  <div className="input-group">
                    <label>Age Restriction</label>
                    <select value={form.ageRestriction} onChange={e => setForm({ ...form, ageRestriction: e.target.value })}>
                      <option value="">Select...</option>
                      <option value="all_ages">All Ages</option>
                      <option value="18+">18+</option>
                      <option value="21+">21+</option>
                    </select>
                  </div>
                </div>

                <div style={{ borderTop: '1px solid var(--border)', marginTop: '.5rem', paddingTop: '.5rem' }}>
                  <div style={{ fontSize: '.75rem', fontWeight: 600, color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '.05em', marginBottom: '.4rem' }}>Contact Info</div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Contact Name</label>
                      <input value={form.contactName} onChange={e => setForm({ ...form, contactName: e.target.value })} placeholder="Booking contact" />
                    </div>
                    <div className="input-group">
                      <label>Contact Email</label>
                      <input type="email" value={form.contactEmail} onChange={e => setForm({ ...form, contactEmail: e.target.value })} placeholder="email@venue.com" />
                    </div>
                  </div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Contact Phone</label>
                      <input value={form.contactPhone} onChange={e => setForm({ ...form, contactPhone: e.target.value })} placeholder="(555) 123-4567" />
                    </div>
                    <div className="input-group">
                      <label>Compensation</label>
                      <input value={form.compensation} onChange={e => setForm({ ...form, compensation: e.target.value })} placeholder="e.g. $500, door split" />
                    </div>
                  </div>
                </div>

                <div style={{ borderTop: '1px solid var(--border)', marginTop: '.5rem', paddingTop: '.5rem' }}>
                  <div style={{ fontSize: '.75rem', fontWeight: 600, color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '.05em', marginBottom: '.4rem' }}>Schedule &amp; Logistics</div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Load-In Time</label>
                      <input type="time" value={form.loadInTime} onChange={e => setForm({ ...form, loadInTime: e.target.value })} />
                    </div>
                    <div className="input-group">
                      <label>Sound Check</label>
                      <input type="time" value={form.soundCheckTime} onChange={e => setForm({ ...form, soundCheckTime: e.target.value })} />
                    </div>
                  </div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Set Start Time</label>
                      <input type="time" value={form.setStartTime} onChange={e => setForm({ ...form, setStartTime: e.target.value })} />
                    </div>
                    <div className="input-group" style={{ display: 'flex', gap: '.75rem', alignItems: 'flex-end' }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: '.4rem', cursor: 'pointer', textTransform: 'none', fontSize: '.8rem' }}>
                        <input type="checkbox" checked={form.backlineProvided} onChange={e => setForm({ ...form, backlineProvided: e.target.checked })} style={{ width: 'auto' }} />
                        Backline
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: '.4rem', cursor: 'pointer', textTransform: 'none', fontSize: '.8rem' }}>
                        <input type="checkbox" checked={form.paProvided} onChange={e => setForm({ ...form, paProvided: e.target.checked })} style={{ width: 'auto' }} />
                        PA Provided
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            )}

            <div className="input-group">
              <label>Notes</label>
              <textarea value={form.notes} onChange={e => setForm({ ...form, notes: e.target.value })} placeholder="Special requests, parking info, dress code..." rows={2} style={{ resize: 'vertical' }} />
            </div>

            <button className="btn btn-primary" onClick={handleCreate} style={{ width: '100%', marginBottom: '1rem' }}>
              Create Gig Profile
            </button>

            <div style={{ maxHeight: '350px', overflowY: 'auto' }}>
              {gigs.length === 0 ? (
                <div style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '1.5rem' }}>
                  No gig profiles yet. Create one above.
                </div>
              ) : (
                gigs.sort((a, b) => {
                  if (a.date && b.date) return a.date.localeCompare(b.date);
                  if (a.date) return -1;
                  if (b.date) return 1;
                  return (b.createdAt || 0) - (a.createdAt || 0);
                }).map(gig => (
                  <div key={gig.id} className="band-row" style={{ flexDirection: 'column', alignItems: 'stretch', gap: '.5rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <div style={{ flex: 1, minWidth: 0 }}>
                        <div style={{ fontWeight: 700 }}>{gig.name}</div>
                        <div style={{ fontSize: '.8rem', color: 'var(--text-muted)' }}>
                          {gig.venue && <span>{gig.venue}</span>}
                          {gig.venueCity && <span>, {gig.venueCity}</span>}
                          {gig.venueState && <span>, {gig.venueState}</span>}
                          {gig.date && <span> | {gig.date}</span>}
                          {gig.eventType && <span> | {gig.eventType.replace(/_/g, ' ')}</span>}
                          {gig.setlists && <span> | {gig.setlists.length} set(s)</span>}
                        </div>
                        {gig.setStartTime && <div style={{ fontSize: '.75rem', color: 'var(--accent)' }}>Start: {gig.setStartTime}</div>}
                        {gig.notes && <div style={{ fontSize: '.75rem', color: 'var(--text-muted)', fontStyle: 'italic', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{gig.notes}</div>}
                      </div>
                      <div style={{ display: 'flex', gap: '.3rem', flexShrink: 0, flexWrap: 'wrap', justifyContent: 'flex-end' }}>
                        {setlists.length > 0 && (
                          <button className="btn btn-small" onClick={() => onSaveToGig(gig.id)} style={{ borderColor: 'var(--success)', color: 'var(--success)' }}>
                            Save
                          </button>
                        )}
                        {gig.setlists && gig.setlists.length > 0 && (
                          <>
                            <button className="btn btn-small" onClick={() => onLoadGig(gig.id)} style={{ borderColor: 'var(--accent)', color: 'var(--accent)' }}>
                              Load
                            </button>
                            <button className="btn btn-small" onClick={() => onExportGigCSV(gig.id)} style={{ borderColor: 'var(--warning)', color: 'var(--warning)' }}>
                              CSV
                            </button>
                          </>
                        )}
                        <button className="btn btn-small" onClick={() => onDeleteGig(gig.id)}>Del</button>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      );
    }

    /******************* MAIN APP *******************/
    function App() {
      const [bands, setBands] = useState([]);
      const [activeBandId, setActiveBandId] = useState(null);

      const [songs, setSongs] = useState([]);
      const [settings, setSettings] = useState({ numSets: 2, setDuration: 45, allowSongReuse: false, useEnergyCurve: true, forceOpener: false, forceCloser: true, lockedOpeners: [], lockedClosers: [], useTonalGravity: false, tonalSmoothness: 70, anchorKey: '', showDetailedDiagnostics: false, energyCurveType: 'standard', energyWeight: 0.35, tonalWeight: 0.25, diversityWeight: 1.0, randomness: 50, optimizationLevel: 'standard', setTemplate: 'freeform', songAffinities: [], songAntiAffinities: [] });
      const [setlists, setSetlists] = useState([]);
      const [locked, setLocked] = useState(new Set());
      // Cross-set drag-and-drop state
      const defaultDragState = { active: false, song: null, fromSetIdx: null, fromSongIdx: null, overSetIdx: null, overSongIdx: null };
      const [dragState, setDragState] = useState(defaultDragState);
      const [originalSetlists, setOriginalSetlists] = useState(null);

      const [isReorderMode, setIsReorderMode] = useState(false);

      const [bandModal, setBandModal] = useState(false);
      const [importModal, setImportModal] = useState(false);
      const [gigModal, setGigModal] = useState(false);
      const [toast, setToast] = useState(null);
      const [lastGenerationStats, setLastGenerationStats] = useState(null);
      const [imports, setImports] = useState([]);
      const [gigs, setGigs] = useState([]);
      const [watermarkImg, setWatermarkImg] = useState(null);

      // PHASE 3A: active/cold library tab
      const [libraryTab, setLibraryTab] = useState('active');

      const showToast = (message, type = 'success') => setToast({ message, type });

      const activeBand = useMemo(() => bands.find(b => b.id === activeBandId), [bands, activeBandId]);

      // PHASE 3A: derived active/cold
      const activeSongs = useMemo(() => songs.filter(s => (s.status || 'active') === 'active'), [songs]);
      const coldSongs = useMemo(() => songs.filter(s => (s.status || 'active') === 'cold'), [songs]);

      const activeLibraryTime = useMemo(
        () => activeSongs.reduce((sum, s) => sum + parseDuration(s.duration), 0),
        [activeSongs]
      );

      // LOAD BANDS FROM STORAGE
      useEffect(() => {
        const stored = LS.get(LS_KEYS.bands);
        if (stored && Array.isArray(stored) && stored.length > 0) {
          setBands(stored);
          const activeId = LS.get(LS_KEYS.active) || stored[0].id;
          setActiveBandId(activeId);
        } else {
          const defaultBand = {
            id: genId(),
            name: 'Default Band',
            icon: 'ðŸŽµ',
            color: '#ff6b35'
          };
          setBands([defaultBand]);
          setActiveBandId(defaultBand.id);
          LS.set(LS_KEYS.bands, [defaultBand]);
          LS.set(LS_KEYS.active, defaultBand.id);
        }
      }, []);

      // SAVE BANDS TO STORAGE
      useEffect(() => {
        if (bands.length > 0) LS.set(LS_KEYS.bands, bands);
      }, [bands]);

      // LOAD ACTIVE BAND DATA
      useEffect(() => {
        if (!activeBandId) return;

        const storedSongsRaw = LS.get(LS_KEYS.bandSongs(activeBandId)) || [];
        // PHASE 3A: normalize status for older data
        const normalizedSongs = storedSongsRaw.map(s => ({ ...s, status: (s.status || 'active') }));

        const storedSettings = LS.get(LS_KEYS.bandSettings(activeBandId)) || { numSets: 2, setDuration: 45, allowSongReuse: false, useEnergyCurve: true, forceOpener: false, forceCloser: true, lockedOpeners: [], lockedClosers: [], useTonalGravity: false, tonalSmoothness: 70, anchorKey: '', showDetailedDiagnostics: false, energyCurveType: 'standard', energyWeight: 0.35, tonalWeight: 0.25, diversityWeight: 1.0, randomness: 50, optimizationLevel: 'standard', setTemplate: 'freeform', songAffinities: [], songAntiAffinities: [] };
        // Ensure backward compatibility for settings without newer fields
        if (!storedSettings.lockedOpeners) storedSettings.lockedOpeners = [];
        if (!storedSettings.lockedClosers) storedSettings.lockedClosers = [];
        if (!storedSettings.energyCurveType) storedSettings.energyCurveType = 'standard';
        if (storedSettings.energyWeight == null) storedSettings.energyWeight = 0.35;
        if (storedSettings.tonalWeight == null) storedSettings.tonalWeight = 0.25;
        if (storedSettings.diversityWeight == null) storedSettings.diversityWeight = 1.0;
        if (storedSettings.randomness == null) storedSettings.randomness = 50;
        if (!storedSettings.optimizationLevel) storedSettings.optimizationLevel = 'standard';
        if (!storedSettings.setTemplate) storedSettings.setTemplate = 'freeform';
        if (!storedSettings.songAffinities) storedSettings.songAffinities = [];
        if (!storedSettings.songAntiAffinities) storedSettings.songAntiAffinities = [];
        const storedImports = LS.get(LS_KEYS.bandImports(activeBandId)) || [];
        const storedGigs = LS.get(LS_KEYS.bandGigs(activeBandId)) || [];
        const storedWatermark = LS.get(LS_KEYS.bandWatermark(activeBandId)) || null;

        setSongs(normalizedSongs);
        setSettings(storedSettings);
        setImports(storedImports);
        setGigs(storedGigs);
        setWatermarkImg(storedWatermark);

        setSetlists([]);
        setLocked(new Set());
        setLibraryTab('active');
      }, [activeBandId]);

      // SAVE ACTIVE BAND DATA
      useEffect(() => {
        if (activeBandId) LS.set(LS_KEYS.bandSongs(activeBandId), songs);
      }, [songs, activeBandId]);

      useEffect(() => {
        if (activeBandId) LS.set(LS_KEYS.bandSettings(activeBandId), settings);
      }, [settings, activeBandId]);

      // PHASE 2: Build lock plan from current setlists
      const buildLockPlanFromCurrentSetlists = () => {
        if (!setlists || setlists.length === 0 || locked.size === 0) return null;

        const plan = [];
        for (let setIdx = 0; setIdx < setlists.length; setIdx++) {
          const set = setlists[setIdx];
          if (!set) { plan.push([]); continue; }

          const lockedEntries = [];
          set.songs.forEach((song, idx) => {
            if (song && locked.has(`${setIdx}:${song.id}`)) {
              lockedEntries.push({ index: idx, song });
            }
          });
          plan.push(lockedEntries);
        }
        return plan;
      };

      const generate = () => {
        // PHASE 3A: generator uses ACTIVE only
        const lockPlan = buildLockPlanFromCurrentSetlists();
        const generatorFn = settings.useTonalGravity ? generateSetlistsCore_WithTonalGravity : generateSetlistsCore;
        // Pre-compute anchor key so the core generator can use it for tonal-aware selection
        let _anchorKey = null;
        if (settings.useTonalGravity) {
          const enrichedForAnchor = activeSongs.map(s => ({
            ...s,
            normalizedKey: normalizeKey_TG(s.key, s.tags || [])
          }));
          _anchorKey = determineAnchorKey_TG(enrichedForAnchor, settings.anchorKey || '');
        }
        const out = generatorFn(activeSongs, {
          ...settings,
          lockPlan: lockPlan || null,
          _anchorKey
        });
        // Compute quality scores if not already attached (non-tonal-gravity path)
        if (!out.qualityScores) {
          try {
            out.qualityScores = out.map(set => calculateSetlistQualityScore(set, {
              ...settings, _anchorKey
            }));
          } catch (e) { console.warn('Quality score computation failed:', e); }
        }
        setSetlists(out);
        setLastGenerationStats(out.stats);

        const history = LS.get(LS_KEYS.bandHistory(activeBandId)) || [];
        const newEntry = { ts: Date.now(), settings, setlists: out };
        LS.set(LS_KEYS.bandHistory(activeBandId), [newEntry, ...history].slice(0, 50));

        if (out.generationWarnings && out.generationWarnings.length) {
          showToast(out.generationWarnings[0], 'warning');
        } else {
          showToast(`Generated ${settings.numSets} set(s)`, 'success');
        }
      };

      const addSong = (songData) => {
        const newSong = { id: genId(), status: 'active', ...songData };
        setSongs([...songs, newSong]);
        showToast('Song added (Active)', 'success');
      };

      const deleteSong = (id) => {
        setSongs(songs.filter(s => s.id !== id));
        showToast('Song deleted', 'warning');
      };

      // PHASE 3A: shelf/restore
      const shelfSong = (id) => {
        setSongs(songs.map(s => s.id === id ? { ...s, status: 'cold' } : s));
        // remove from setlists + locks if it appears (optional safety)
        setLocked(prev => {
          const next = new Set(prev);
          [...next].forEach(k => {
            const [, songId] = k.split(':');
            if (songId === id) next.delete(k);
          });
          return next;
        });
        showToast('Shelved to Cold List', 'success');
      };

      const restoreSong = (id) => {
        setSongs(songs.map(s => s.id === id ? { ...s, status: 'active' } : s));
        showToast('Restored to Active', 'success');
      };

      const clearAllSongs = () => {
        if (!window.confirm('Delete all songs? This cannot be undone.')) return;
        setSongs([]);
        setSetlists([]);
        setLocked(new Set());
        setLastGenerationStats(null);
        showToast('All songs deleted', 'warning');
      };

      // PHASE 2: CSV Export with proper quoting + enhanced energy/tonal data
      const exportSongs = () => {
        const headers = ['Title', 'Artist', 'Duration', 'Style', 'Key', 'BPM', 'Vocalist', 'Energy', 'Status'];
        const rows = songs.map(s => {
          const energy = getCompositeEnergy(s);
          return [
            csvEscapeCell(s.title),
            csvEscapeCell(s.artist),
            csvEscapeCell(s.duration ?? ''),
            csvEscapeCell(s.style ?? ''),
            csvEscapeCell(s.key ?? ''),
            csvEscapeCell(s.bpm ?? ''),
            csvEscapeCell(s.vocalist ?? ''),
            csvEscapeCell(Math.round(energy * 10) / 10),
            csvEscapeCell(s.status || 'active')
          ];
        });
        const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `songs-${activeBand?.name || 'band'}-${new Date().toISOString().slice(0, 10)}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
      };

      const importCSVRobust = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        // Handle PDF files via Quick Import
        if (file.name.toLowerCase().endsWith('.pdf') || file.type === 'application/pdf') {
          try {
            const arrayBuffer = await file.arrayBuffer();
            const pageTexts = await pdfExtractText(arrayBuffer);
            const pdfSongs = pdfParseAllPages(pageTexts);
            if (pdfSongs.length === 0) return showToast('No song data found in PDF', 'error');

            const imported = pdfSongs.map(s => ({
              id: genId(),
              status: 'active',
              title: sanitizeInput(s.title),
              artist: sanitizeInput(s.artist),
              duration: parseDuration(s.duration),
              style: (s.style && PDF_KNOWN_STYLES.has(s.style.toLowerCase())) ? s.style.toLowerCase() : 'midtempo',
              key: s.key || '',
              bpm: s.bpm || '',
              vocalist: s.vocalist || ''
            }));

            setSongs([...songs, ...imported]);
            const newImport = { ts: Date.now(), count: imported.length, filename: file.name };
            const updatedImports = [newImport, ...imports].slice(0, 10);
            setImports(updatedImports);
            LS.set(LS_KEYS.bandImports(activeBandId), updatedImports);
            showToast(`Imported ${imported.length} songs from PDF`, 'success');
          } catch (err) {
            console.error('PDF parse error:', err);
            showToast('Failed to parse PDF: ' + (err.message || 'Unknown error'), 'error');
          }
          e.target.value = '';
          return;
        }

        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target?.result;
          if (!text) return;

          // Use PapaParse for robust CSV parsing (handles quoted commas, etc.)
          const result = Papa.parse(String(text), {
            header: true, skipEmptyLines: 'greedy', dynamicTyping: false
          });
          if (!result.data || result.data.length === 0) return showToast('CSV empty or invalid', 'error');

          const imported = [];
          for (const row of result.data) {
            // Map column names case-insensitively
            const get = (keys) => {
              for (const k of keys) {
                for (const col of Object.keys(row)) {
                  if (col.toLowerCase().trim() === k) return (row[col] || '').trim();
                }
              }
              return '';
            };
            const title = get(['title', 'song', 'song title', 'name', 'tune', 'track']);
            const artist = get(['artist', 'band', 'performer', 'by']);
            const duration = get(['duration', 'dur', 'time', 'length', 'minutes']);
            const style = get(['style', 'genre', 'type', 'feel']);
            const key = get(['key', 'tonality', 'pitch']);
            const bpm = get(['bpm', 'tempo', 'speed']);
            const vocalist = get(['vocalist', 'singer', 'lead', 'vox', 'vocal']);

            if (!title || !artist || !duration) continue;

            imported.push({
              id: genId(),
              status: 'active',
              title: sanitizeInput(title),
              artist: sanitizeInput(artist),
              duration: parseDuration(duration),
              style: (style || 'midtempo').toLowerCase(),
              key: key || '',
              bpm: bpm || '',
              vocalist: vocalist || ''
            });
          }

          if (imported.length === 0) return showToast('No valid songs found', 'error');

          setSongs([...songs, ...imported]);
          const newImport = { ts: Date.now(), count: imported.length, filename: file.name };
          const updatedImports = [newImport, ...imports].slice(0, 10);
          setImports(updatedImports);
          LS.set(LS_KEYS.bandImports(activeBandId), updatedImports);
          showToast(`Imported ${imported.length} songs`, 'success');
        };
        reader.readAsText(file);
        e.target.value = '';
      };

      const downloadSampleCSV = () => {
        const sample =
`Title,Artist,Duration,Style,Key,BPM,Vocalist
"25 or 6 to 4","Chicago",4.82,uptempo,Am,147,Beau
"Call Me the Breeze","Lynyrd Skynyrd",5.15,midtempo,A,192,Kelly
"Hard To Handle","The Black Crowes",3.13,uptempo,B,103,Kelly
"Hold On Loosely","38 Special",4.68,midtempo,E,128,Beau
"La Grange","ZZ Top",3.83,uptempo,A,162,Chris
"Come Together","The Beatles",4.5,groove,Dm,82,ALL
"Sweet Home Alabama","Lynyrd Skynyrd",4.75,midtempo,D,100,Chris
"Billie Jean","Michael Jackson",4.25,uptempo,F#m,117,ALL
"Stormy Monday","Allman Brothers",7.25,blues,G,80,ALL
"Pride and Joy","Stevie Ray Vaughan",3.62,shuffle,E,127,ALL
"Fly Away","Lenny Kravitz",3.62,rock,A,138,ALL`;
        const blob = new Blob([sample], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'sample-setlist.csv';
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
      };

      // Canonical import with dedup
      const importCanonicalRows = (rows, report) => {
        const existingKeys = new Set(
          songs.map(s => (s.title || "").toLowerCase().trim())
        );
        const imported = [];
        let dupeCount = 0;

        for (const row of rows) {
          const dedupKey = (row.title || "").toLowerCase().trim();
          if (existingKeys.has(dedupKey)) {
            // Merge missing fields into existing
            const idx = songs.findIndex(s => (s.title || "").toLowerCase().trim() === dedupKey);
            if (idx >= 0) {
              const existing = songs[idx];
              let updated = false;
              const merged = { ...existing };
              if (!merged.key && row.key) { merged.key = row.key; updated = true; }
              if (!merged.bpm && row.tempo) { merged.bpm = row.tempo; updated = true; }
              if (!merged.artist && row.artist) { merged.artist = sanitizeInput(row.artist); updated = true; }
              if ((!merged.duration || merged.duration === DEFAULT_DURATION_MINUTES) && row.duration) { merged.duration = parseDuration(row.duration); updated = true; }
              if (merged.style === 'midtempo' && row.style && row.style !== 'midtempo') { merged.style = row.style; updated = true; }
              if (updated) {
                const newSongs = [...songs];
                newSongs[idx] = merged;
                setSongs(newSongs);
              }
            }
            dupeCount++;
            continue;
          }

          existingKeys.add(dedupKey);
          imported.push({
            id: genId(),
            status: 'active',
            title: sanitizeInput(row.title),
            artist: sanitizeInput(row.artist || ''),
            duration: parseDuration(row.duration || 0),
            style: row.style || 'midtempo',
            key: row.key || '',
            bpm: row.tempo || '',
            vocalist: row.vocalist || ''
          });
        }

        if (imported.length > 0) {
          setSongs(prev => [...prev, ...imported]);
        }

        const newImport = { ts: Date.now(), count: imported.length, filename: 'canonical-import', dupes: dupeCount };
        const updatedImports = [newImport, ...imports].slice(0, 10);
        setImports(updatedImports);
        LS.set(LS_KEYS.bandImports(activeBandId), updatedImports);

        let msg = `Imported ${imported.length} songs`;
        if (dupeCount > 0) msg += ` (${dupeCount} duplicates merged/skipped)`;
        msg += ` | Parsed: ${report.rowsParsed}, Rejected: ${report.rowsRejected}`;
        showToast(msg, 'success');
      };

      const copyToClipboard = () => {
        const text = setlists.map((set) => {
          const header = `${set.name} (${set.songs.length} songs, ${Math.round(set.totalTime)} min)\n${'='.repeat(50)}`;
          const songList = set.songs.map((s, idx) => {
            const meta = [];
            if (s.key) meta.push(s.key);
            if (s.bpm) meta.push(`${s.bpm} BPM`);
            const metaStr = meta.length > 0 ? ` (${meta.join(' | ')})` : '';
            return `${idx + 1}. ${s.title}${s.artist ? ` - ${s.artist}` : ''}${metaStr}`;
          }).join('\n');
          return `${header}\n${songList}`;
        }).join('\n\n');

        navigator.clipboard.writeText(text).then(() => showToast('Copied to clipboard', 'success'));
      };

      const handleWatermarkUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const dataUrl = ev.target.result;
          setWatermarkImg(dataUrl);
          if (activeBandId) LS.set(LS_KEYS.bandWatermark(activeBandId), dataUrl);
          showToast('Watermark image set', 'success');
        };
        reader.readAsDataURL(file);
      };

      const clearWatermark = () => {
        setWatermarkImg(null);
        if (activeBandId) LS.set(LS_KEYS.bandWatermark(activeBandId), null);
        showToast('Watermark removed', 'success');
      };

      const exportPDF = () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
        const pageW = doc.internal.pageSize.getWidth(); // 612pt
        const pageH = doc.internal.pageSize.getHeight(); // 792pt
        const margin = 18;
        const contentWidth = pageW - (margin * 2);

        const HEADER_SIZE = 20;
        const BODY_SIZE = 18;
        const SMALL_SIZE = 10;
        const LINE_HEIGHT = 20;

        const addWatermark = () => {
          if (!watermarkImg) return;
          doc.saveGraphicsState();
          doc.setGState(new doc.GState({ opacity: 0.12 }));
          try {
            doc.addImage(watermarkImg, 'AUTO', 0, 0, pageW, pageH);
          } catch (err) {
            console.warn('Watermark image error:', err);
          }
          doc.restoreGraphicsState();
        };

        const drawSetHeader = (set, yPos, setIdx) => {
          const heading = set.name.toUpperCase();

          doc.setFont('helvetica', 'bold');
          doc.setFontSize(HEADER_SIZE);
          doc.setTextColor(0, 0, 0);
          doc.text(heading, margin, yPos);

          const headingWidth = doc.getTextWidth(heading);
          doc.setLineWidth(1.5);
          doc.line(margin, yPos + 3, margin + headingWidth, yPos + 3);

          yPos += HEADER_SIZE + 6;
          doc.setFontSize(BODY_SIZE - 4);
          const setInfo = `${set.songs.length} songs  |  ${Math.round(set.totalTime)} minutes`;
          doc.text(setInfo, margin, yPos);

          // Quality score badge if available
          const qScores = setlists.qualityScores;
          if (qScores && qScores[setIdx]) {
            const q = qScores[setIdx];
            const scoreText = `Quality: ${q.overall}/100  (E:${q.energy} T:${q.tonal} D:${q.diversity} Dur:${q.duration})`;
            const scoreX = margin + doc.getTextWidth(setInfo) + 15;
            doc.setFontSize(SMALL_SIZE);
            doc.setTextColor(q.overall >= 75 ? 0 : q.overall >= 50 ? 120 : 180, q.overall >= 75 ? 128 : q.overall >= 50 ? 100 : 0, 0);
            doc.text(scoreText, scoreX, yPos);
            doc.setTextColor(0, 0, 0);
          }

          yPos += HEADER_SIZE + 2;

          // Draw column headers
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(SMALL_SIZE);
          doc.setTextColor(100, 100, 100);
          doc.text('#', margin, yPos);
          doc.text('TITLE / ARTIST', margin + 24, yPos);
          doc.text('KEY', contentWidth - 120 + margin, yPos);
          doc.text('BPM', contentWidth - 70 + margin, yPos);
          doc.text('STYLE', contentWidth - 30 + margin, yPos);
          doc.setTextColor(0, 0, 0);
          doc.setLineWidth(0.5);
          doc.line(margin, yPos + 4, margin + contentWidth, yPos + 4);

          return yPos + LINE_HEIGHT - 2;
        };

        const formatSongLine = (song, idx) => {
          const parts = [`${idx + 1}. ${song.title}`];
          if (song.artist) parts.push(` - ${song.artist}`);
          return parts.join('');
        };

        setlists.forEach((set, setIdx) => {
          if (setIdx > 0) doc.addPage();
          addWatermark();

          let yPos = drawSetHeader(set, margin + HEADER_SIZE, setIdx);

          set.songs.forEach((song, songIdx) => {
            const mainText = formatSongLine(song, songIdx);
            const mainLines = doc.splitTextToSize(mainText, contentWidth - 150);
            const itemHeight = mainLines.length * LINE_HEIGHT;

            if (yPos + itemHeight > pageH - margin - 30) {
              doc.addPage();
              addWatermark();
              yPos = margin + HEADER_SIZE;
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(BODY_SIZE);
            }

            // Song title and artist
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(BODY_SIZE);
            doc.setTextColor(0, 0, 0);
            mainLines.forEach((line) => {
              doc.text(line, margin, yPos);
              yPos += LINE_HEIGHT;
            });

            // Key, BPM, Style on the right side (aligned with the first line)
            const metaY = yPos - (mainLines.length * LINE_HEIGHT) + LINE_HEIGHT - 2;
            doc.setFontSize(SMALL_SIZE + 1);
            doc.setTextColor(60, 60, 60);
            if (song.key) doc.text(song.key, contentWidth - 120 + margin, metaY);
            if (song.bpm) doc.text(String(song.bpm), contentWidth - 70 + margin, metaY);
            if (song.style) {
              doc.setFontSize(SMALL_SIZE);
              doc.text(song.style, contentWidth - 30 + margin, metaY);
            }
            doc.setTextColor(0, 0, 0);

            yPos += 2;
          });

          // Footer with tonal diagnostics
          if (setlists.diagnostics && setlists.diagnostics[setIdx]) {
            const diag = setlists.diagnostics[setIdx];
            if (yPos + 30 > pageH - margin) {
              doc.addPage();
              addWatermark();
              yPos = margin + HEADER_SIZE;
            }
            doc.setLineWidth(0.5);
            doc.line(margin, yPos + 4, margin + contentWidth, yPos + 4);
            yPos += 14;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(SMALL_SIZE);
            doc.setTextColor(80, 80, 80);
            const tonalInfo = `Tonal Flow: ${diag.qualityScore} (avg circle distance: ${diag.avgCircleDistance})`;
            doc.text(tonalInfo, margin, yPos);
            if (diag.contrastJumps && diag.contrastJumps.length > 0) {
              yPos += 12;
              const jumpsText = `Key jumps: ${diag.contrastJumps.map(j => `#${j.position} ${j.from}->${j.to} (${j.distance})`).join(', ')}`;
              doc.text(jumpsText, margin, yPos);
            }
            doc.setTextColor(0, 0, 0);
          }
        });

        // Add summary page
        if (setlists.length > 0) {
          doc.addPage();
          addWatermark();
          let yPos = margin + HEADER_SIZE;

          doc.setFont('helvetica', 'bold');
          doc.setFontSize(HEADER_SIZE);
          doc.text('SETLIST SUMMARY', margin, yPos);
          doc.setLineWidth(1.5);
          doc.line(margin, yPos + 3, margin + doc.getTextWidth('SETLIST SUMMARY'), yPos + 3);
          yPos += HEADER_SIZE + 10;

          doc.setFontSize(12);
          doc.text(`Band: ${activeBand?.name || 'Unknown'}`, margin, yPos);
          yPos += 18;
          doc.text(`Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, margin, yPos);
          yPos += 18;
          doc.text(`Total Sets: ${setlists.length}`, margin, yPos);
          yPos += 18;
          const totalSongs = setlists.reduce((s, set) => s + set.songs.length, 0);
          const totalTime = setlists.reduce((s, set) => s + set.totalTime, 0);
          doc.text(`Total Songs: ${totalSongs}  |  Total Time: ${Math.round(totalTime)} minutes`, margin, yPos);
          yPos += 30;

          // Per-set quality breakdown
          const qScores = setlists.qualityScores;
          if (qScores && qScores.length > 0) {
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(14);
            doc.text('Quality Scores', margin, yPos);
            yPos += 20;

            doc.setFont('helvetica', 'normal');
            doc.setFontSize(11);
            qScores.forEach((q, qi) => {
              doc.text(`Set ${qi + 1}: Overall ${q.overall}/100  |  Energy: ${q.energy}  |  Tonal: ${q.tonal}  |  Diversity: ${q.diversity}  |  Duration: ${q.duration}`, margin, yPos);
              yPos += 16;
            });
          }

          // Anchor key info
          if (setlists.anchorKey) {
            yPos += 10;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(11);
            doc.text(`Anchor Key: ${setlists.anchorKey}`, margin, yPos);
          }
        }

        const safeBandName = (activeBand?.name || 'band').replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        doc.save(`setlist-${safeBandName}-${new Date().toISOString().slice(0, 10)}.pdf`);
      };

      const toggleLock = (setIdx, songId) => {
        const key = `${setIdx}:${songId}`;
        const newLocked = new Set(locked);
        if (newLocked.has(key)) newLocked.delete(key);
        else newLocked.add(key);
        setLocked(newLocked);
      };

      // PHASE 2: Swap with closest-duration fallback
      const swapSong = (setIdx, songIdx) => {
        const set = setlists[setIdx];
        if (!set) return;

        const songToReplace = set.songs[songIdx];
        if (locked.has(`${setIdx}:${songToReplace.id}`)) return showToast('Cannot swap locked song', 'warning');

        // PHASE 3A: candidates should come from ACTIVE songs only
        const candidatePool = activeSongs;

        const globalUsedSongKeys = new Set();
        setlists.forEach((s, i) => {
          if (i !== setIdx || !settings.allowSongReuse) {
            s.songs.forEach(song => {
              globalUsedSongKeys.add(`id:${song.id}`);
              if (song.title && song.artist) {
                globalUsedSongKeys.add(`ta:${song.title.toLowerCase().trim()}|${song.artist.toLowerCase().trim()}`);
              }
            });
          }
        });

        const getSongDedupKeys = (s) => {
          const k = [];
          if (s.id) k.push(`id:${s.id}`);
          if (s.title && s.artist) k.push(`ta:${s.title.toLowerCase().trim()}|${s.artist.toLowerCase().trim()}`);
          return k;
        };

        let candidates = candidatePool.filter(s =>
          s.id !== songToReplace.id &&
          !set.songs.some(x => x.id === s.id) &&
          (settings.allowSongReuse ? true : !getSongDedupKeys(s).some(key => globalUsedSongKeys.has(key)))
        );

        candidates = candidates
          .map(s => ({ s, diff: Math.abs((Number(parseDuration(s.duration)) || 0) - (Number(parseDuration(songToReplace.duration)) || 0)) }))
          .sort((a, b) => a.diff - b.diff)
          .slice(0, 20)
          .map(x => x.s);

        const pick = candidates.length ? candidates[Math.floor(Math.random() * Math.min(6, candidates.length))] : null;
        if (!pick) return showToast('No suitable replacement', 'warning');

        const newSetlists = [...setlists];
        const newSongsArr = set.songs.map((s, i) => i === songIdx ? pick : s);
        newSetlists[setIdx] = {
          ...set,
          songs: newSongsArr,
          totalTime: newSongsArr.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0)
        };
        setSetlists(newSetlists);
        showToast('Song swapped', 'success');
      };

      const moveSong = (setIdx, fromIdx, toIdx) => {
        const set = setlists[setIdx];
        if (!set || toIdx < 0 || toIdx >= set.songs.length) return;

        const newSongs = [...set.songs];
        const [moved] = newSongs.splice(fromIdx, 1);
        newSongs.splice(toIdx, 0, moved);

        const newSetlists = [...setlists];
        newSetlists[setIdx] = { ...set, songs: newSongs };
        setSetlists(newSetlists);
      };

      // Remove song from setlist and send to Cold List
      const removeSongFromSetlist = (setIdx, songIdx) => {
        const set = setlists[setIdx];
        if (!set) return;

        const song = set.songs[songIdx];
        if (!song) return;

        // Remove from setlist
        const newSongs = set.songs.filter((_, i) => i !== songIdx);
        const newSetlists = [...setlists];
        newSetlists[setIdx] = {
          ...set,
          songs: newSongs,
          totalTime: newSongs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0)
        };
        setSetlists(newSetlists);

        // Remove any lock for this song
        const lockKey = `${setIdx}:${song.id}`;
        if (locked.has(lockKey)) {
          const newLocked = new Set(locked);
          newLocked.delete(lockKey);
          setLocked(newLocked);
        }

        // Move song to cold list
        setSongs(prev => prev.map(s => s.id === song.id ? { ...s, status: 'cold' } : s));
        showToast(`"${song.title}" removed and shelved to Cold List`, 'success');
      };

      // Lock or unlock all songs in a set
      const lockEntireSet = (setIdx, lock) => {
        const set = setlists[setIdx];
        if (!set) return;

        const newLocked = new Set(locked);
        set.songs.forEach(song => {
          const key = `${setIdx}:${song.id}`;
          if (lock) newLocked.add(key);
          else newLocked.delete(key);
        });
        setLocked(newLocked);
        showToast(lock ? 'Set locked' : 'Set unlocked', 'success');
      };

      // --- Cross-Set Drag-and-Drop Handlers ---
      // Ref to throttle dragover state updates (prevents excessive re-renders that cause "stuck" feeling)
      const dragOverRef = React.useRef({ setIdx: null, songIdx: null });

      const handleDragStart = (e, song, setIdx, songIdx) => {
        if (locked.has(`${setIdx}:${song.id}`)) { e.preventDefault(); return; }
        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }
        // Set effectAllowed BEFORE setData for cross-browser compat (Firefox requires this order)
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain', song.title); } catch (_) {}
        // Some browsers (Safari) need a brief delay before visual state updates during drag
        requestAnimationFrame(() => {
          setDragState({ active: true, song, fromSetIdx: setIdx, fromSongIdx: songIdx, overSetIdx: null, overSongIdx: null });
        });
      };

      const handleDragEnd = () => {
        dragOverRef.current = { setIdx: null, songIdx: null };
        setDragState(defaultDragState);
        // Let React handle class removal via the dragState reset â€” no imperative DOM cleanup needed.
      };

      const handleDragOverSong = (e, setIdx, songIdx) => {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'move';
        // Throttle: only update React state if the target actually changed
        if (dragOverRef.current.setIdx === setIdx && dragOverRef.current.songIdx === songIdx) return;
        dragOverRef.current = { setIdx, songIdx };
        setDragState(prev => {
          if (prev.overSetIdx === setIdx && prev.overSongIdx === songIdx) return prev;
          return { ...prev, overSetIdx: setIdx, overSongIdx: songIdx };
        });
      };

      const handleDragOverSet = (e, setIdx) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        setDragState(prev => {
          if (prev.overSetIdx === setIdx && prev.overSongIdx === null) return prev;
          return { ...prev, overSetIdx: setIdx, overSongIdx: null };
        });
      };

      const reorderSongWithinSet = (setIdx, fromIdx, toIdx) => {
        const set = setlists[setIdx];
        if (!set || fromIdx === toIdx) return;
        const newSongs = [...set.songs];
        const [moved] = newSongs.splice(fromIdx, 1);
        newSongs.splice(toIdx, 0, moved);
        const newSetlists = [...setlists];
        newSetlists[setIdx] = { ...set, songs: newSongs, totalTime: newSongs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0) };
        setSetlists(newSetlists);
      };

      const moveSongBetweenSets = (fromSetIdx, toSetIdx, fromSongIdx, toSongIdx) => {
        const newSetlists = JSON.parse(JSON.stringify(setlists));
        const fromSet = newSetlists[fromSetIdx];
        const toSet = newSetlists[toSetIdx];
        if (!fromSet || !toSet) return;

        const [movedSong] = fromSet.songs.splice(fromSongIdx, 1);
        const insertIdx = (toSongIdx !== null && toSongIdx !== undefined) ? Math.min(toSongIdx, toSet.songs.length) : toSet.songs.length;
        toSet.songs.splice(insertIdx, 0, movedSong);

        fromSet.totalTime = fromSet.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);
        toSet.totalTime = toSet.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);

        // Migrate lock from source set to destination set
        const oldKey = `${fromSetIdx}:${movedSong.id}`;
        if (locked.has(oldKey)) {
          const newLocked = new Set(locked);
          newLocked.delete(oldKey);
          newLocked.add(`${toSetIdx}:${movedSong.id}`);
          setLocked(newLocked);
        }

        setSetlists(newSetlists);
        showToast(`Moved "${movedSong.title}" to ${toSet.name}`, 'success');
      };

      const handleDropOnSong = (e, toSetIdx, toSongIdx) => {
        e.preventDefault();
        e.stopPropagation();
        if (!dragState.active) return;
        const { fromSetIdx, fromSongIdx } = dragState;
        if (fromSetIdx === toSetIdx) {
          reorderSongWithinSet(toSetIdx, fromSongIdx, toSongIdx);
        } else {
          moveSongBetweenSets(fromSetIdx, toSetIdx, fromSongIdx, toSongIdx);
        }
        handleDragEnd();
      };

      const handleDropOnSet = (e, toSetIdx) => {
        e.preventDefault();
        if (!dragState.active) return;
        const { fromSetIdx, fromSongIdx } = dragState;
        if (fromSetIdx !== toSetIdx) {
          moveSongBetweenSets(fromSetIdx, toSetIdx, fromSongIdx, null);
        }
        handleDragEnd();
      };

      const handleDropToRemove = (e) => {
        e.preventDefault();
        if (!dragState.active) return;
        const { fromSetIdx, fromSongIdx } = dragState;
        removeSongFromSetlist(fromSetIdx, fromSongIdx);
        handleDragEnd();
      };

      const moveToSetDropdown = (fromSetIdx, songIdx, toSetIdx) => {
        if (fromSetIdx === toSetIdx) return;
        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }
        moveSongBetweenSets(fromSetIdx, toSetIdx, songIdx, null);
      };

      const resetToOriginal = () => {
        if (!originalSetlists) return;
        setSetlists(originalSetlists);
        setLocked(new Set());
        setOriginalSetlists(null);
        showToast('Order reset to original', 'success');
      };

      const [swapFrom, setSwapFrom] = useState(null);

      const swapSets = (idxA, idxB) => {
        if (idxA === idxB || idxA == null || idxB == null) return;
        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }
        const newSetlists = [...setlists];
        // Swap the two sets
        [newSetlists[idxA], newSetlists[idxB]] = [newSetlists[idxB], newSetlists[idxA]];
        // Rename sets to reflect positions and remap locks
        const newLocked = new Set();
        locked.forEach(key => {
          const [setIdxStr, songId] = key.split(':');
          const oldIdx = Number(setIdxStr);
          let newIdx = oldIdx;
          if (oldIdx === idxA) newIdx = idxB;
          else if (oldIdx === idxB) newIdx = idxA;
          newLocked.add(`${newIdx}:${songId}`);
        });
        const renamedSetlists = newSetlists.map((set, i) => ({ ...set, name: `Set ${i + 1}` }));
        setSetlists(renamedSetlists);
        setLocked(newLocked);
        setSwapFrom(null);
        showToast(`Swapped Set ${idxA + 1} with Set ${idxB + 1}`, 'success');
      };

      const balanceSets = () => {
        if (setlists.length < 2) return;
        const allSongs = setlists.flatMap(s => s.songs);
        const sorted = [...allSongs].sort((a, b) => (Number(parseDuration(b.duration)) || 0) - (Number(parseDuration(a.duration)) || 0));
        const buckets = setlists.map(() => []);
        const totals = setlists.map(() => 0);

        sorted.forEach(song => {
          let minIdx = 0;
          for (let i = 1; i < totals.length; i++) {
            if (totals[i] < totals[minIdx]) minIdx = i;
          }
          buckets[minIdx].push(song);
          totals[minIdx] += Number(parseDuration(song.duration)) || 0;
        });

        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }

        const newSetlists = setlists.map((set, i) => ({
          ...set,
          songs: buckets[i],
          totalTime: totals[i]
        }));
        setSetlists(newSetlists);
        setLocked(new Set());

        const times = totals.map(t => Math.round(t));
        const spread = Math.max(...times) - Math.min(...times);
        showToast(`Sets balanced (spread: ${spread} min)`, 'success');
      };

      const switchBand = (bandId) => {
        setActiveBandId(bandId);
        LS.set(LS_KEYS.active, bandId);
      };

      const createBand = (form) => {
        const newBand = { id: genId(), ...form };
        setBands([...bands, newBand]);
        setActiveBandId(newBand.id);
        LS.set(LS_KEYS.active, newBand.id);
        showToast('Band created', 'success');
      };

      // Band deletion cleanup
      const deleteBand = (band) => {
        if (bands.length === 1) return showToast('Cannot delete the last band', 'error');
        if (!window.confirm(`Delete "${band.name}"? This cannot be undone.`)) return;

        const next = bands.filter(b => b.id !== band.id);
        setBands(next);

        LS.remove(LS_KEYS.bandSongs(band.id));
        LS.remove(LS_KEYS.bandSettings(band.id));
        LS.remove(LS_KEYS.bandHistory(band.id));
        LS.remove(LS_KEYS.bandImports(band.id));
        LS.remove(LS_KEYS.bandGigs(band.id));

        if (activeBandId === band.id && next.length) {
          setActiveBandId(next[0].id);
          LS.set(LS_KEYS.active, next[0].id);
        }

        showToast('Band deleted', 'warning');
      };

      const duplicateBand = (band) => {
        const newBand = {
          id: genId(),
          name: `${band.name} (Copy)`,
          icon: band.icon,
          color: band.color
        };
        setBands([...bands, newBand]);
        // Copy songs, settings, gigs, and imports from source band to new band
        const srcSongs = LS.get(LS_KEYS.bandSongs(band.id));
        const srcSettings = LS.get(LS_KEYS.bandSettings(band.id));
        const srcGigs = LS.get(LS_KEYS.bandGigs(band.id));
        const srcImports = LS.get(LS_KEYS.bandImports(band.id));
        const srcWatermark = LS.get(LS_KEYS.bandWatermark(band.id));
        if (srcSongs) {
          // Assign new IDs to duplicated songs to avoid cross-band ID collisions
          const newSongs = srcSongs.map(s => ({ ...s, id: genId() }));
          LS.set(LS_KEYS.bandSongs(newBand.id), newSongs);
        }
        if (srcSettings) LS.set(LS_KEYS.bandSettings(newBand.id), srcSettings);
        if (srcGigs) LS.set(LS_KEYS.bandGigs(newBand.id), srcGigs);
        if (srcImports) LS.set(LS_KEYS.bandImports(newBand.id), srcImports);
        if (srcWatermark) LS.set(LS_KEYS.bandWatermark(newBand.id), srcWatermark);
        showToast('Band duplicated with songs & settings', 'success');
      };

      // Gig Profile functions
      const createGig = (form) => {
        // Store all venue/gig fields from the form
        const newGig = {
          id: genId(),
          name: form.name,
          venue: form.venue || '',
          date: form.date || '',
          notes: form.notes || '',
          venueCity: form.venueCity || '',
          venueState: form.venueState || '',
          venueZip: form.venueZip || '',
          venueType: form.venueType || '',
          venueCapacity: form.venueCapacity || '',
          contactName: form.contactName || '',
          contactEmail: form.contactEmail || '',
          contactPhone: form.contactPhone || '',
          loadInTime: form.loadInTime || '',
          soundCheckTime: form.soundCheckTime || '',
          setStartTime: form.setStartTime || '',
          compensation: form.compensation || '',
          eventType: form.eventType || '',
          ageRestriction: form.ageRestriction || '',
          backlineProvided: !!form.backlineProvided,
          paProvided: !!form.paProvided,
          setlists: null,
          createdAt: Date.now()
        };
        const updated = [...gigs, newGig];
        setGigs(updated);
        LS.set(LS_KEYS.bandGigs(activeBandId), updated);
        showToast('Gig profile created', 'success');
      };

      const deleteGig = (gigId) => {
        if (!window.confirm('Delete this gig profile?')) return;
        const updated = gigs.filter(g => g.id !== gigId);
        setGigs(updated);
        LS.set(LS_KEYS.bandGigs(activeBandId), updated);
        showToast('Gig profile deleted', 'warning');
      };

      const saveSetlistsToGig = (gigId) => {
        if (!setlists.length) return;
        const updated = gigs.map(g =>
          g.id === gigId ? { ...g, setlists: JSON.parse(JSON.stringify(setlists)), savedAt: Date.now() } : g
        );
        setGigs(updated);
        LS.set(LS_KEYS.bandGigs(activeBandId), updated);
        showToast('Setlists saved to gig profile', 'success');
      };

      const exportGigCSV = (gigId) => {
        const gig = gigs.find(g => g.id === gigId);
        if (!gig || !gig.setlists || gig.setlists.length === 0) return showToast('No setlists saved for this gig', 'warning');

        const headers = ['Set', 'Order', 'Title', 'Artist', 'Duration', 'Style', 'Key', 'BPM', 'Vocalist', 'Energy'];
        const rows = [];
        gig.setlists.forEach((set, setIdx) => {
          set.songs.forEach((song, songIdx) => {
            const energy = getCompositeEnergy(song);
            rows.push([
              csvEscapeCell(set.name || `Set ${setIdx + 1}`),
              csvEscapeCell(songIdx + 1),
              csvEscapeCell(song.title),
              csvEscapeCell(song.artist),
              csvEscapeCell(parseDuration(song.duration)),
              csvEscapeCell(song.style || ''),
              csvEscapeCell(song.key || ''),
              csvEscapeCell(song.bpm || ''),
              csvEscapeCell(song.vocalist || ''),
              csvEscapeCell(Math.round(energy * 10) / 10)
            ]);
          });
        });

        // Add gig metadata as footer rows
        rows.push([]);
        rows.push([csvEscapeCell('Gig Info')]);
        rows.push([csvEscapeCell('Gig Name'), csvEscapeCell(gig.name || '')]);
        rows.push([csvEscapeCell('Venue'), csvEscapeCell(gig.venue || '')]);
        rows.push([csvEscapeCell('Date'), csvEscapeCell(gig.date || '')]);
        if (gig.venueCity) rows.push([csvEscapeCell('City'), csvEscapeCell(gig.venueCity)]);
        if (gig.venueState) rows.push([csvEscapeCell('State'), csvEscapeCell(gig.venueState)]);
        if (gig.eventType) rows.push([csvEscapeCell('Event Type'), csvEscapeCell(gig.eventType.replace(/_/g, ' '))]);
        if (gig.contactName) rows.push([csvEscapeCell('Contact'), csvEscapeCell(gig.contactName)]);
        if (gig.contactEmail) rows.push([csvEscapeCell('Email'), csvEscapeCell(gig.contactEmail)]);
        if (gig.notes) rows.push([csvEscapeCell('Notes'), csvEscapeCell(gig.notes)]);

        const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const safeName = (gig.name || 'gig').replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        const dateStr = gig.date || new Date().toISOString().slice(0, 10);
        a.download = `setlist-${safeName}-${dateStr}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
        showToast('Gig setlist exported as CSV', 'success');
      };

      const loadSetlistsFromGig = (gigId) => {
        const gig = gigs.find(g => g.id === gigId);
        if (!gig || !gig.setlists) return showToast('No saved setlists for this gig', 'warning');
        setSetlists(gig.setlists);
        setLocked(new Set());
        setOriginalSetlists(null);
        setLastGenerationStats(null);
        showToast(`Loaded setlists from "${gig.name}"`, 'success');
        setGigModal(false);
      };

      return (
        <>
          <div className="app-container no-print">
            {toast && (
              <div className="toast-container">
                <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />
              </div>
            )}

            <header className="header">
              <h1>SETLIST GENERATOR</h1>
              <div className="subtitle">v3.7.0 â€” SA Optimizer â€¢ Continuous Energy Curves â€¢ Tonal Gravity v2 â€¢ Templates</div>
            </header>

            <div className="band-bar">
              <div className="band-left">
                <div className="band-pill">
                  <span style={{ fontSize: '1.2rem' }}>{activeBand?.icon || 'ðŸŽµ'}</span>
                  <strong>{activeBand?.name || 'No Band'}</strong>
                  <span className="swatch" style={{ background: activeBand?.color || '#ff6b35' }}></span>
                </div>
                <button className="btn btn-small" onClick={() => setBandModal(true)}>Manage Bands</button>
                <button className="btn btn-small" onClick={() => setGigModal(true)} style={{ borderColor: 'var(--accent)', color: 'var(--accent)' }}>Gig Profiles</button>
              </div>
              <div className="toolbar">
                <select value={activeBandId || ''} onChange={(e) => switchBand(e.target.value)}>
                  {bands.map(b => <option key={b.id} value={b.id}>{b.icon || 'ðŸŽµ'} {b.name}</option>)}
                </select>
              </div>
            </div>

            <div className="main-grid">
              <SongLibrary
                songs={songs}
                activeCount={activeSongs.length}
                coldCount={coldSongs.length}
                libraryTab={libraryTab}
                onSetLibraryTab={setLibraryTab}
                onAddSong={addSong}
                onDeleteSong={deleteSong}
                onShelfSong={shelfSong}
                onRestoreSong={restoreSong}
                onExportCSV={exportSongs}
                onImportCSVRobust={importCSVRobust}
                onOpenImportModal={() => setImportModal(true)}
                onDownloadSampleCSV={downloadSampleCSV}
                onClearAll={clearAllSongs}
                latestImport={imports[0] || null}
              />

              <SetConfiguration
                settings={settings}
                onChange={setSettings}
                onGenerate={generate}
                onCopy={copyToClipboard}
                onExportPDF={exportPDF}
                songCount={activeSongs.length}
                libraryTime={activeLibraryTime}
                watermarkImg={watermarkImg}
                onWatermarkUpload={handleWatermarkUpload}
                onClearWatermark={clearWatermark}
                activeSongs={activeSongs}
              />
            </div>

            {setlists.length === 0 ? (
              <div className="panel" style={{ marginTop: '1rem' }}>
                <div className="alert alert-warning">
                  No setlists yet. Configure your settings and click <strong>Generate Setlists</strong>.
                  <div style={{ marginTop: '.4rem', color: 'var(--text-muted)', fontSize: '.85rem' }}>
                    Note: Generator uses <strong>Active</strong> songs only (Cold List excluded).
                  </div>
                </div>
              </div>
            ) : (
              <>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '1rem' }}>
                  <h3 className="panel-title">Generated Setlists</h3>
                  <div className="toolbar">
                    <div className="reset-balance-bar">
                      {originalSetlists && (
                        <button className="btn btn-small" onClick={resetToOriginal} title="Reset to original generated order">&#8617; Reset Order</button>
                      )}
                      {setlists.length > 1 && (
                        <>
                          <div style={{ display: 'flex', gap: '.3rem', alignItems: 'center' }}>
                            <select
                              className="move-to-set-select"
                              value={swapFrom != null ? swapFrom : ''}
                              onChange={(e) => setSwapFrom(e.target.value !== '' ? Number(e.target.value) : null)}
                              title="Select first set to swap"
                              style={{ minWidth: '60px' }}
                            >
                              <option value="" disabled>Swap...</option>
                              {setlists.map((_, i) => (
                                <option key={i} value={i}>Set {i + 1}</option>
                              ))}
                            </select>
                            {swapFrom != null && (
                              <>
                                <span style={{ color: 'var(--text-muted)', fontSize: '.8rem' }}>&#8645;</span>
                                <select
                                  className="move-to-set-select"
                                  value=""
                                  onChange={(e) => { if (e.target.value !== '') swapSets(swapFrom, Number(e.target.value)); }}
                                  title="Select second set to swap with"
                                  style={{ minWidth: '60px' }}
                                >
                                  <option value="" disabled>With...</option>
                                  {setlists.map((_, i) => i).filter(i => i !== swapFrom).map(i => (
                                    <option key={i} value={i}>Set {i + 1}</option>
                                  ))}
                                </select>
                              </>
                            )}
                          </div>
                          <button className="btn btn-small" onClick={balanceSets} title="Evenly redistribute songs across sets">&#9878; Balance Sets</button>
                        </>
                      )}
                    </div>
                    <button
                      className={`btn btn-small ${isReorderMode ? 'btn-toggle-active' : ''}`}
                      onClick={() => setIsReorderMode(!isReorderMode)}
                      title={isReorderMode ? 'Exit reorder mode' : 'Enable drag-and-drop reordering'}
                    >
                      {isReorderMode ? 'Done Reordering' : '\u{1F504} Reorder'}
                    </button>
                    <button className="btn btn-small" onClick={generate}>Regenerate</button>
                    <button className="btn btn-small" onClick={() => { setSetlists([]); setLocked(new Set()); setOriginalSetlists(null); setLastGenerationStats(null); setIsReorderMode(false); setSwapFrom(null); }}>Clear</button>
                  </div>
                </div>

                {lastGenerationStats && (
                  <div className="generation-stats">
                    <strong>{lastGenerationStats.songsUsed}</strong> songs used â€¢
                    <strong> {lastGenerationStats.attempts}</strong> selection attempts
                    {setlists.qualityScores && setlists.qualityScores.length > 0 && (
                      <span>
                        {' '} â€¢ Quality: {setlists.qualityScores.map((q, qi) => (
                          <span key={qi} title={`Energy: ${q.energy} | Tonal: ${q.tonal} | Diversity: ${q.diversity} | Duration: ${q.duration}`}
                            style={{ color: q.overall >= 75 ? 'var(--success)' : q.overall >= 50 ? 'var(--warning)' : 'var(--error)', fontWeight: 600, cursor: 'help' }}>
                            {qi > 0 ? ' | ' : ''}Set {qi + 1}: <strong>{q.overall}</strong>/100
                          </span>
                        ))}
                      </span>
                    )}
                  </div>
                )}

                <div className="setlists-container">
                  {setlists.map((set, i) => (
                    <SetlistView
                      key={set.id}
                      setIdx={i}
                      setlist={set}
                      locked={locked}
                      setLocked={setLocked}
                      onToggleLock={toggleLock}
                      onSwap={swapSong}
                      onMoveSong={moveSong}
                      onRemoveSong={removeSongFromSetlist}
                      onLockEntireSet={lockEntireSet}
                      onDragStart={handleDragStart}
                      onDragEnd={handleDragEnd}
                      onDragOverSong={handleDragOverSong}
                      onDragOverSet={handleDragOverSet}
                      onDropOnSong={handleDropOnSong}
                      onDropOnSet={handleDropOnSet}
                      onMoveToSet={moveToSetDropdown}
                      dragState={dragState}
                      totalSets={setlists.length}
                      isReorderMode={isReorderMode}
                    />
                  ))}
                </div>
              </>
            )}

            <BandModal
              open={bandModal}
              onClose={() => setBandModal(false)}
              bands={bands}
              onCreate={createBand}
              onDelete={deleteBand}
              onDuplicate={duplicateBand}
            />

            <ImportSongsModal
              open={importModal}
              onClose={() => setImportModal(false)}
              onImport={importCanonicalRows}
              existingSongs={songs}
            />

            <GigProfileModal
              open={gigModal}
              onClose={() => setGigModal(false)}
              gigs={gigs}
              onCreateGig={createGig}
              onDeleteGig={deleteGig}
              onLoadGig={loadSetlistsFromGig}
              onSaveToGig={saveSetlistsToGig}
              onExportGigCSV={exportGigCSV}
              setlists={setlists}
              bandName={activeBand?.name || 'Band'}
            />
          </div>

          {dragState.active && (
            <div
              className="optimized-removal-zone"
              onDragOver={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }}
              onDrop={handleDropToRemove}
            >
              Drop Here to Remove Song
            </div>
          )}

          <PrintView setlists={setlists} watermarkImg={watermarkImg} />
        </>
      );
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ErrorBoundary><App /></ErrorBoundary>);
  </script>
</body>
</html>
