<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Setlist Generator v3.6.0 — Phase 5: Locked Openers/Closers, Venue Integration, PDF Enhancements</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>

  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Manrope:wght@400;500;600;700&family=Oswald:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --primary: #1a1a1a;
      --secondary: #2d2d2d;
      --accent: #ff6b35;
      --accent-dark: #e85a28;
      --text: #ffffff;
      --text-muted: #9aa0a6;
      --border: #404040;
      --success: #4ade80;
      --warning: #fbbf24;
      --error: #ef4444;
      --ballad: #60a5fa;
      --uptempo: #f87171;
      --midtempo: #fbbf24;
      --funk: #a78bfa;
      --shuffle: #34d399;
      --swing: #fb923c;
      --groove: #ec4899;
      --locked: #4ade80;
      --toast-bg: rgba(45,45,45,.95);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Manrope', system-ui, -apple-system, Arial, sans-serif;
      background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
      color: var(--text);
      min-height: 100vh; overflow-x: hidden;
    }
    .app-container { max-width: 1600px; margin: 0 auto; padding: 1.25rem; }
    header.header { text-align: center; margin: 1rem 0 2rem; position: relative; }
    header.header::before {
      content: ''; position: absolute; top: -16px; left: 50%; transform: translateX(-50%);
      width: 100px; height: 4px; background: linear-gradient(90deg, var(--accent), var(--accent-dark)); border-radius: 2px;
    }
    h1 {
      font-family: 'Space Mono', monospace; font-size: 2.2rem; font-weight: 700; letter-spacing: -0.02em; margin-bottom: .25rem;
      background: linear-gradient(135deg, var(--text) 0%, var(--text-muted) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .subtitle { color: var(--text-muted); font-size: .95rem; letter-spacing: .08em; text-transform: uppercase; }
    .band-bar {
      background: var(--secondary); border: 1px solid var(--border); border-radius: 10px;
      padding: .75rem 1rem; margin: 0 0 1rem; display: flex; gap: .75rem; align-items: center; justify-content: space-between;
    }
    .band-left { display: flex; align-items: center; gap: .75rem; }
    .band-pill {
      display: inline-flex; gap: .5rem; align-items: center; background: var(--primary);
      border: 1px solid var(--border); border-radius: 999px; padding: .4rem .75rem; font-size: .9rem;
    }
    .band-pill .swatch { width: 12px; height: 12px; border-radius: 999px; border: 1px solid var(--border); }
    .btn {
      padding: .65rem 1rem; border: 1px solid var(--border); border-radius: 8px; background: var(--primary); color: var(--text);
      font-weight: 600; font-size: .85rem; letter-spacing: .04em; cursor: pointer; transition: .2s ease;
    }
    .btn:hover { border-color: var(--accent); }
    .btn:disabled { opacity: .55; cursor: not-allowed; }
    .btn-primary { background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%); border-color: transparent; }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.35); }
    .btn-small { padding: .45rem .75rem; font-size: .75rem; }
    .btn-toggle-active { border-color: var(--accent); color: var(--text); }
    .btn-toggle-active.btn-primary { box-shadow: 0 4px 12px rgba(255, 107, 53, 0.35); }

    .main-grid { display: grid; grid-template-columns: 420px 1fr; gap: 1rem; }
    .panel {
      background: var(--secondary); border: 1px solid var(--border); border-radius: 12px; padding: 1rem;
      box-shadow: 0 6px 24px rgba(0,0,0,.35);
    }
    .panel-header { display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border);
      padding-bottom: .6rem; margin-bottom: 1rem; }
    .panel-title { font-family: 'Space Mono', monospace; color: var(--accent); font-weight: 700; }

    label { display:block; margin-bottom: .35rem; font-size: .8rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .05em; }
    input, select, textarea {
      width: 100%; padding: .65rem .75rem; background: var(--primary); border: 1px solid var(--border); border-radius: 8px;
      color: var(--text); font-size: .9rem;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(255,107,53,.12); }
    .input-group { margin-bottom: .8rem; }
    .set-config { display:grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
    .toolbar { display:flex; gap:.6rem; flex-wrap: wrap; align-items:center; }

    .song-list { max-height: 420px; overflow:auto; }
    .song-item {
      background: var(--primary); border: 1px solid var(--border); border-radius: 8px; padding: .75rem;
      display:flex; align-items:center; justify-content: space-between; margin-bottom:.6rem;
    }
    .song-title { font-weight:700; margin-bottom: .2rem; }
    .song-meta { font-size: .8rem; color: var(--text-muted); display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .song-badge { padding: .15rem .4rem; border-radius: 4px; font-size: .7rem; font-weight:700; text-transform: uppercase; letter-spacing: .04em; }
    .style-ballad{background:var(--ballad); color:#111;} .style-uptempo{background:var(--uptempo); color:#111;}
    .style-midtempo{background:var(--midtempo); color:#111;} .style-funk{background:var(--funk); color:#111;}
    .style-shuffle{background:var(--shuffle); color:#111;} .style-swing{background:var(--swing); color:#111;}
    .style-groove{background:var(--groove); color:#111;}

    .setlists-container { display:grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 1rem; }
    .setlist { background: var(--secondary); border: 1px solid var(--border); border-radius: 12px; padding: 1rem; }
    .setlist-header { display:flex; align-items:center; justify-content: space-between; border-bottom:2px solid var(--accent); padding-bottom:.5rem; margin-bottom:.75rem; }
    .setlist-song {
      display:grid; grid-template-columns: 20px 32px 1fr 54px 60px; gap:.6rem; align-items:center;
      background: var(--primary); border:1px solid var(--border); border-left:3px solid transparent; border-radius: 8px; padding: .6rem; margin-bottom:.5rem;
      transition: opacity 0.2s, border-color 0.2s;
    }
    .setlist-song.locked { border-left-color: var(--locked); background: rgba(74,222,128,.06); }
    .song-number { color: var(--accent); font-family:'Space Mono', monospace; font-weight:700; text-align:center; }
    .song-time { font-size: .8rem; color: var(--text-muted); text-align:right; font-family:'Space Mono', monospace; }
    .song-actions { display:flex; gap:.4rem; justify-content:flex-end; }
    .action-btn {
      width:26px; height:26px; display:flex; align-items:center; justify-content:center;
      border:1px solid var(--border); border-radius:6px; background: transparent; color:var(--text-muted); cursor:pointer;
    }
    .action-btn:hover { background: var(--border); color: var(--text); }
    .action-btn:disabled { opacity:.5; cursor:not-allowed; }
    .action-btn.locked { color: var(--locked); }

    /* Drag and Drop */
    .setlist-song[draggable="true"] { cursor: grab; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }
    .setlist-song[draggable="true"]:active { cursor: grabbing; }
    .setlist-song.dragging { opacity: 0.4; border: 1px dashed var(--accent); pointer-events: none; }
    .setlist-song.drag-over-top { border-top: 3px solid var(--accent); margin-top: -2px; }
    .setlist-song.drag-over-bottom { border-bottom: 3px solid var(--accent); margin-bottom: -2px; }
    .drag-handle { cursor: grab; color: var(--text-muted); font-size: 1rem; user-select: none; -webkit-user-select: none; display: flex; align-items: center; touch-action: none; }
    .drag-handle:active { cursor: grabbing; }
    .drop-zone-between { padding: .6rem; border: 2px dashed var(--border); border-radius: 8px; text-align: center; color: var(--text-muted); font-size: .8rem; margin-top: .35rem; transition: .2s; }
    .drop-zone-between:hover, .drop-zone-between.drag-over { border-color: var(--accent); color: var(--accent); background: rgba(255,107,53,.06); }
    .setlist.drag-target { outline: 2px solid var(--accent); outline-offset: 2px; }
    .move-to-set-select { font-size: .7rem; padding: .1rem .2rem; background: var(--primary); color: var(--text-muted); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; max-width: 70px; }
    .move-to-set-select:hover { border-color: var(--accent); color: var(--text); }
    .reset-balance-bar { display: flex; gap: .5rem; align-items: center; }
    .reset-balance-bar .btn { font-size: .8rem; }

    .toast-container { position: fixed; bottom: 1.25rem; left: 50%; transform: translateX(-50%); z-index: 2000; }
    .toast {
      background: var(--toast-bg); border: 1px solid var(--border); color: var(--text);
      border-radius: 8px; padding: .75rem 1rem; display:flex; gap:.6rem; align-items:center; min-width: 240px;
    }

    .alert { margin:.6rem 0; padding:.6rem .75rem; border-radius:8px; border:1px solid transparent; font-size:.9rem; display:flex; gap:.45rem; align-items:baseline; }
    .alert-error{ border-color: var(--error); background: rgba(239,68,68,.12); color: var(--error); }
    .alert-success{ border-color: var(--success); background: rgba(74,222,128,.12); color: var(--success); }
    .alert-warning{ border-color: var(--warning); background: rgba(251,191,36,.12); color: var(--warning); }

    .modal-backdrop { position:fixed; inset:0; background: rgba(0,0,0,.5); display:flex; justify-content:center; align-items:center; z-index:1500; }
    .modal { width:min(520px, 92vw); background:var(--secondary); border:1px solid var(--border); border-radius:12px; padding:1rem; }

    .band-row { display:flex; align-items:center; justify-content: space-between; padding:.5rem; border:1px solid var(--border);
      border-radius:8px; margin-bottom:.5rem; background: var(--primary); }
    .band-id { font-family:'Space Mono', monospace; color: var(--text-muted); font-size: .75rem; }

    .print-only { display: none; }
    .generation-stats { background: var(--primary); border-radius: 8px; padding: .5rem .75rem; margin-top: .5rem; font-size: .8rem; color: var(--text-muted); }
    .generation-stats strong { color: var(--accent); }

    @media print {
      @page { size: letter portrait; margin: 0.25in; }
      body { background: #fff; color: #000; }
      .no-print { display: none !important; }
      .print-only { display: block; }
      .set-page {
        page-break-after: always; break-after: page;
        font-family: 'Oswald', 'Helvetica Neue', Arial, sans-serif; font-size: 20pt; font-weight: bold; line-height: 1.0;
        position: relative; overflow: hidden;
      }
      .set-page:last-child { page-break-after: auto; break-after: auto; }
      .set-page img { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    }
    /* Import Modal Styles */
    .import-modal { width: min(720px, 95vw); max-height: 90vh; overflow-y: auto; background: var(--secondary); border: 1px solid var(--border); border-radius: 12px; padding: 1.25rem; }
    .import-steps { display: flex; gap: .5rem; margin-bottom: 1rem; }
    .import-step { flex: 1; text-align: center; padding: .5rem; border-radius: 8px; font-size: .75rem; font-weight: 600; text-transform: uppercase; letter-spacing: .05em; background: var(--primary); color: var(--text-muted); border: 1px solid var(--border); }
    .import-step.active { border-color: var(--accent); color: var(--accent); }
    .import-step.completed { border-color: var(--success); color: var(--success); }
    .import-tabs { display: flex; gap: .5rem; margin-bottom: 1rem; }
    .import-tab { padding: .5rem .75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--primary); color: var(--text-muted); font-size: .8rem; font-weight: 600; cursor: pointer; }
    .import-tab.active { border-color: var(--accent); color: var(--text); }
    .import-preview-table { width: 100%; border-collapse: collapse; font-size: .8rem; margin: .75rem 0; }
    .import-preview-table th, .import-preview-table td { padding: .4rem .5rem; border: 1px solid var(--border); text-align: left; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .import-preview-table th { background: var(--primary); color: var(--accent); font-weight: 700; text-transform: uppercase; font-size: .7rem; letter-spacing: .05em; }
    .import-preview-table tr:nth-child(even) td { background: rgba(255,255,255,.02); }
    .import-mapping-grid { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; margin: .75rem 0; }
    .import-mapping-item label { margin-bottom: .25rem; }
    .import-mapping-item .confidence { font-size: .7rem; color: var(--success); margin-left: .5rem; }
    .import-options { display: grid; grid-template-columns: 1fr 1fr; gap: .5rem; margin: .75rem 0; }
    .import-option { display: flex; align-items: center; gap: .5rem; font-size: .8rem; color: var(--text-muted); cursor: pointer; }
    .import-option input[type="checkbox"] { width: auto; accent-color: var(--accent); }
    .import-results-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: .75rem; margin: .75rem 0; }
    .import-stat { background: var(--primary); border: 1px solid var(--border); border-radius: 8px; padding: .75rem; text-align: center; }
    .import-stat .number { font-size: 1.5rem; font-weight: 700; font-family: 'Space Mono', monospace; }
    .import-stat .label { font-size: .7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .05em; }
    .import-stat.success .number { color: var(--success); }
    .import-stat.warning .number { color: var(--warning); }
    .import-stat.error .number { color: var(--error); }
    .import-warnings-list { max-height: 200px; overflow-y: auto; margin: .75rem 0; }
    .import-warning-item { display: flex; gap: .5rem; align-items: baseline; padding: .35rem .5rem; font-size: .8rem; border-bottom: 1px solid var(--border); }
    .import-warning-item:last-child { border-bottom: none; }
    .import-warning-code { font-family: 'Space Mono', monospace; font-size: .7rem; color: var(--warning); min-width: 160px; }
    .import-guardrail { background: rgba(74,222,128,.08); border: 1px solid var(--success); border-radius: 8px; padding: .75rem; margin: .75rem 0; font-size: .85rem; color: var(--success); }
    .import-rejected-table { width: 100%; border-collapse: collapse; font-size: .8rem; margin: .5rem 0; }
    .import-rejected-table th, .import-rejected-table td { padding: .35rem .5rem; border: 1px solid var(--border); text-align: left; }
    .import-rejected-table th { background: rgba(239,68,68,.15); color: var(--error); font-size: .7rem; text-transform: uppercase; }
    .import-footer { display: flex; gap: .75rem; justify-content: flex-end; margin-top: 1rem; padding-top: .75rem; border-top: 1px solid var(--border); }
    .import-textarea { width: 100%; min-height: 150px; font-family: 'Space Mono', monospace; font-size: .8rem; resize: vertical; }
    .import-drop-zone { border: 2px dashed var(--border); border-radius: 12px; padding: 2rem; text-align: center; color: var(--text-muted); cursor: pointer; transition: .2s; }
    .import-drop-zone:hover, .import-drop-zone.dragover { border-color: var(--accent); color: var(--text); }
    .import-drop-zone input[type="file"] { display: none; }

    @media (max-width: 1100px){ .main-grid{ grid-template-columns: 1fr; } }
    @media (max-width: 700px){
      h1{ font-size: 1.8rem; }
      .setlist-song{ grid-template-columns: 18px 26px 1fr 46px 50px; }
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    /******************* UTILITIES & GUARDS *******************/
    const genId = () => (window.crypto && crypto.randomUUID) ? crypto.randomUUID() :
      ('id-' + Math.random().toString(36).slice(2) + Date.now().toString(36));

    const sanitizeInput = (input) => {
      if (typeof input !== 'string') return input;
      let cleaned = input;
      cleaned = cleaned.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
      cleaned = cleaned.replace(/<\/?[^>]+>/g, '');
      cleaned = cleaned.replace(/javascript:|data:|vbscript:/gi, '');
      return cleaned.trim();
    };

    const guardCSVCell = (s) => {
      if (s == null) return '';
      const str = String(s);
      return /^[=+\-@]/.test(str) ? `'${str}` : str;
    };

    // Define tuning constants for algorithm thresholds.
    // MAX_GUARD sets an upper bound on loop iterations when filling a set to avoid infinite loops.
    // DURATION_TOLERANCE_POSITIVE and DURATION_TOLERANCE_NEGATIVE expand the acceptable range when
    // choosing songs to fill a remaining duration. DEFAULT_PASSES controls the number of
    // refinement passes when optimizing tonal smoothness. Expose these as constants for easy
    // tuning rather than embedding magic numbers throughout the code.
    const MAX_GUARD = 10000;
    const DURATION_TOLERANCE_POSITIVE = 2.0;
    const DURATION_TOLERANCE_NEGATIVE = 6.0;
    const DEFAULT_PASSES = 2;

    // PHASE 2: CSV Quoting Fix
    function csvEscapeCell(value) {
      const s = guardCSVCell(value == null ? '' : String(value));
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    // Default song duration in minutes used when a duration is missing or zero.
    const DEFAULT_DURATION_MINUTES = 4;

    /**
     * Parse a duration string or number into minutes. Supports "m:ss" format or plain
     * numbers. If the value is missing, invalid, or evaluates to zero, a default
     * duration is returned. This prevents zero-length songs from consuming an entire
     * setlist in the generator.
     *
     * @param {string|number|null|undefined} v The raw duration value.
     * @returns {number} Duration in minutes, with a sensible default when necessary.
     */
    const parseDuration = (v) => {
      // If a positive number is provided directly, use it.
      if (typeof v === 'number') {
        return v > 0 ? v : DEFAULT_DURATION_MINUTES;
      }
      // Non-string values return the default duration.
      if (typeof v !== 'string') return DEFAULT_DURATION_MINUTES;
      const cleaned = v.replace(/[^\d.:]/g, '').trim();
      if (!cleaned) {
        return DEFAULT_DURATION_MINUTES;
      }
      if (cleaned.includes(':')) {
        const [minsStr, secsStr] = cleaned.split(':');
        const mins = Number(minsStr);
        const secs = Number(secsStr);
        const total = (mins || 0) + ((secs || 0) / 60);
        return total > 0 ? total : DEFAULT_DURATION_MINUTES;
      }
      const parsed = parseFloat(cleaned);
      return (parsed && parsed > 0) ? parsed : DEFAULT_DURATION_MINUTES;
    };

    const LS = {
      // Add logging for localStorage getter failures. Swallowing exceptions silently hides
      // corrupted data or JSON parse errors. Logging aids debugging without breaking runtime.
      get: (k) => {
        try {
          return JSON.parse(localStorage.getItem(k));
        } catch (err) {
          console.warn('LS.get error:', err);
          return null;
        }
      },
      set: (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch (err) { console.error('LS.set error:', err); } },
      remove: (k) => { try { localStorage.removeItem(k); } catch (err) { console.error('LS.remove error:', err); } }
    };

    const LS_KEYS = {
      bands: 'setlist_bands_v3',
      active: 'setlist_activeBandId_v3',
      bandSongs: (id) => `setlist_band_songs_v3_${id}`,
      bandSettings: (id) => `setlist_band_settings_v3_${id}`,
      bandHistory: (id) => `setlist_band_history_v3_${id}`,
      bandImports: (id) => `setlist_band_imports_v3_${id}`,
      bandGigs: (id) => `setlist_band_gigs_v3_${id}`,
      bandWatermark: (id) => `setlist_band_watermark_v3_${id}`
    };

    const ENERGY_MAP = {
      ballad: 2, uptempo: 6, midtempo: 4, funk: 5, shuffle: 5, swing: 4, groove: 5
    };


    /******************* CSV IMPORT: NORMALIZATION ENGINE *******************/

    const IMPORT_VALID_KEYS = new Set([
      "C","Db","D","Eb","E","F","F#","G","Ab","A","Bb","B",
      "Cm","Dbm","Dm","Ebm","Em","Fm","F#m","Gm","Abm","Am","Bbm","Bm"
    ]);

    const IMPORT_DESCRIPTOR_TOKENS = [
      "instrumental","slow","blues","shuffle","ballad","funk","reggae",
      "dom","dominant","mixolydian","dorian","phrygian","lydian","locrian",
      "major","minor","maj","min"
    ];

    const IMPORT_COLUMN_SYNONYMS = {
      title: ["title","song","song title","name","tune","track"],
      key: ["key","tonality","pitch","root"],
      tempo: ["tempo","bpm","speed"],
      vocalist: ["vocalist","singer","lead","vox","vocal"]
    };

    function importNormalizeWhitespace(s) {
      const original = s ?? "";
      const trimmed = String(original).replace(/\s+/g, " ").trim();
      const warnings = [];
      if (trimmed !== original) warnings.push("title_trimmed");
      return { value: trimmed, warnings, original };
    }

    function importNormalizeSmartPunct(s) {
      const original = s ?? "";
      const converted = String(original)
        .replace(/[\u201C\u201D]/g, '"')
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u2014\u2013]/g, "-")
        .replace(/\u00A0/g, " ");
      const warnings = [];
      if (converted !== original) warnings.push("title_smart_punct");
      return { value: converted, warnings, original };
    }

    function importStripMetaParenEnd(title) {
      const original = title ?? "";
      const metaRe = /\s*\((demo|live|alt\.?\s*version|version|edit|radio\s*edit|\d{4})\)\s*$/i;
      const stripped = String(original).replace(metaRe, "").trim();
      const warnings = [];
      if (stripped !== original) warnings.push("title_meta_paren_stripped");
      return { value: stripped, warnings, original };
    }

    function importNormalizeTitle(title, opts) {
      const res1 = importNormalizeWhitespace(title);
      const res2 = importNormalizeSmartPunct(res1.value);
      let warnings = [...res1.warnings, ...res2.warnings];
      let val = res2.value;
      if (opts.stripMetaParen) {
        const res3 = importStripMetaParenEnd(val);
        val = res3.value;
        warnings.push(...res3.warnings);
      }
      return { value: val, warnings, original: title ?? "" };
    }

    function importNormalizeKeySingle(k) {
      const original = k ?? "";
      let s = String(original).replace(/\s+/g, " ").trim();
      const warnings = [];
      if (!s) return { value: "", warnings, original };
      s = s.replace(/\([^)]*\)/g, " ").replace(/\s+/g, " ").trim();
      const tokens = s.split(" ").filter(Boolean);
      const cleaned = tokens.filter(t => !IMPORT_DESCRIPTOR_TOKENS.includes(t.toLowerCase()));
      s = cleaned.join(" ").trim();
      s = s.replace(/maj(or)?$/i, "");
      s = s.replace(/min(or)?$/i, "m");
      const m = s.match(/^([A-Ga-g])\s*(#|b)?\s*(m)?$/);
      if (!m) return { value: "", warnings, original };
      let root = m[1].toUpperCase();
      let accidental = m[2] ? m[2] : "";
      let minor = m[3] ? "m" : "";
      const out = root + (accidental === "b" ? "b" : accidental) + minor;
      if (!IMPORT_VALID_KEYS.has(out)) return { value: "", warnings, original };
      return { value: out, warnings, original };
    }

    function importNormalizeKey(rawKey) {
      const original = rawKey ?? "";
      let s = String(original).trim();
      const warnings = [];
      if (!s) return { value: "", warnings, original };
      const parts = s.replace(/\bor\b/gi, "/").split(/[/,;|]+/).map(p => p.trim()).filter(Boolean);
      for (let i = 0; i < parts.length; i++) {
        const candidate = importNormalizeKeySingle(parts[i]);
        if (candidate.value) {
          if (parts.length > 1) warnings.push("multi_key_first_selected");
          return { value: candidate.value, warnings: [...warnings, ...candidate.warnings], original };
        }
      }
      warnings.push("key_invalid");
      return { value: "", warnings, original };
    }

    function importNormalizeTempo(rawTempo, opts) {
      const original = rawTempo ?? "";
      const warnings = [];
      let s = String(original).trim();
      if (!s) {
        if (opts.defaultTempo != null) {
          warnings.push("tempo_default_applied");
          return { value: String(opts.defaultTempo), warnings, original };
        }
        return { value: "", warnings, original };
      }
      const rangeMatch = s.match(/(\d+)\s*[-\u2013]\s*(\d+)/);
      if (rangeMatch) {
        warnings.push("tempo_range_first_selected");
        s = rangeMatch[1];
      }
      const intMatch = s.match(/(\d+)/);
      if (!intMatch) {
        if (opts.defaultTempo != null) {
          warnings.push("tempo_default_applied");
          return { value: String(opts.defaultTempo), warnings, original };
        }
        return { value: "", warnings, original };
      }
      const bpm = parseInt(intMatch[1], 10);
      if (bpm < 1 || bpm > 300) {
        warnings.push("tempo_out_of_range");
        return { value: "", warnings, original };
      }
      return { value: String(bpm), warnings, original };
    }

    function importNormalizeVocalist(rawVox, opts) {
      const original = rawVox ?? "";
      const warnings = [];
      let s = String(original).trim();
      if (!s) {
        warnings.push("vocalist_default_all");
        return { value: opts.defaultVocalist || "ALL", warnings, original };
      }
      if (/[/,&]+/.test(s)) {
        warnings.push("multi_vocalist_first_selected");
        s = s.split(/[/,&]+/)[0].trim();
      }
      return { value: s, warnings, original };
    }

    function importNormalizeRow(rowObj, mapping, opts) {
      const warnings = [];
      const changes = [];
      const rawTitle = rowObj[mapping.titleCol] ?? "";
      const rawKey = mapping.keyCol != null ? (rowObj[mapping.keyCol] ?? "") : "";
      const rawTempo = mapping.tempoCol != null ? (rowObj[mapping.tempoCol] ?? "") : "";
      const rawVox = mapping.vocalistCol != null ? (rowObj[mapping.vocalistCol] ?? "") : "";

      const t = importNormalizeTitle(rawTitle, opts);
      warnings.push(...t.warnings);
      if (t.original !== t.value) changes.push({ field: "title", original: t.original, normalized: t.value });

      const k = opts.normalizeKeys ? importNormalizeKey(rawKey) : { value: String(rawKey).trim(), warnings: [], original: String(rawKey) };
      warnings.push(...k.warnings);
      if (k.original !== k.value) changes.push({ field: "key", original: k.original, normalized: k.value });

      const p = opts.normalizeTempo ? importNormalizeTempo(rawTempo, opts) : { value: String(rawTempo).trim(), warnings: [], original: String(rawTempo) };
      warnings.push(...p.warnings);
      if (p.original !== p.value) changes.push({ field: "tempo", original: p.original, normalized: p.value });

      const v = opts.normalizeVocalist ? importNormalizeVocalist(rawVox, opts) : { value: String(rawVox).trim(), warnings: [], original: String(rawVox) };
      warnings.push(...v.warnings);
      if (v.original !== v.value) changes.push({ field: "vocalist", original: v.original, normalized: v.value });

      const out = { title: t.value, key: k.value, tempo: p.value, vocalist: v.value };
      const rejectReason = !out.title ? "empty_title" : null;
      return { out, rejectReason, warnings, changes };
    }

    function importNormalizeAll(parsedRows, mapping, opts) {
      const rows = [];
      const rejected = [];
      const warningCounts = {};
      const rowChanges = [];
      parsedRows.forEach((rowObj, idx) => {
        const res = importNormalizeRow(rowObj, mapping, opts);
        res.warnings.forEach(w => warningCounts[w] = (warningCounts[w] || 0) + 1);
        if (res.rejectReason) {
          rejected.push({ rowIndex: idx + 1, reason: res.rejectReason, raw: rowObj });
          return;
        }
        rows.push(res.out);
        if (rowChanges.length < 200 && res.changes.length) {
          rowChanges.push({ rowIndex: idx + 1, changes: res.changes });
        }
      });
      return {
        rows, rejected,
        report: { rowsParsed: parsedRows.length, rowsImported: rows.length, rowsRejected: rejected.length, warningCounts, sampleChanges: rowChanges }
      };
    }

    function importToCanonicalCSV(rows) {
      const header = ["title","key","tempo","vocalist"];
      const esc = (s) => `"${String(s ?? "").replace(/"/g,'""')}"`;
      const lines = [header.join(",")];
      for (const r of rows) {
        lines.push([esc(r.title), esc(r.key), r.tempo ? String(parseInt(r.tempo, 10)) : "", esc(r.vocalist)].join(","));
      }
      return lines.join("\n");
    }

    function importDetectDelimiter(text) {
      const lines = text.split(/\r?\n/).slice(0, 10).filter(l => l.trim());
      const delimiters = [",", "\t", "|", ";"];
      let best = ",";
      let bestScore = -1;
      for (const d of delimiters) {
        const counts = lines.map(l => l.split(d).length - 1);
        if (counts.length === 0) continue;
        const min = Math.min(...counts);
        const max = Math.max(...counts);
        const stability = min > 0 && (max - min) <= 1 ? 1 : 0;
        const score = min * 10 + stability * 100;
        if (score > bestScore) { bestScore = score; best = d; }
      }
      return best;
    }

    function importAutoMapColumns(headers) {
      const mapping = { titleCol: null, keyCol: null, tempoCol: null, vocalistCol: null };
      const confidences = {};
      const used = new Set();

      for (const [field, synonyms] of Object.entries(IMPORT_COLUMN_SYNONYMS)) {
        let bestIdx = null;
        let bestScore = 0;
        headers.forEach((h, idx) => {
          if (used.has(idx)) return;
          const lh = h.toLowerCase().trim();
          let score = 0;
          for (const syn of synonyms) {
            if (lh === syn) { score = Math.max(score, 100); break; }
            if (lh.startsWith(syn)) score = Math.max(score, 70);
            else if (lh.includes(syn)) score = Math.max(score, 60);
          }
          if (score > bestScore) { bestScore = score; bestIdx = idx; }
        });
        if (bestIdx !== null && bestScore >= 50) {
          const colKey = field + "Col";
          mapping[colKey] = bestIdx;
          confidences[colKey] = bestScore;
          used.add(bestIdx);
        }
      }
      return { mapping, confidences };
    }

    /******************* END CSV IMPORT ENGINE *******************/


    /******************* PDF IMPORT ENGINE *******************/

    /**
     * Extract text content from a PDF file using pdf.js.
     * Returns an array of strings, one per page.
     */
    async function pdfExtractText(arrayBuffer) {
      if (!window.pdfjsLib) throw new Error('PDF.js not loaded');
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const pages = [];
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        // Group items by Y position to reconstruct rows
        const items = content.items.filter(item => item.str.trim());
        const rows = [];
        let currentY = null;
        let currentRow = [];
        // Sort by Y (descending, since PDF Y is bottom-up) then by X
        items.sort((a, b) => {
          const yDiff = b.transform[5] - a.transform[5];
          if (Math.abs(yDiff) > 3) return yDiff;
          return a.transform[4] - b.transform[4];
        });
        for (const item of items) {
          const y = Math.round(item.transform[5]);
          if (currentY === null || Math.abs(y - currentY) > 3) {
            if (currentRow.length) rows.push(currentRow.join('\t'));
            currentRow = [item.str.trim()];
            currentY = y;
          } else {
            currentRow.push(item.str.trim());
          }
        }
        if (currentRow.length) rows.push(currentRow.join('\t'));
        pages.push(rows.join('\n'));
      }
      return pages;
    }

    // Known style values for BandHelper / Zemba-style PDFs
    const PDF_KNOWN_STYLES = new Set([
      'uptempo','ballad','midtempo','groove','shuffle','swing','funk',
      'slow blues','rock','blues','country','jazz','reggae','latin','pop'
    ]);

    /**
     * Detect column header row and return column index mapping.
     * Matches headers like: "# TITLE ARTIST DURATION STYLE KEY BPM VOCALIST"
     * Returns { detected: true, map: { title, artist, duration, style, key, bpm, vocalist } }
     * or { detected: false }
     */
    function pdfDetectHeaderRow(allLines) {
      for (let i = 0; i < Math.min(allLines.length, 15); i++) {
        const line = allLines[i];
        const parts = line.split(/\t/).map(s => s.trim().toLowerCase());
        // Need at least title and one other recognizable column
        const titleIdx = parts.findIndex(p => /^(title|song|song\s*title|tune)$/.test(p));
        if (titleIdx < 0) continue;

        const artistIdx = parts.findIndex(p => /^(artist|band|performer)$/.test(p));
        const durationIdx = parts.findIndex(p => /^(duration|dur|time|length)$/.test(p));
        const styleIdx = parts.findIndex(p => /^(style|genre|type|feel)$/.test(p));
        const keyIdx = parts.findIndex(p => /^(key|tonality|pitch)$/.test(p));
        const bpmIdx = parts.findIndex(p => /^(bpm|tempo|speed)$/.test(p));
        const vocalistIdx = parts.findIndex(p => /^(vocalist|singer|vox|vocal|vocals|lead)$/.test(p));
        const numIdx = parts.findIndex(p => /^(#|no\.?|number|num)$/.test(p));

        // Must have at least title + artist or title + 2 other columns
        const found = [artistIdx, durationIdx, styleIdx, keyIdx, bpmIdx].filter(i => i >= 0).length;
        if (found < 1) continue;

        return {
          detected: true,
          headerLineIdx: i,
          map: {
            num: numIdx,
            title: titleIdx,
            artist: artistIdx,
            duration: durationIdx,
            style: styleIdx,
            key: keyIdx,
            bpm: bpmIdx,
            vocalist: vocalistIdx
          }
        };
      }
      return { detected: false };
    }

    /**
     * Parse a row using detected column positions (header-mapped mode).
     * Used for BandHelper / Zemba-style PDFs with clear column structure.
     */
    function pdfParseWithColumnMap(line, colMap) {
      const trimmed = line.trim();
      if (!trimmed) return null;

      const parts = trimmed.split(/\t/).map(s => s.trim());
      if (parts.length < 2) return null;

      // Get title - required
      const title = colMap.title >= 0 && colMap.title < parts.length ? parts[colMap.title] : '';
      if (!title || /^(title|#|number)\b/i.test(title)) return null;

      // Skip non-data rows (headers repeated on new pages, summary rows)
      if (/^\d+\s+songs?[,\s]/i.test(trimmed)) return null;

      const get = (idx) => (idx >= 0 && idx < parts.length) ? parts[idx] : '';

      const artist = get(colMap.artist);
      const rawDuration = get(colMap.duration);
      const style = get(colMap.style);
      const rawKey = get(colMap.key);
      const rawBpm = get(colMap.bpm);
      const vocalist = get(colMap.vocalist);

      // Parse duration: could be M:SS, plain minutes, or decimal
      let duration = '';
      if (rawDuration) {
        if (/^\d{1,2}:\d{2}$/.test(rawDuration)) {
          const [m, s] = rawDuration.split(':').map(Number);
          duration = String(Math.round((m + s / 60) * 100) / 100);
        } else {
          const num = parseFloat(rawDuration);
          if (num > 0) duration = String(num);
        }
      }

      // Parse BPM: strip decimal (122.0 -> 122)
      let bpm = '';
      if (rawBpm) {
        const bpmMatch = rawBpm.match(/(\d+)/);
        if (bpmMatch) bpm = bpmMatch[1];
      }

      // Normalize key: handle Cmaj, Bbm, F#, etc.
      let key = '';
      if (rawKey) {
        let k = rawKey.trim();
        k = k.replace(/maj(or)?$/i, '');
        if (/^[A-Ga-g][b#]?m?$/i.test(k)) {
          key = k.charAt(0).toUpperCase() + k.slice(1);
        } else {
          key = rawKey.trim();
        }
      }

      if (!title) return null;

      return {
        number: 0,
        title: title.trim(),
        artist: artist.trim(),
        vocalist: vocalist.trim(),
        duration,
        style: style.trim().toLowerCase(),
        key: key.trim(),
        bpm: bpm.trim()
      };
    }

    /**
     * Parse a line using heuristic detection (no header row found).
     * Works for DSJ-style PDFs with numbered rows and M:SS durations.
     * Returns { number, title, artist, vocalist, duration, key, bpm, style } or null
     */
    function pdfParseBandListLine(line) {
      // Skip header rows and empty lines
      const trimmed = line.trim();
      if (!trimmed) return null;
      if (/^(title|#|number)\b/i.test(trimmed)) return null;
      if (/^\d+\s+songs?,/i.test(trimmed)) return null; // "56 songs, 4:04" summary

      // Try to detect a numbered row: starts with digits
      const numberedMatch = trimmed.match(/^(\d+)\s+(.+)/);
      if (!numberedMatch) return null;

      const rowNum = parseInt(numberedMatch[1], 10);
      const rest = numberedMatch[2];

      // Split by tab or 2+ spaces
      const parts = rest.split(/\t|  +/).map(s => s.trim()).filter(Boolean);

      if (parts.length < 2) return null;

      // Heuristic detection of fields (scan from right to left)
      let durationIdx = -1;
      let keyIdx = -1;
      let bpmIdx = -1;
      let styleIdx = -1;

      for (let i = parts.length - 1; i >= 0; i--) {
        const p = parts[i];
        const pLower = p.toLowerCase();

        // BPM: 2-3 digits, optionally with .0 decimal
        if (bpmIdx === -1 && /^\d{2,3}(\.\d)?$/.test(p)) {
          bpmIdx = i;
        // Key: musical key notation (A-G with optional accidental and minor)
        } else if (keyIdx === -1 && /^[A-G][b#]?(m|maj|min)?$/i.test(p) && p.length <= 4) {
          keyIdx = i;
        // Key: multi-key like "C / F / F /"
        } else if (keyIdx === -1 && /^[A-G][b#]?\s*\/\s*[A-G]/.test(p)) {
          keyIdx = i;
        // Style: known style value
        } else if (styleIdx === -1 && PDF_KNOWN_STYLES.has(pLower)) {
          styleIdx = i;
        // Duration: M:SS format
        } else if (durationIdx === -1 && /^\d{1,2}:\d{2}$/.test(p)) {
          durationIdx = i;
        // Duration: plain number 1-20 (minutes) - only if no M:SS found yet
        } else if (durationIdx === -1 && /^\d{1,2}(\.\d+)?$/.test(p)) {
          const num = parseFloat(p);
          if (num > 0 && num <= 20) durationIdx = i;
        }
      }

      // Parse duration
      let duration = '';
      if (durationIdx >= 0) {
        const dp = parts[durationIdx];
        if (/^\d{1,2}:\d{2}$/.test(dp)) {
          const [m, s] = dp.split(':').map(Number);
          duration = String(Math.round((m + s / 60) * 100) / 100);
        } else {
          const num = parseFloat(dp);
          if (num > 0) duration = String(num);
        }
      }

      let key = keyIdx >= 0 ? parts[keyIdx].replace(/\s*\/\s*/g, '/').replace(/maj(or)?$/i, '').trim() : '';
      let bpm = bpmIdx >= 0 ? parts[bpmIdx].replace(/\.0$/, '') : '';
      let style = styleIdx >= 0 ? parts[styleIdx].toLowerCase() : '';

      // Collect remaining text parts (title, artist, vocalist)
      const metaIndices = new Set([durationIdx, keyIdx, bpmIdx, styleIdx].filter(i => i >= 0));
      const textParts = parts.filter((_, i) => !metaIndices.has(i));

      let title = '', artist = '', vocalist = '';

      if (textParts.length >= 3) {
        title = textParts[0];
        artist = textParts[1];
        vocalist = textParts.slice(2).join(' ');
      } else if (textParts.length === 2) {
        title = textParts[0];
        artist = textParts[1];
      } else if (textParts.length === 1) {
        title = textParts[0];
      }

      if (!title) return null;

      return {
        number: rowNum,
        title: title.trim(),
        artist: artist.trim(),
        vocalist: vocalist.trim(),
        duration,
        style,
        key: key.trim(),
        bpm: bpm.trim()
      };
    }

    /**
     * Parse all pages of extracted PDF text into song rows.
     * First tries header-detection (BandHelper/Zemba format),
     * then falls back to heuristic parsing (DSJ format).
     */
    function pdfParseAllPages(pageTexts) {
      const allLines = pageTexts.join('\n').split('\n');

      // Try header-based detection first
      const headerResult = pdfDetectHeaderRow(allLines);
      if (headerResult.detected) {
        const songs = [];
        for (let i = 0; i < allLines.length; i++) {
          if (i === headerResult.headerLineIdx) continue;
          // Skip repeated header rows on subsequent pages
          const lower = allLines[i].toLowerCase();
          if (/\btitle\b/.test(lower) && /\bartist\b/.test(lower)) continue;
          const parsed = pdfParseWithColumnMap(allLines[i], headerResult.map);
          if (parsed) songs.push(parsed);
        }
        if (songs.length > 0) return songs;
      }

      // Fallback: heuristic line-by-line parsing (DSJ-style)
      const songs = [];
      for (const line of allLines) {
        const parsed = pdfParseBandListLine(line);
        if (parsed) songs.push(parsed);
      }
      return songs;
    }

    /**
     * Convert parsed PDF songs into the standard CSV format string.
     */
    function pdfSongsToCSV(songs) {
      const headers = ['Title', 'Artist', 'Duration', 'Style', 'Key', 'BPM', 'Vocalist'];
      const esc = (s) => {
        const str = String(s ?? '');
        if (/[",\n\r]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
        return str;
      };
      const lines = [headers.join(',')];
      for (const s of songs) {
        lines.push([
          esc(s.title), esc(s.artist), esc(s.duration), esc(s.style || ''), esc(s.key), esc(s.bpm), esc(s.vocalist)
        ].join(','));
      }
      return lines.join('\n');
    }

    /******************* END PDF IMPORT ENGINE *******************/


/******************* PHASE 3B: TONAL GRAVITY (CIRCLE OF FIFTHS) *******************/
// Canonical internal tonics are taken from the fixed circle ordering below.
// Display tonics are musician-friendly (F# instead of Gb), but distances always use canonical tonics.

const CIRCLE_OF_FIFTHS = ["C","G","D","A","E","B","F#","Db","Ab","Eb","Bb","F"];
const SHARP_TO_FLAT = { "C#":"Db","D#":"Eb","F#":"Gb","G#":"Ab","A#":"Bb" };
const CANONICAL_SET = new Set(["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B","F#"]); // include F# for direct user input
const DISPLAY_OVERRIDES = { "Gb":"F#" };

function normalizeKey_TG(keyString, songTags = []) {
  if (!keyString || typeof keyString !== 'string') return null;
  const raw = keyString.trim().replace(/♯/g,'#').replace(/♭/g,'b');
  if (!raw) return null;

  // detect tonic letter + accidental
  const m = raw.match(/^([A-G])\s*([#b]?)/);
  if (!m) { console.warn('[TonalGravity] Invalid key:', keyString); return null; }

  let tonic = (m[1] || '').toUpperCase() + (m[2] || '');
  // convert sharp to canonical flat where required (except F# which is explicitly on the circle)
  if (SHARP_TO_FLAT[tonic] && tonic !== 'F#') tonic = SHARP_TO_FLAT[tonic];

  // allow Gb internally even though circle uses F#
  if (tonic === 'Gb') tonic = 'F#';

  if (!CIRCLE_OF_FIFTHS.includes(tonic)) {
    // allow naturals that may parse oddly
    if (!CANONICAL_SET.has(tonic)) {
      console.warn('[TonalGravity] Unsupported tonic:', tonic, 'from', keyString);
      return null;
    }
  }

  const tags = Array.isArray(songTags) ? songTags.map(t => String(t).toLowerCase()) : [];
  const isMinor =
    /\bminor\b/i.test(raw) ||
    /\bmin\b/i.test(raw) ||
    (/m$/i.test(raw) && !/maj/i.test(raw)) ||
    tags.includes('minor') || tags.includes('dark');

  const mode = isMinor ? 'minor' : 'major';
  const displayTonic = DISPLAY_OVERRIDES[tonic] || tonic;

  return { tonic, mode, displayTonic };
}

function getCircleIndex_TG(tonic) {
  return CIRCLE_OF_FIFTHS.indexOf(tonic);
}

function circleDistance_TG(a, b) {
  const ia = getCircleIndex_TG(a);
  const ib = getCircleIndex_TG(b);
  if (ia < 0 || ib < 0) return 6;
  const diff = Math.abs(ia - ib);
  return Math.min(diff, 12 - diff);
}

function areRelativeKeys_TG(k1, k2) {
  if (!k1 || !k2) return false;
  if (k1.mode === k2.mode) return false;
  return circleDistance_TG(k1.tonic, k2.tonic) === 3;
}

function areParallelKeys_TG(k1, k2) {
  if (!k1 || !k2) return false;
  return k1.tonic === k2.tonic && k1.mode !== k2.mode;
}

function determineAnchorKey_TG(songs, userAnchor = '') {
  const manual = userAnchor && typeof userAnchor === 'string' ? userAnchor.trim() : '';
  if (manual) {
    const nk = normalizeKey_TG(manual);
    if (nk) return nk;
  }

  const counts = {};
  for (const s of songs) {
    const nk = s.normalizedKey;
    if (!nk) continue;
    counts[nk.tonic] = (counts[nk.tonic] || 0) + 1;
  }
  const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([t])=>t);
  if (top.length === 0) return normalizeKey_TG('A'); // safe default

  let best = top[0], bestAvg = Infinity;
  for (const cand of top) {
    const avg = top.reduce((sum,t)=>sum+circleDistance_TG(cand,t),0) / top.length;
    if (avg < bestAvg) { bestAvg = avg; best = cand; }
  }
  return normalizeKey_TG(best);
}

function isContrastSlot_TG(pos, setLen, tonalSmoothness) {
  if (tonalSmoothness > 50) return false; // <=50 means allow contrast
  const cp = Math.floor(setLen * 0.66);
  return Math.abs(pos - cp) <= 1;
}

function calculateTonalTransitionScore_TG(prevSong, nextSong, pos, setLen, tonalSmoothness) {
  // Null-safe: missing keys simply contribute 0 tonal score
  if (!prevSong?.normalizedKey || !nextSong?.normalizedKey) return 0;

  const a = prevSong.normalizedKey;
  const b = nextSong.normalizedKey;
  const dist = circleDistance_TG(a.tonic, b.tonic);

  let base = 0;
  if (dist <= 1) base = 10;
  else if (dist === 2) base = 6;
  else if (dist === 3) base = 2;
  else base = -4;

  // planned contrast slot
  if (isContrastSlot_TG(pos, setLen, tonalSmoothness) && dist >= 4) {
    base = Math.max(0, base);
  }

  let modeBonus = 0;
  if (areRelativeKeys_TG(a, b)) modeBonus += 5;
  if (areParallelKeys_TG(a, b)) modeBonus += 4;

  // repetition penalty (simple, fast)
  let repetitionPenalty = 0;
  if (a.tonic === b.tonic && a.mode === b.mode) repetitionPenalty -= 5;

  return base + modeBonus + repetitionPenalty;
}

// generateTonalDiagnostics_TG analyses tonal transitions across the provided setlists.
// Previously unused parameters anchorKey and tonalSmoothness were removed to simplify
// the signature. The function now derives all needed context from the setlists
// themselves.
function generateTonalDiagnostics_TG(setlists) {
  const out = [];
  for (let setIdx = 0; setIdx < setlists.length; setIdx++) {
    const set = setlists[setIdx];
    const keyPath = set.songs.map(s => {
      const nk = s.normalizedKey;
      return nk ? { tonicCanonical: nk.tonic, tonicDisplay: nk.displayTonic, mode: nk.mode } : null;
    }).filter(Boolean);

    let sum = 0;
    let edges = 0;
    const contrastJumps = [];

    for (let i = 0; i < set.songs.length - 1; i++) {
      const a = set.songs[i].normalizedKey;
      const b = set.songs[i+1].normalizedKey;
      if (!a || !b) continue;
      const dist = circleDistance_TG(a.tonic, b.tonic);
      sum += dist; edges++;
      if (dist >= 4) {
        contrastJumps.push({
          position: i + 2,
          from: a.displayTonic + (a.mode === 'minor' ? 'm' : ''),
          to: b.displayTonic + (b.mode === 'minor' ? 'm' : ''),
          distance: dist
        });
      }
    }

    const avg = edges ? (sum / edges) : 0;
    const qualityScore = avg <= 2 ? "Excellent" : avg <= 3 ? "Good" : avg <= 4 ? "Fair" : "Needs Review";

    out.push({
      avgCircleDistance: Math.round(avg * 10) / 10,
      qualityScore,
      keyPath: keyPath.map(k => ({ tonic: k.tonicDisplay, mode: k.mode })), // safe for UI
      contrastJumps
    });
  }
  return out;
}

// Tonal Gravity generator wrapper: preserve Phase 2 validity, then refine ordering locally.
function generateSetlistsCore_WithTonalGravity(songs, opts) {
  const enriched = (songs || []).map(s => ({
    ...s,
    normalizedKey: normalizeKey_TG(s.key, s.tags || [])
  }));

  // Always use Phase 2 to satisfy duration/energy/locks robustly
  const base = generateSetlistsCore(enriched, opts);

  // Local refinement pass: adjacent swaps only (fast & safe)
  base.forEach(set => {
    const len = set.songs.length;
    if (len < 3) return;

    // multiple passes for a little more convergence
    // Use configurable DEFAULT_PASSES rather than hard-coded passes.
    const PASSES = DEFAULT_PASSES;
    for (let pass = 0; pass < PASSES; pass++) {
      for (let i = 1; i < len - 1; i++) {
        const prev = set.songs[i - 1];
        const curr = set.songs[i];
        const next = set.songs[i + 1];

        const currentScore =
          calculateTonalTransitionScore_TG(prev, curr, i, len, opts.tonalSmoothness ?? 70) +
          calculateTonalTransitionScore_TG(curr, next, i + 1, len, opts.tonalSmoothness ?? 70);

        const swappedScore =
          calculateTonalTransitionScore_TG(prev, next, i, len, opts.tonalSmoothness ?? 70) +
          calculateTonalTransitionScore_TG(next, curr, i + 1, len, opts.tonalSmoothness ?? 70);

        if (swappedScore > currentScore + 3) {
          [set.songs[i], set.songs[i + 1]] = [set.songs[i + 1], set.songs[i]];
        }
      }
    }

    set.totalTime = set.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);
  });

  // Attach diagnostics (non-breaking) when enabled
  try {
    const anchor = determineAnchorKey_TG(enriched, opts.anchorKey || '');
    base.diagnostics = generateTonalDiagnostics_TG(base);
    base.anchorKey = anchor?.displayTonic || anchor?.tonic || null;
  } catch (e) {
    console.warn('[TonalGravity] Diagnostics failed:', e);
  }

  return base;
}


    /******************* CORE GENERATOR (PHASE 2 OPTIMIZED) *******************/
    function generateSetlistsCore(songs, opts) {
      const {
        numSets = 2,
        setDuration = 45,
        allowSongReuse = false,
        useEnergyCurve = true,
        forceOpener = false,
        forceCloser = true,
        lockedOpeners = [],
        lockedClosers = [],
        lockPlan = null
      } = opts || {};

      const pool = [...songs].map(s => ({ ...s, duration: parseDuration(s.duration) }));
      const used = new Map();
      const generationWarnings = new Set();
      let totalAttempts = 0;
      let generationAborted = false;

      const getSongDedupKeys = (s) => {
        const k = [];
        if (s.id) k.push(`id:${s.id}`);
        if (s.title && s.artist) k.push(`ta:${s.title.toLowerCase().trim()}|${s.artist.toLowerCase().trim()}`);
        return k;
      };

      const markUsed = (song) => {
        const keys = getSongDedupKeys(song);
        for (const k of keys) {
          used.set(k, (used.get(k) || 0) + 1);
        }
      };

      const unmarkUsed = (song) => {
        const keys = getSongDedupKeys(song);
        for (const k of keys) {
          const count = used.get(k) || 0;
          if (count <= 1) used.delete(k);
          else used.set(k, count - 1);
        }
      };

      const isAvailable = (song) => {
        if (allowSongReuse) return true;
        const keys = getSongDedupKeys(song);
        return !keys.some(k => used.has(k) && used.get(k) > 0);
      };

      const results = [];

      for (let setNum = 0; setNum < numSets; setNum++) {
        if (generationAborted) break;
        const lockedSlots = new Map(); // idx -> song
        const plan = Array.isArray(lockPlan) && Array.isArray(lockPlan[setNum]) ? lockPlan[setNum] : null;

        if (plan && plan.length) {
          for (const entry of plan) {
            if (!entry || !entry.song) continue;
            const idx = Math.max(0, Math.floor(entry.index));
            const song = entry.song;

            if (!allowSongReuse && !isAvailable(song)) continue;
            lockedSlots.set(idx, song);
            markUsed(song);
          }
        }

        let setArr = [];
        let current = 0;
        const setUsedIds = new Set(); // O(1) dedup within a single set

        if (lockedSlots.size > 0) {
          const maxIdx = Math.max(...lockedSlots.keys());
          setArr = new Array(maxIdx + 1).fill(null);
          for (const [idx, song] of lockedSlots.entries()) {
            setArr[idx] = song;
            setUsedIds.add(song.id);
            current += song.duration || 0;
          }
        } else {
          setArr = [];
        }

        if (lockedSlots.size === 0 && forceOpener) {
          let opener = null;

          // Prefer user-selected locked openers
          if (lockedOpeners.length > 0) {
            const availableLockedOpeners = lockedOpeners
              .map(id => pool.find(s => s.id === id))
              .filter(s => s && isAvailable(s));
            if (availableLockedOpeners.length > 0) {
              opener = availableLockedOpeners[Math.floor(Math.random() * availableLockedOpeners.length)];
            }
          }

          // Fallback to style-based opener if no locked opener available
          if (!opener) {
            const openerStyles = ['uptempo', 'swing', 'midtempo', 'groove'];
            const openers = pool.filter(s => isAvailable(s) && openerStyles.includes(s.style));
            if (openers.length > 0) {
              opener = openers[Math.floor(Math.random() * openers.length)];
            }
          }

          if (opener) {
            setArr[0] = opener;
            setUsedIds.add(opener.id);
            markUsed(opener);
            current += opener.duration || 0;
          }
        }

        let lastAddedSong = null;
        // Track last added song directly instead of scanning backwards each iteration
        if (lockedSlots.size > 0) {
          for (let i = setArr.length - 1; i >= 0; i--) {
            if (setArr[i]) { lastAddedSong = setArr[i]; break; }
          }
        }

        let guard = 0;
        const maxGuard = MAX_GUARD;

        // Pre-build available pool index for faster candidate lookup
        while (current < setDuration - 0.5 && guard < maxGuard) {
          guard++;
          const remaining = setDuration - current;

          let insertIndex = setArr.indexOf(null);
          if (insertIndex === -1) insertIndex = setArr.length;

          const durMin = Math.max(0.5, remaining - DURATION_TOLERANCE_NEGATIVE);
          const durMax = remaining + DURATION_TOLERANCE_POSITIVE;

          let candidates = pool.filter(song => {
            if (setUsedIds.has(song.id)) return false;
            if (!isAvailable(song)) return false;
            const dur = song.duration;
            return dur <= durMax && dur >= durMin;
          });

          if (candidates.length === 0) {
            candidates = pool.filter(s => !setUsedIds.has(s.id) && isAvailable(s));
            if (candidates.length === 0) {
              if (!allowSongReuse) {
                generationWarnings.add(`Set ${setNum + 1}: Ran out of unique songs at ${Math.round(current)}min.`);
                generationAborted = true;
              }
              break;
            }
          }

          const last = lastAddedSong;

          const scored = candidates.map(s => {
            const dur = s.duration || 0;
            const timePenalty = Math.abs(remaining - dur);

            let diversityPenalty = 0;
            if (last) {
              if (s.style === last.style) diversityPenalty += 1.25;
              if (s.artist === last.artist) diversityPenalty += 1.0;
            }

            let energyPenalty = 0;
            if (useEnergyCurve) {
              const pos = (setDuration - remaining) / setDuration;
              let targetE = 4;
              if (pos < 0.15) targetE = 3.5;
              else if (pos < 0.4) targetE = 4.5;
              else if (pos < 0.75) targetE = 5.5;
              else targetE = 3.0;
              const e = ENERGY_MAP[s.style] || 3;
              energyPenalty = Math.abs(e - targetE) * 0.35;
            }

            const score = timePenalty + diversityPenalty + energyPenalty;
            return { s, score };
          });

          scored.sort((a, b) => a.score - b.score);

          const topK = scored.slice(0, Math.min(6, scored.length));
          const pick = topK[Math.floor(Math.random() * topK.length)].s;

          setArr[insertIndex] = pick;
          setUsedIds.add(pick.id);
          markUsed(pick);
          current += pick.duration;
          lastAddedSong = pick;
          totalAttempts++;

          if (current > setDuration + 8) break;
        }

        const setSongs = setArr.filter(Boolean);

        if (forceCloser && setSongs.length > 0) {
          const lastIdx = setSongs.length - 1;
          const lastSong = setSongs[lastIdx];
          const closerStyles = ['ballad', 'midtempo', 'swing'];

          // Check if a locked closer should be used
          let useLockedCloser = false;
          let lockedCloserSong = null;

          if (lockedClosers.length > 0) {
            const availableLockedClosers = lockedClosers
              .map(id => pool.find(s => s.id === id))
              .filter(s => s && (s.id === lastSong.id || (allowSongReuse || !setSongs.some((x, xi) => xi !== lastIdx && x.id === s.id))));

            // Find one that's available globally
            if (!allowSongReuse) unmarkUsed(lastSong);
            const reallyAvailable = availableLockedClosers.filter(s => s.id === lastSong.id || isAvailable(s));
            if (reallyAvailable.length > 0) {
              lockedCloserSong = reallyAvailable[Math.floor(Math.random() * reallyAvailable.length)];
              useLockedCloser = true;
            }
            if (!useLockedCloser && !allowSongReuse) markUsed(lastSong);
          }

          if (useLockedCloser && lockedCloserSong) {
            if (lockedCloserSong.id !== lastSong.id) {
              setSongs[lastIdx] = lockedCloserSong;
              markUsed(lockedCloserSong);
            } else {
              // Locked closer is already the last song, re-mark it
              if (!allowSongReuse) markUsed(lastSong);
            }
          } else if (!closerStyles.includes(lastSong.style)) {
            // Fallback to style-based closer selection
            if (!allowSongReuse) unmarkUsed(lastSong);

            const closerCandidates = pool.filter(s =>
              isAvailable(s) && closerStyles.includes(s.style) && s.id !== lastSong.id
              && !setSongs.some((x, xi) => xi !== lastIdx && x.id === s.id)
            );
            if (closerCandidates.length > 0) {
              const closer = closerCandidates[Math.floor(Math.random() * closerCandidates.length)];
              setSongs[lastIdx] = closer;
              markUsed(closer);
            } else {
              if (!allowSongReuse) markUsed(lastSong);
            }
          }
        }

        const totalTime = setSongs.reduce((sum, s) => sum + (s.duration || 0), 0);
        results.push({
          id: genId(),
          name: `Set ${setNum + 1}`,
          songs: setSongs,
          totalTime
        });
      }

      const songsUsed = new Set(results.flatMap(r => r.songs.map(s => s.id))).size;
      results.stats = { songsUsed, attempts: totalAttempts };
      results.generationWarnings = Array.from(generationWarnings);

      return results;
    }

    /******************* REACT COMPONENTS *******************/
    function ErrorBoundary({ children }) {
      const [hasError, setHasError] = useState(false);
      const [error, setError] = useState(null);

      useEffect(() => {
        const handler = (event) => {
          setHasError(true);
          setError(event.error);
        };
        window.addEventListener('error', handler);
        return () => window.removeEventListener('error', handler);
      }, []);

      if (hasError) {
        return (
          <div style={{ padding: '2rem', textAlign: 'center' }}>
            <h2 style={{ color: 'var(--error)' }}>Something went wrong</h2>
            <pre style={{ color: 'var(--text-muted)', marginTop: '1rem', whiteSpace: 'pre-wrap', textAlign: 'left' }}>
              {error?.toString() || 'Unknown error'}
            </pre>
          </div>
        );
      }
      return children;
    }

    function Toast({ message, type, onClose }) {
      useEffect(() => {
        const t = setTimeout(onClose, 3500);
        return () => clearTimeout(t);
      }, [onClose]);

      return (
        <div className="toast">
          <span>{type === 'error' ? '❌' : type === 'success' ? '✅' : '⚠️'}</span>
          <span>{message}</span>
        </div>
      );
    }

    // PHASE 3A: Active / Cold tabs + Shelf / Restore
    function SongLibrary({
      songs,
      activeCount,
      coldCount,
      libraryTab,
      onSetLibraryTab,
      onAddSong,
      onDeleteSong,
      onShelfSong,
      onRestoreSong,
      onExportCSV,
      onImportCSVRobust,
      onOpenImportModal,
      onDownloadSampleCSV,
      onClearAll,
      latestImport
    }) {
      const [form, setForm] = useState({ title: '', artist: '', duration: '', style: 'midtempo', key: '', bpm: '' });

      const handleAdd = () => {
        if (!form.title || !form.artist || !form.duration) return;
        onAddSong(form);
        setForm({ title: '', artist: '', duration: '', style: 'midtempo', key: '', bpm: '' });
      };

      const visibleSongs = useMemo(() => {
        const tab = libraryTab || 'active';
        return songs.filter(s => ((s.status || 'active') === tab));
      }, [songs, libraryTab]);

      return (
        <div className="panel">
          <div className="panel-header">
            <h3 className="panel-title">
              Song Library (Active {activeCount} • Cold {coldCount})
            </h3>
            <div className="toolbar">
              <button
                className={`btn btn-small ${libraryTab === 'active' ? 'btn-toggle-active' : ''}`}
                onClick={() => onSetLibraryTab('active')}
              >
                Active
              </button>
              <button
                className={`btn btn-small ${libraryTab === 'cold' ? 'btn-toggle-active' : ''}`}
                onClick={() => onSetLibraryTab('cold')}
              >
                Cold
              </button>
            </div>
          </div>

          <div className="input-group">
            <label>Title*</label>
            <input value={form.title} onChange={e => setForm({ ...form, title: e.target.value })} placeholder="Enter song title" />
          </div>

          <div className="input-group">
            <label>Artist*</label>
            <input value={form.artist} onChange={e => setForm({ ...form, artist: e.target.value })} placeholder="Enter artist name" />
          </div>

          <div className="set-config">
            <div className="input-group">
              <label>Duration*</label>
              <input value={form.duration} onChange={e => setForm({ ...form, duration: e.target.value })} placeholder="4.5" />
            </div>
            <div className="input-group">
              <label>Style</label>
              <select value={form.style} onChange={e => setForm({ ...form, style: e.target.value })}>
                <option value="ballad">Ballad</option>
                <option value="uptempo">Uptempo</option>
                <option value="midtempo">Midtempo</option>
                <option value="funk">Funk</option>
                <option value="shuffle">Shuffle</option>
                <option value="swing">Swing</option>
                <option value="groove">Groove</option>
              </select>
            </div>
          </div>

          <div className="set-config">
            <div className="input-group">
              <label>Key</label>
              <input value={form.key} onChange={e => setForm({ ...form, key: e.target.value })} placeholder="C" />
            </div>
            <div className="input-group">
              <label>BPM</label>
              <input value={form.bpm} onChange={e => setForm({ ...form, bpm: e.target.value })} placeholder="120" />
            </div>
          </div>

          <button className="btn btn-primary" onClick={handleAdd} style={{ width: '100%', marginBottom: '1rem' }}>
            Add Song (to Active)
          </button>

          <div className="toolbar" style={{ marginBottom: '1rem' }}>
            <label className="btn btn-small" style={{ margin: 0, cursor: 'pointer' }}>
              Quick Import
              <input type="file" accept=".csv,.pdf,.txt" onChange={onImportCSVRobust} style={{ display: 'none' }} />
            </label>
            <button className="btn btn-small" onClick={onOpenImportModal} style={{ borderColor: 'var(--accent)', color: 'var(--accent)' }}>Import + Normalize</button>
            <button className="btn btn-small" onClick={onExportCSV} disabled={songs.length === 0}>Export CSV</button>
            <button className="btn btn-small" onClick={onDownloadSampleCSV}>Sample CSV</button>
            <button className="btn btn-small" onClick={onClearAll} disabled={songs.length === 0}>Clear All</button>
          </div>

          {latestImport && (
            <div className="alert alert-success">
              ✅ Imported {latestImport.count} songs on {new Date(latestImport.ts).toLocaleString()}
            </div>
          )}

          <div className="song-list">
            {visibleSongs.length === 0 ? (
              <div style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '2rem 1rem' }}>
                {libraryTab === 'active'
                  ? 'No Active songs yet. Add manually or import CSV.'
                  : 'Cold List is empty.'}
              </div>
            ) : (
              visibleSongs.map(song => (
                <div key={song.id} className="song-item">
                  <div>
                    <div className="song-title">{song.title}</div>
                    <div className="song-meta">
                      <span>{song.artist}</span>
                      <span className={`song-badge style-${song.style}`}>{song.style}</span>
                      <span>{parseDuration(song.duration)}min</span>
                      {song.key && <span>{song.key}</span>}
                      {song.bpm && <span>{song.bpm}bpm</span>}
                    </div>
                  </div>
                  <div className="toolbar" style={{ justifyContent: 'flex-end' }}>
                    {(song.status || 'active') === 'active' ? (
                      <button className="btn btn-small" onClick={() => onShelfSong(song.id)} title="Move to Cold List">🧊 Shelf</button>
                    ) : (
                      <button className="btn btn-small" onClick={() => onRestoreSong(song.id)} title="Restore to Active">🔥 Restore</button>
                    )}
                    <button className="btn btn-small" onClick={() => onDeleteSong(song.id)}>Delete</button>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      );
    }

    function SetConfiguration({ settings, onChange, onGenerate, onCopy, onExportPDF, songCount, libraryTime, watermarkImg, onWatermarkUpload, onClearWatermark, activeSongs }) {
      return (
        <div className="panel">
          <div className="panel-header">
            <h3 className="panel-title">Setlist Configuration</h3>
          </div>

          <div className="set-config">
            <div className="input-group">
              <label>Number of Sets</label>
              <input type="number" min="1" max="10" value={settings.numSets}
                onChange={e => onChange({ ...settings, numSets: parseInt(e.target.value) || 1 })} />
            </div>
            <div className="input-group">
              <label>Set Duration (min)</label>
              <input type="number" min="15" max="180" value={settings.setDuration}
                onChange={e => onChange({ ...settings, setDuration: parseInt(e.target.value) || 45 })} />
            </div>
          </div>

          <div className="input-group">
            <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
              <input type="checkbox" checked={settings.allowSongReuse}
                onChange={e => onChange({ ...settings, allowSongReuse: e.target.checked })}
                style={{ width: 'auto' }} />
              Allow Song Reuse Across Sets
            </label>
          </div>

          <div className="input-group">
            <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
              <input type="checkbox" checked={settings.useEnergyCurve}
                onChange={e => onChange({ ...settings, useEnergyCurve: e.target.checked })}
                style={{ width: 'auto' }} />
              Energy Curve Optimization
            </label>
          </div>

          <div className="set-config">
            <div className="input-group">
              <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
                <input type="checkbox" checked={settings.forceOpener}
                  onChange={e => onChange({ ...settings, forceOpener: e.target.checked })}
                  style={{ width: 'auto' }} />
                Force Opener
              </label>
            </div>
            <div className="input-group">
              <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
                <input type="checkbox" checked={settings.forceCloser}
                  onChange={e => onChange({ ...settings, forceCloser: e.target.checked })}
                  style={{ width: 'auto' }} />
                Force Closer
              </label>
            </div>
          </div>

          {/* Locked Openers Selection */}
          {settings.forceOpener && (
            <div className="input-group" style={{ marginTop: '.5rem' }}>
              <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
                Locked Set Openers ({(settings.lockedOpeners || []).length} selected)
              </label>
              <select
                value=""
                onChange={e => {
                  if (!e.target.value) return;
                  const id = e.target.value;
                  const current = settings.lockedOpeners || [];
                  if (!current.includes(id)) {
                    onChange({ ...settings, lockedOpeners: [...current, id] });
                  }
                }}
                style={{ fontSize: '.8rem' }}
              >
                <option value="">+ Add a locked opener...</option>
                {(activeSongs || []).filter(s => !(settings.lockedOpeners || []).includes(s.id)).map(s => (
                  <option key={s.id} value={s.id}>{s.title} - {s.artist}</option>
                ))}
              </select>
              {(settings.lockedOpeners || []).length > 0 && (
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '.3rem', marginTop: '.3rem' }}>
                  {(settings.lockedOpeners || []).map(id => {
                    const song = (activeSongs || []).find(s => s.id === id);
                    return song ? (
                      <span key={id} style={{ display: 'inline-flex', alignItems: 'center', gap: '.25rem', background: 'var(--primary)', border: '1px solid var(--success)', borderRadius: '6px', padding: '.2rem .5rem', fontSize: '.75rem', color: 'var(--success)' }}>
                        {song.title}
                        <span style={{ cursor: 'pointer', opacity: 0.7 }} onClick={() => onChange({ ...settings, lockedOpeners: (settings.lockedOpeners || []).filter(x => x !== id) })}>x</span>
                      </span>
                    ) : null;
                  })}
                </div>
              )}
            </div>
          )}

          {/* Locked Closers Selection */}
          {settings.forceCloser && (
            <div className="input-group" style={{ marginTop: '.5rem' }}>
              <label style={{ textTransform: 'none', fontSize: '.75rem' }}>
                Locked Set Closers ({(settings.lockedClosers || []).length} selected)
              </label>
              <select
                value=""
                onChange={e => {
                  if (!e.target.value) return;
                  const id = e.target.value;
                  const current = settings.lockedClosers || [];
                  if (!current.includes(id)) {
                    onChange({ ...settings, lockedClosers: [...current, id] });
                  }
                }}
                style={{ fontSize: '.8rem' }}
              >
                <option value="">+ Add a locked closer...</option>
                {(activeSongs || []).filter(s => !(settings.lockedClosers || []).includes(s.id)).map(s => (
                  <option key={s.id} value={s.id}>{s.title} - {s.artist}</option>
                ))}
              </select>
              {(settings.lockedClosers || []).length > 0 && (
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '.3rem', marginTop: '.3rem' }}>
                  {(settings.lockedClosers || []).map(id => {
                    const song = (activeSongs || []).find(s => s.id === id);
                    return song ? (
                      <span key={id} style={{ display: 'inline-flex', alignItems: 'center', gap: '.25rem', background: 'var(--primary)', border: '1px solid var(--ballad)', borderRadius: '6px', padding: '.2rem .5rem', fontSize: '.75rem', color: 'var(--ballad)' }}>
                        {song.title}
                        <span style={{ cursor: 'pointer', opacity: 0.7 }} onClick={() => onChange({ ...settings, lockedClosers: (settings.lockedClosers || []).filter(x => x !== id) })}>x</span>
                      </span>
                    ) : null;
                  })}
                </div>
              )}
            </div>
          )}


{/* PHASE 3B: Tonal Gravity */}
<div style={{ 
  marginTop: '1rem', 
  paddingTop: '1rem', 
  borderTop: '1px solid var(--border)' 
}}>
  <div className="input-group">
    <label style={{ 
      display: 'flex', 
      alignItems: 'center', 
      gap: '.5rem', 
      cursor: 'pointer', 
      textTransform: 'none' 
    }}>
      <input
        type="checkbox"
        checked={!!settings.useTonalGravity}
        onChange={e => onChange({ ...settings, useTonalGravity: e.target.checked })}
        style={{ width: 'auto' }}
      />
      🎵 Tonal Gravity (Circle of Fifths)
    </label>
  </div>

  {settings.useTonalGravity && (
    <div style={{ marginTop: '.5rem' }}>
      <div className="input-group">
        <label style={{ textTransform: 'none' }}>
          Tonal Smoothness: {settings.tonalSmoothness ?? 70}
        </label>
        <input
          type="range"
          min="0"
          max="100"
          value={settings.tonalSmoothness ?? 70}
          onChange={e => onChange({ ...settings, tonalSmoothness: parseInt(e.target.value, 10) || 0 })}
        />
        <div style={{ fontSize: '.8rem', color: 'var(--text-muted)', marginTop: '.25rem' }}>
          {(settings.tonalSmoothness ?? 70) > 70 ? 'Smooth' :
           (settings.tonalSmoothness ?? 70) > 50 ? 'Balanced' : 'Contrast'}
        </div>
      </div>

      <div className="set-config">
        <div className="input-group">
          <label style={{ textTransform: 'none' }}>Anchor Key</label>
          <select
            value={settings.anchorKey || ''}
            onChange={e => onChange({ ...settings, anchorKey: e.target.value })}
          >
            <option value="">Auto-detect</option>
            <option value="C">C</option><option value="G">G</option><option value="D">D</option><option value="A">A</option>
            <option value="E">E</option><option value="B">B</option><option value="F#">F#</option>
            <option value="F">F</option><option value="Bb">Bb</option><option value="Eb">Eb</option>
            <option value="Ab">Ab</option><option value="Db">Db</option>
          </select>
        </div>

        <div className="input-group">
          <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', textTransform: 'none' }}>
            <input
              type="checkbox"
              checked={!!settings.showDetailedDiagnostics}
              onChange={e => onChange({ ...settings, showDetailedDiagnostics: e.target.checked })}
              style={{ width: 'auto' }}
            />
            Detailed diagnostics
          </label>
        </div>
      </div>
    </div>
  )}
</div>

          <button className="btn btn-primary" onClick={onGenerate} disabled={songCount === 0} style={{ width: '100%', marginTop: '.5rem' }}>
            Generate Setlists
          </button>

          <div className="toolbar" style={{ marginTop: '1rem' }}>
            <button className="btn btn-small" onClick={onCopy}>Copy Text</button>
            <button className="btn btn-small" onClick={onExportPDF}>Export PDF</button>
          </div>

          <div style={{ marginTop: '.75rem', padding: '.5rem', background: 'var(--primary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
            <div style={{ fontSize: '.75rem', fontWeight: 600, textTransform: 'uppercase', letterSpacing: '.05em', color: 'var(--text-muted)', marginBottom: '.4rem' }}>
              PDF Watermark
            </div>
            {watermarkImg ? (
              <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>
                <img src={watermarkImg} alt="Watermark" style={{ width: 40, height: 40, objectFit: 'contain', borderRadius: 4, opacity: 0.7 }} />
                <span style={{ fontSize: '.8rem', color: 'var(--text-muted)', flex: 1 }}>Watermark set</span>
                <button className="btn btn-small" onClick={onClearWatermark} style={{ fontSize: '.7rem' }}>Remove</button>
              </div>
            ) : (
              <label style={{ display: 'flex', alignItems: 'center', gap: '.5rem', cursor: 'pointer', fontSize: '.8rem', color: 'var(--text-muted)' }}>
                <input type="file" accept="image/*" onChange={onWatermarkUpload} style={{ display: 'none' }} />
                <span className="btn btn-small" style={{ fontSize: '.7rem' }}>Upload Image</span>
                <span>No watermark</span>
              </label>
            )}
          </div>

          <div style={{ marginTop: '1rem', fontSize: '.85rem', color: 'var(--text-muted)' }}>
            Active Library: {songCount} songs • {Math.round(libraryTime)} min total
          </div>
        </div>
      );
    }

    function SetlistView({ setIdx, setlist, locked, setLocked: setLockedSet, onToggleLock, onSwap, onMoveSong, onRemoveSong, onLockEntireSet, onDragStart, onDragEnd, onDragOverSong, onDragOverSet, onDropOnSong, onDropOnSet, onMoveToSet, dragState, totalSets }) {
      let runningTime = 0;
      const allLocked = setlist.songs.length > 0 && setlist.songs.every(s => locked.has(`${setIdx}:${s.id}`));
      const isSetDragTarget = dragState && dragState.active && dragState.overSetIdx === setIdx && dragState.fromSetIdx !== setIdx;

      return (
        <div
          className={`setlist${isSetDragTarget ? ' drag-target' : ''}`}
          onDragOver={(e) => onDragOverSet(e, setIdx)}
          onDragEnter={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }}
          onDrop={(e) => onDropOnSet(e, setIdx)}
        >
          <div className="setlist-header">
            <div>
              <h4>{setlist.name}</h4>
              <div style={{ fontSize: '.85rem', color: 'var(--text-muted)' }}>
                {setlist.songs.length} songs • {Math.round(setlist.totalTime)} min
              </div>
            </div>
            <div style={{ display: 'flex', gap: '.4rem', alignItems: 'center' }}>
              <button
                className={`btn btn-small ${allLocked ? 'btn-toggle-active' : ''}`}
                onClick={() => onLockEntireSet(setIdx, !allLocked)}
                title={allLocked ? 'Unlock entire set' : 'Lock entire set'}
                style={allLocked ? { borderColor: 'var(--locked)', color: 'var(--locked)' } : {}}
              >
                {allLocked ? 'Unlock Set' : 'Lock Set'}
              </button>
            </div>
          </div>

          {setlist.songs.map((song, songIdx) => {
            const startTime = runningTime;
            runningTime += Number(song.duration) || 0;
            const isLocked = locked.has(`${setIdx}:${song.id}`);
            const isDragging = dragState && dragState.active && dragState.fromSetIdx === setIdx && dragState.fromSongIdx === songIdx;
            const isOver = dragState && dragState.active && dragState.overSetIdx === setIdx && dragState.overSongIdx === songIdx;

            let dragClass = '';
            if (isDragging) dragClass = 'dragging';
            if (isOver) dragClass += ' drag-over-bottom';

            return (
              <div
                key={`${song.id}-${songIdx}`}
                className={`setlist-song ${isLocked ? 'locked' : ''} ${dragClass}`}
                draggable={!isLocked}
                onDragStart={(e) => onDragStart(e, song, setIdx, songIdx)}
                onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); }}
                onDragOver={(e) => onDragOverSong(e, setIdx, songIdx)}
                onDrop={(e) => onDropOnSong(e, setIdx, songIdx)}
                onDragEnd={onDragEnd}
              >
                <div className="drag-handle" title={isLocked ? 'Locked - cannot drag' : 'Drag to reorder or move to another set'}>
                  {isLocked ? '' : '⠿'}
                </div>
                <div className="song-number">{songIdx + 1}</div>
                <div>
                  <div className="song-title">{song.title}</div>
                  <div className="song-meta">
                    <span>{song.artist}</span>
                    <span className={`song-badge style-${song.style}`}>{song.style}</span>
                    <span>{parseDuration(song.duration)}min</span>
                    {song.key && <span style={{ fontSize: '.7rem', color: 'var(--text-muted)' }}>{song.key}</span>}
                  </div>
                </div>
                <div className="song-time">+{Math.round(startTime)}m</div>
                <div className="song-actions">
                  {totalSets > 1 && !isLocked && (
                    <select
                      className="move-to-set-select"
                      value=""
                      onChange={(e) => { if (e.target.value !== '') onMoveToSet(setIdx, songIdx, Number(e.target.value)); }}
                      title="Move to another set"
                    >
                      <option value="" disabled>Set</option>
                      {Array.from({ length: totalSets }, (_, i) => i).filter(i => i !== setIdx).map(i => (
                        <option key={i} value={i}>Set {i + 1}</option>
                      ))}
                    </select>
                  )}
                  <button className={`action-btn ${isLocked ? 'locked' : ''}`} onClick={() => onToggleLock(setIdx, song.id)} title={isLocked ? 'Unlock' : 'Lock'}>
                    {isLocked ? '🔒' : '🔓'}
                  </button>
                  <button className="action-btn" onClick={() => onRemoveSong(setIdx, songIdx)} title="Remove (send to Cold List)" style={{ color: 'var(--error)' }}>
                    ✕
                  </button>
                </div>
              </div>
            );
          })}

          {dragState && dragState.active && dragState.fromSetIdx !== setIdx && (
            <div
              className="drop-zone-between"
              onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('drag-over'); }}
              onDragLeave={(e) => { e.currentTarget.classList.remove('drag-over'); }}
              onDrop={(e) => { e.currentTarget.classList.remove('drag-over'); onDropOnSet(e, setIdx); }}
            >
              Drop here to add to {setlist.name}
            </div>
          )}
        </div>
      );
    }

    /******************* IMPORT SONGS MODAL *******************/
    function ImportSongsModal({ open, onClose, onImport, existingSongs }) {
      const STEPS = ["input", "map", "normalize", "import"];
      const STEP_LABELS = { input: "1. Input", map: "2. Map Columns", normalize: "3. Review", import: "4. Import" };

      const [step, setStep] = useState("input");
      const [inputTab, setInputTab] = useState("upload");
      const [rawText, setRawText] = useState("");
      const [fileName, setFileName] = useState("");
      const [hasHeaders, setHasHeaders] = useState(true);
      const [delimiter, setDelimiter] = useState("auto");

      // Parsed data
      const [parsedColumns, setParsedColumns] = useState([]);
      const [parsedRows, setParsedRows] = useState([]);

      // Mapping
      const [mapping, setMapping] = useState({ titleCol: null, keyCol: null, tempoCol: null, vocalistCol: null });
      const [confidences, setConfidences] = useState({});

      // Options
      const [opts, setOpts] = useState({
        trimWhitespace: true, normalizeKeys: true, normalizeTempo: true, normalizeVocalist: true,
        stripMetaParen: false, defaultTempo: null, defaultVocalist: "ALL"
      });

      // Results
      const [normalizedResult, setNormalizedResult] = useState(null);
      const [dragover, setDragover] = useState(false);

      if (!open) return null;

      const reset = () => {
        setStep("input"); setInputTab("upload"); setRawText(""); setFileName("");
        setHasHeaders(true); setDelimiter("auto");
        setParsedColumns([]); setParsedRows([]);
        setMapping({ titleCol: null, keyCol: null, tempoCol: null, vocalistCol: null });
        setConfidences({});
        setNormalizedResult(null);
      };

      const handleClose = () => { reset(); onClose(); };

      const parseText = (text, fname) => {
        if (!text || !text.trim()) return;
        const effectiveDelimiter = delimiter === "auto" ? importDetectDelimiter(text) : delimiter;
        const result = Papa.parse(text, {
          delimiter: effectiveDelimiter, header: hasHeaders, skipEmptyLines: "greedy", dynamicTyping: false
        });
        if (!result.data || result.data.length === 0) return;

        let columns, rows;
        if (hasHeaders && result.meta && result.meta.fields) {
          columns = result.meta.fields;
          rows = result.data;
        } else {
          const maxCols = result.data.reduce((max, row) => Math.max(max, Array.isArray(row) ? row.length : 0), 0);
          columns = Array.from({ length: maxCols }, (_, i) => `Column ${i + 1}`);
          rows = result.data.map(row => {
            if (Array.isArray(row)) {
              const obj = {};
              columns.forEach((c, i) => obj[c] = row[i] ?? "");
              return obj;
            }
            return row;
          });
        }

        setParsedColumns(columns);
        setParsedRows(rows);
        if (fname) setFileName(fname);

        // Auto-map
        const autoMap = importAutoMapColumns(columns);
        setMapping(autoMap.mapping);
        setConfidences(autoMap.confidences);
        setStep("map");
      };

      const handleFileUpload = async (file) => {
        if (!file) return;

        // PDF handling
        if (file.name.toLowerCase().endsWith('.pdf') || file.type === 'application/pdf') {
          try {
            const arrayBuffer = await file.arrayBuffer();
            const pageTexts = await pdfExtractText(arrayBuffer);
            const songs = pdfParseAllPages(pageTexts);
            if (songs.length === 0) {
              alert('No song data found in PDF. The PDF may not be in a recognized format.');
              return;
            }
            // Convert to CSV and feed into existing pipeline
            const csvText = pdfSongsToCSV(songs);
            parseText(csvText, file.name);
          } catch (err) {
            console.error('PDF parse error:', err);
            alert('Failed to parse PDF: ' + (err.message || 'Unknown error'));
          }
          return;
        }

        // Regular text/CSV handling
        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target?.result;
          if (text) parseText(String(text), file.name);
        };
        reader.readAsText(file);
      };

      const handleDrop = (e) => {
        e.preventDefault(); setDragover(false);
        const file = e.dataTransfer?.files?.[0];
        if (file) handleFileUpload(file);
      };

      const runNormalization = () => {
        if (mapping.titleCol == null) return;
        // Convert column indices to column names
        const colMapping = {
          titleCol: parsedColumns[mapping.titleCol],
          keyCol: mapping.keyCol != null ? parsedColumns[mapping.keyCol] : null,
          tempoCol: mapping.tempoCol != null ? parsedColumns[mapping.tempoCol] : null,
          vocalistCol: mapping.vocalistCol != null ? parsedColumns[mapping.vocalistCol] : null
        };
        const result = importNormalizeAll(parsedRows, colMapping, opts);
        setNormalizedResult(result);
        setStep("normalize");
      };

      const handleImport = () => {
        if (!normalizedResult || normalizedResult.rows.length === 0) return;
        onImport(normalizedResult.rows, normalizedResult.report);
        handleClose();
      };

      const downloadCanonicalCSV = () => {
        if (!normalizedResult) return;
        const csv = importToCanonicalCSV(normalizedResult.rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `canonical-import-${new Date().toISOString().slice(0, 10)}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
      };

      const stepIndex = STEPS.indexOf(step);
      const sampleRows = parsedRows.slice(0, 5);

      const WARNING_LABELS = {
        multi_key_first_selected: "Multiple keys found, used first valid",
        key_invalid: "Key could not be recognized",
        tempo_range_first_selected: "Tempo range found, used first value",
        tempo_out_of_range: "Tempo out of range (1-300)",
        tempo_default_applied: "Default tempo applied",
        vocalist_default_all: "Empty vocalist defaulted to ALL",
        multi_vocalist_first_selected: "Multiple vocalists, used first",
        title_trimmed: "Title whitespace trimmed",
        title_smart_punct: "Smart punctuation converted",
        title_meta_paren_stripped: "Meta parenthetical stripped"
      };

      return (
        <div className="modal-backdrop" onClick={handleClose}>
          <div className="import-modal" onClick={(e) => e.stopPropagation()}>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: ".75rem" }}>
              <h3 className="panel-title">Import Songs</h3>
              <button className="btn btn-small" onClick={handleClose}>Close</button>
            </div>

            {/* Step indicators */}
            <div className="import-steps">
              {STEPS.map((s, i) => (
                <div key={s} className={`import-step ${s === step ? "active" : ""} ${i < stepIndex ? "completed" : ""}`}>
                  {STEP_LABELS[s]}
                </div>
              ))}
            </div>

            {/* STEP 1: INPUT */}
            {step === "input" && (
              <div>
                <div className="import-tabs">
                  <button className={`import-tab ${inputTab === "upload" ? "active" : ""}`} onClick={() => setInputTab("upload")}>Upload File</button>
                  <button className={`import-tab ${inputTab === "paste" ? "active" : ""}`} onClick={() => setInputTab("paste")}>Paste Text</button>
                </div>

                {inputTab === "upload" && (
                  <div
                    className={`import-drop-zone ${dragover ? "dragover" : ""}`}
                    onDragOver={(e) => { e.preventDefault(); setDragover(true); }}
                    onDragLeave={() => setDragover(false)}
                    onDrop={handleDrop}
                    onClick={() => document.getElementById("import-file-input")?.click()}
                  >
                    <div style={{ fontSize: "2rem", marginBottom: ".5rem" }}>Drop file here or click to browse</div>
                    <div style={{ fontSize: ".85rem" }}>Supports CSV, TSV, TXT, and PDF</div>
                    <input id="import-file-input" type="file" accept=".csv,.tsv,.txt,.tab,.pdf" onChange={(e) => handleFileUpload(e.target.files?.[0])} />
                  </div>
                )}

                {inputTab === "paste" && (
                  <div>
                    <textarea
                      className="import-textarea"
                      placeholder={"Paste your song data here...\n\nExamples:\ntitle,key,tempo,vocalist\nCome Together,Dm,82,John\nSweet Home Alabama,D,100,ALL"}
                      value={rawText}
                      onChange={(e) => setRawText(e.target.value)}
                    />
                    <div className="import-footer">
                      <button className="btn btn-primary" onClick={() => parseText(rawText, "pasted-text")} disabled={!rawText.trim()}>
                        Parse Text
                      </button>
                    </div>
                  </div>
                )}

                <div className="set-config" style={{ marginTop: ".75rem" }}>
                  <div className="input-group">
                    <label>Delimiter</label>
                    <select value={delimiter} onChange={(e) => setDelimiter(e.target.value)}>
                      <option value="auto">Auto-detect</option>
                      <option value=",">Comma (,)</option>
                      <option value="&#9;">Tab</option>
                      <option value="|">Pipe (|)</option>
                      <option value=";">Semicolon (;)</option>
                    </select>
                  </div>
                  <div className="input-group">
                    <label style={{ display: "flex", alignItems: "center", gap: ".5rem" }}>
                      <input type="checkbox" checked={hasHeaders} onChange={(e) => setHasHeaders(e.target.checked)} style={{ width: "auto" }} />
                      First row is headers
                    </label>
                  </div>
                </div>
              </div>
            )}

            {/* STEP 2: MAP COLUMNS */}
            {step === "map" && (
              <div>
                <div style={{ marginBottom: ".75rem", fontSize: ".85rem", color: "var(--text-muted)" }}>
                  Parsed <strong style={{ color: "var(--accent)" }}>{parsedRows.length}</strong> rows with <strong style={{ color: "var(--accent)" }}>{parsedColumns.length}</strong> columns
                  {fileName && <span> from <strong>{fileName}</strong></span>}
                </div>

                {/* Preview table */}
                <div style={{ overflowX: "auto" }}>
                  <table className="import-preview-table">
                    <thead>
                      <tr>{parsedColumns.map((c, i) => <th key={i}>{c}</th>)}</tr>
                    </thead>
                    <tbody>
                      {sampleRows.map((row, ri) => (
                        <tr key={ri}>{parsedColumns.map((c, ci) => <td key={ci}>{String(row[c] ?? "")}</td>)}</tr>
                      ))}
                    </tbody>
                  </table>
                </div>

                {/* Column mapping */}
                <h4 style={{ color: "var(--accent)", margin: ".75rem 0 .5rem", fontSize: ".9rem" }}>Column Mapping</h4>
                <div className="import-mapping-grid">
                  {[
                    { key: "titleCol", label: "Title *", required: true },
                    { key: "keyCol", label: "Key" },
                    { key: "tempoCol", label: "Tempo / BPM" },
                    { key: "vocalistCol", label: "Vocalist" }
                  ].map(({ key, label, required }) => (
                    <div key={key} className="import-mapping-item">
                      <label>
                        {label}
                        {confidences[key] && <span className="confidence">{confidences[key]}% match</span>}
                      </label>
                      <select
                        value={mapping[key] ?? "none"}
                        onChange={(e) => setMapping({ ...mapping, [key]: e.target.value === "none" ? null : parseInt(e.target.value) })}
                      >
                        <option value="none">{required ? "-- Select --" : "None"}</option>
                        {parsedColumns.map((c, i) => <option key={i} value={i}>{c}</option>)}
                      </select>
                    </div>
                  ))}
                </div>

                {/* Normalization options */}
                <h4 style={{ color: "var(--accent)", margin: ".75rem 0 .5rem", fontSize: ".9rem" }}>Normalization Options</h4>
                <div className="import-options">
                  {[
                    { key: "normalizeKeys", label: "Normalize keys (Cmaj -> C)" },
                    { key: "normalizeTempo", label: "Normalize tempo" },
                    { key: "normalizeVocalist", label: "Normalize vocalist" },
                    { key: "stripMetaParen", label: "Strip meta parens e.g. (demo)" }
                  ].map(({ key, label }) => (
                    <label key={key} className="import-option">
                      <input type="checkbox" checked={opts[key]} onChange={(e) => setOpts({ ...opts, [key]: e.target.checked })} />
                      {label}
                    </label>
                  ))}
                </div>

                <div className="set-config" style={{ marginTop: ".5rem" }}>
                  <div className="input-group">
                    <label>Default Tempo (blank = none)</label>
                    <input
                      type="number" min="1" max="300" placeholder="e.g. 120"
                      value={opts.defaultTempo ?? ""}
                      onChange={(e) => setOpts({ ...opts, defaultTempo: e.target.value ? parseInt(e.target.value) : null })}
                    />
                  </div>
                  <div className="input-group">
                    <label>Default Vocalist</label>
                    <input
                      value={opts.defaultVocalist}
                      onChange={(e) => setOpts({ ...opts, defaultVocalist: e.target.value || "ALL" })}
                    />
                  </div>
                </div>

                <div className="import-footer">
                  <button className="btn btn-small" onClick={() => { setStep("input"); }}>Back</button>
                  <button className="btn btn-primary" onClick={runNormalization} disabled={mapping.titleCol == null}>
                    Normalize & Preview
                  </button>
                </div>
              </div>
            )}

            {/* STEP 3: NORMALIZE / REVIEW */}
            {step === "normalize" && normalizedResult && (
              <div>
                {/* Guardrail banner */}
                <div className="import-guardrail">
                  Nothing is silently dropped. Only rows with empty titles are rejected. All other rows are imported even if key/tempo/vocalist are blank.
                </div>

                {/* Summary stats */}
                <div className="import-results-summary">
                  <div className="import-stat success">
                    <div className="number">{normalizedResult.report.rowsParsed}</div>
                    <div className="label">Rows Parsed</div>
                  </div>
                  <div className="import-stat success">
                    <div className="number">{normalizedResult.report.rowsImported}</div>
                    <div className="label">Will Import</div>
                  </div>
                  <div className={`import-stat ${normalizedResult.report.rowsRejected > 0 ? "error" : "success"}`}>
                    <div className="number">{normalizedResult.report.rowsRejected}</div>
                    <div className="label">Rejected</div>
                  </div>
                </div>

                {/* Equation check */}
                <div style={{ textAlign: "center", fontSize: ".8rem", color: "var(--text-muted)", margin: ".25rem 0 .75rem" }}>
                  {normalizedResult.report.rowsParsed} parsed = {normalizedResult.report.rowsImported} imported + {normalizedResult.report.rowsRejected} rejected
                  {normalizedResult.report.rowsParsed === normalizedResult.report.rowsImported + normalizedResult.report.rowsRejected
                    ? <span style={{ color: "var(--success)", marginLeft: ".5rem" }}>&#10003; Verified</span>
                    : <span style={{ color: "var(--error)", marginLeft: ".5rem" }}>Mismatch!</span>
                  }
                </div>

                {/* Warning counts */}
                {Object.keys(normalizedResult.report.warningCounts).length > 0 && (
                  <div>
                    <h4 style={{ color: "var(--warning)", fontSize: ".85rem", marginBottom: ".5rem" }}>Normalization Warnings</h4>
                    <div className="import-warnings-list">
                      {Object.entries(normalizedResult.report.warningCounts).map(([code, count]) => (
                        <div key={code} className="import-warning-item">
                          <span className="import-warning-code">{code}</span>
                          <span>{WARNING_LABELS[code] || code}</span>
                          <span style={{ marginLeft: "auto", color: "var(--accent)", fontWeight: 700 }}>x{count}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Sample changes */}
                {normalizedResult.report.sampleChanges.length > 0 && (
                  <div style={{ marginTop: ".75rem" }}>
                    <h4 style={{ color: "var(--accent)", fontSize: ".85rem", marginBottom: ".5rem" }}>
                      Sample Changes (showing {Math.min(normalizedResult.report.sampleChanges.length, 20)} of {normalizedResult.report.sampleChanges.length})
                    </h4>
                    <div style={{ maxHeight: "160px", overflowY: "auto" }}>
                      <table className="import-preview-table">
                        <thead><tr><th>Row</th><th>Field</th><th>Original</th><th>Normalized</th></tr></thead>
                        <tbody>
                          {normalizedResult.report.sampleChanges.slice(0, 20).flatMap((rc) =>
                            rc.changes.map((c, ci) => (
                              <tr key={`${rc.rowIndex}-${ci}`}>
                                <td>{rc.rowIndex}</td>
                                <td>{c.field}</td>
                                <td style={{ color: "var(--error)" }}>{c.original || "(empty)"}</td>
                                <td style={{ color: "var(--success)" }}>{c.normalized || "(empty)"}</td>
                              </tr>
                            ))
                          )}
                        </tbody>
                      </table>
                    </div>
                  </div>
                )}

                {/* Rejected rows */}
                {normalizedResult.rejected.length > 0 && (
                  <div style={{ marginTop: ".75rem" }}>
                    <h4 style={{ color: "var(--error)", fontSize: ".85rem", marginBottom: ".5rem" }}>
                      Rejected Rows ({normalizedResult.rejected.length})
                    </h4>
                    <table className="import-rejected-table">
                      <thead><tr><th>Row #</th><th>Reason</th><th>Raw Data</th></tr></thead>
                      <tbody>
                        {normalizedResult.rejected.map((r, i) => (
                          <tr key={i}>
                            <td>{r.rowIndex}</td>
                            <td>{r.reason}</td>
                            <td style={{ maxWidth: "300px", overflow: "hidden", textOverflow: "ellipsis" }}>
                              {JSON.stringify(r.raw).slice(0, 100)}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

                {/* Normalized data preview */}
                <div style={{ marginTop: ".75rem" }}>
                  <h4 style={{ color: "var(--accent)", fontSize: ".85rem", marginBottom: ".5rem" }}>
                    Import Preview (first 10 rows)
                  </h4>
                  <div style={{ overflowX: "auto" }}>
                    <table className="import-preview-table">
                      <thead><tr><th>Title</th><th>Key</th><th>Tempo</th><th>Vocalist</th></tr></thead>
                      <tbody>
                        {normalizedResult.rows.slice(0, 10).map((r, i) => (
                          <tr key={i}>
                            <td>{r.title}</td>
                            <td>{r.key}</td>
                            <td>{r.tempo}</td>
                            <td>{r.vocalist}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>

                <div className="import-footer">
                  <button className="btn btn-small" onClick={() => setStep("map")}>Back</button>
                  <button className="btn btn-small" onClick={downloadCanonicalCSV}>Download Canonical CSV</button>
                  <button className="btn btn-primary" onClick={handleImport} disabled={normalizedResult.rows.length === 0}>
                    Import {normalizedResult.rows.length} Songs
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function BandModal({ open, onClose, bands, onCreate, onDelete, onDuplicate }) {
      const [form, setForm] = useState({ name: '', icon: '🎵', color: '#ff6b35' });
      if (!open) return null;

      const handleCreate = () => {
        if (!form.name.trim()) return;
        onCreate(form);
        setForm({ name: '', icon: '🎵', color: '#ff6b35' });
      };

      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal" onClick={e => e.stopPropagation()}>
            <div className="panel-header">
              <h3 className="panel-title">Manage Bands</h3>
              <button className="btn btn-small" onClick={onClose}>Close</button>
            </div>

            <div className="input-group">
              <label>Band Name</label>
              <input value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} placeholder="Enter band name" />
            </div>

            <div className="set-config">
              <div className="input-group">
                <label>Icon</label>
                <input value={form.icon} onChange={e => setForm({ ...form, icon: e.target.value })} placeholder="🎵" />
              </div>
              <div className="input-group">
                <label>Color</label>
                <input type="color" value={form.color} onChange={e => setForm({ ...form, color: e.target.value })} />
              </div>
            </div>

            <button className="btn btn-primary" onClick={handleCreate} style={{ width: '100%', marginBottom: '1rem' }}>
              Create Band
            </button>

            <div style={{ maxHeight: '300px', overflowY: 'auto' }}>
              {bands.map(band => (
                <div key={band.id} className="band-row">
                  <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>
                    <span style={{ fontSize: '1.2rem' }}>{band.icon}</span>
                    <div>
                      <div style={{ fontWeight: 600 }}>{band.name}</div>
                      <div className="band-id">{band.id}</div>
                    </div>
                    <span className="swatch" style={{ background: band.color, marginLeft: '.5rem', width: 12, height: 12, borderRadius: 999, border: '1px solid var(--border)' }}></span>
                  </div>
                  <div style={{ display: 'flex', gap: '.5rem' }}>
                    <button className="btn btn-small" onClick={() => onDuplicate(band)}>Duplicate</button>
                    <button className="btn btn-small" onClick={() => onDelete(band)}>Delete</button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    function PrintView({ setlists, watermarkImg }) {
      return (
        <div className="print-only">
          {setlists.map((set) => (
            <div key={set.id} className="set-page" style={{ position: 'relative' }}>
              {watermarkImg && (
                <div style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: '100%',
                  opacity: 0.12,
                  pointerEvents: 'none',
                  zIndex: 0
                }}>
                  <img src={watermarkImg} alt="" style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
                </div>
              )}
              <div style={{ position: 'relative', zIndex: 1, padding: '0.25in' }}>
                <div style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '20pt', fontWeight: 'bold', textTransform: 'uppercase', textDecoration: 'underline', marginBottom: '18px' }}>
                  {set.name}
                </div>
                <div style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '16pt', fontWeight: 'bold', marginBottom: '18px' }}>
                  {set.songs.length} songs | {Math.round(set.totalTime)} minutes
                </div>
                <div>
                  {set.songs.map((song, idx) => {
                    const meta = [];
                    if (song.key) meta.push(song.key);
                    if (song.bpm) meta.push(`${song.bpm} BPM`);
                    return (
                      <div key={`print-${song.id}-${idx}`} style={{ fontFamily: "'Oswald', 'Helvetica Neue', Arial, sans-serif", fontSize: '20pt', fontWeight: 'bold', lineHeight: 1.0, marginBottom: '8px' }}>
                        {idx + 1}. {song.title}{song.artist ? ` - ${song.artist}` : ''}{meta.length > 0 ? ` (${meta.join(' | ')})` : ''}
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          ))}
        </div>
      );
    }

    /******************* GIG PROFILES *******************/
    function GigProfileModal({ open, onClose, gigs, onCreateGig, onDeleteGig, onLoadGig, onSaveToGig, onExportGigCSV, setlists, bandName }) {
      const [form, setForm] = useState({
        name: '', venue: '', date: '', notes: '',
        // Venue info fields (common across GigSalad, Sonicbids, Bands in Town, Gigmit, etc.)
        venueCity: '', venueState: '', venueZip: '',
        venueType: '', // bar, club, festival, private, corporate, theater, outdoor
        venueCapacity: '',
        contactName: '', contactEmail: '', contactPhone: '',
        loadInTime: '', soundCheckTime: '', setStartTime: '',
        compensation: '', // flat fee, door split, percentage, etc.
        eventType: '', // wedding, corporate, festival, bar gig, private party
        ageRestriction: '', // all ages, 18+, 21+
        backlineProvided: false,
        paProvided: false
      });
      const [showVenueDetails, setShowVenueDetails] = useState(false);

      if (!open) return null;

      const handleCreate = () => {
        if (!form.name.trim()) return;
        onCreateGig(form);
        setForm({
          name: '', venue: '', date: '', notes: '',
          venueCity: '', venueState: '', venueZip: '',
          venueType: '', venueCapacity: '',
          contactName: '', contactEmail: '', contactPhone: '',
          loadInTime: '', soundCheckTime: '', setStartTime: '',
          compensation: '', eventType: '', ageRestriction: '',
          backlineProvided: false, paProvided: false
        });
      };

      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal" onClick={e => e.stopPropagation()} style={{ width: 'min(720px, 95vw)', maxHeight: '90vh', overflowY: 'auto' }}>
            <div className="panel-header">
              <h3 className="panel-title">Gig Profiles — {bandName}</h3>
              <button className="btn btn-small" onClick={onClose}>Close</button>
            </div>

            <div style={{ marginBottom: '1rem', fontSize: '.85rem', color: 'var(--text-muted)' }}>
              Create gig profiles for specific venues and dates. Save and load setlists for each gig. Export gig setlists as CSV.
            </div>

            {/* Basic Gig Info */}
            <div className="set-config">
              <div className="input-group">
                <label>Gig Name*</label>
                <input value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} placeholder="e.g. Friday at The Roxy" />
              </div>
              <div className="input-group">
                <label>Venue Name</label>
                <input value={form.venue} onChange={e => setForm({ ...form, venue: e.target.value })} placeholder="e.g. The Roxy" />
              </div>
            </div>
            <div className="set-config">
              <div className="input-group">
                <label>Date</label>
                <input type="date" value={form.date} onChange={e => setForm({ ...form, date: e.target.value })} />
              </div>
              <div className="input-group">
                <label>Event Type</label>
                <select value={form.eventType} onChange={e => setForm({ ...form, eventType: e.target.value })}>
                  <option value="">Select...</option>
                  <option value="bar_gig">Bar / Club Gig</option>
                  <option value="festival">Festival</option>
                  <option value="corporate">Corporate Event</option>
                  <option value="wedding">Wedding / Reception</option>
                  <option value="private_party">Private Party</option>
                  <option value="theater">Theater / Concert Hall</option>
                  <option value="outdoor">Outdoor Event</option>
                  <option value="house_concert">House Concert</option>
                  <option value="charity">Charity / Benefit</option>
                  <option value="other">Other</option>
                </select>
              </div>
            </div>

            {/* Expandable Venue Details */}
            <button
              className="btn btn-small"
              onClick={() => setShowVenueDetails(!showVenueDetails)}
              style={{ width: '100%', marginBottom: '.75rem', textAlign: 'left' }}
            >
              {showVenueDetails ? '▾' : '▸'} Venue Details &amp; Contact Info
            </button>

            {showVenueDetails && (
              <div style={{ background: 'var(--primary)', border: '1px solid var(--border)', borderRadius: '8px', padding: '.75rem', marginBottom: '.75rem' }}>
                <div className="set-config">
                  <div className="input-group">
                    <label>City</label>
                    <input value={form.venueCity} onChange={e => setForm({ ...form, venueCity: e.target.value })} placeholder="City" />
                  </div>
                  <div className="input-group">
                    <label>State/Region</label>
                    <input value={form.venueState} onChange={e => setForm({ ...form, venueState: e.target.value })} placeholder="State" />
                  </div>
                </div>
                <div className="set-config">
                  <div className="input-group">
                    <label>ZIP/Postal Code</label>
                    <input value={form.venueZip} onChange={e => setForm({ ...form, venueZip: e.target.value })} placeholder="ZIP" />
                  </div>
                  <div className="input-group">
                    <label>Venue Type</label>
                    <select value={form.venueType} onChange={e => setForm({ ...form, venueType: e.target.value })}>
                      <option value="">Select...</option>
                      <option value="bar">Bar / Pub</option>
                      <option value="club">Night Club</option>
                      <option value="restaurant">Restaurant</option>
                      <option value="theater">Theater</option>
                      <option value="arena">Arena / Stadium</option>
                      <option value="outdoor_amphitheater">Outdoor Amphitheater</option>
                      <option value="festival_grounds">Festival Grounds</option>
                      <option value="hotel_ballroom">Hotel / Ballroom</option>
                      <option value="community_center">Community Center</option>
                      <option value="private_residence">Private Residence</option>
                      <option value="winery_brewery">Winery / Brewery</option>
                      <option value="coffeehouse">Coffeehouse</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                </div>
                <div className="set-config">
                  <div className="input-group">
                    <label>Capacity</label>
                    <input value={form.venueCapacity} onChange={e => setForm({ ...form, venueCapacity: e.target.value })} placeholder="e.g. 200" />
                  </div>
                  <div className="input-group">
                    <label>Age Restriction</label>
                    <select value={form.ageRestriction} onChange={e => setForm({ ...form, ageRestriction: e.target.value })}>
                      <option value="">Select...</option>
                      <option value="all_ages">All Ages</option>
                      <option value="18+">18+</option>
                      <option value="21+">21+</option>
                    </select>
                  </div>
                </div>

                <div style={{ borderTop: '1px solid var(--border)', marginTop: '.5rem', paddingTop: '.5rem' }}>
                  <div style={{ fontSize: '.75rem', fontWeight: 600, color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '.05em', marginBottom: '.4rem' }}>Contact Info</div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Contact Name</label>
                      <input value={form.contactName} onChange={e => setForm({ ...form, contactName: e.target.value })} placeholder="Booking contact" />
                    </div>
                    <div className="input-group">
                      <label>Contact Email</label>
                      <input type="email" value={form.contactEmail} onChange={e => setForm({ ...form, contactEmail: e.target.value })} placeholder="email@venue.com" />
                    </div>
                  </div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Contact Phone</label>
                      <input value={form.contactPhone} onChange={e => setForm({ ...form, contactPhone: e.target.value })} placeholder="(555) 123-4567" />
                    </div>
                    <div className="input-group">
                      <label>Compensation</label>
                      <input value={form.compensation} onChange={e => setForm({ ...form, compensation: e.target.value })} placeholder="e.g. $500, door split" />
                    </div>
                  </div>
                </div>

                <div style={{ borderTop: '1px solid var(--border)', marginTop: '.5rem', paddingTop: '.5rem' }}>
                  <div style={{ fontSize: '.75rem', fontWeight: 600, color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '.05em', marginBottom: '.4rem' }}>Schedule &amp; Logistics</div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Load-In Time</label>
                      <input type="time" value={form.loadInTime} onChange={e => setForm({ ...form, loadInTime: e.target.value })} />
                    </div>
                    <div className="input-group">
                      <label>Sound Check</label>
                      <input type="time" value={form.soundCheckTime} onChange={e => setForm({ ...form, soundCheckTime: e.target.value })} />
                    </div>
                  </div>
                  <div className="set-config">
                    <div className="input-group">
                      <label>Set Start Time</label>
                      <input type="time" value={form.setStartTime} onChange={e => setForm({ ...form, setStartTime: e.target.value })} />
                    </div>
                    <div className="input-group" style={{ display: 'flex', gap: '.75rem', alignItems: 'flex-end' }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: '.4rem', cursor: 'pointer', textTransform: 'none', fontSize: '.8rem' }}>
                        <input type="checkbox" checked={form.backlineProvided} onChange={e => setForm({ ...form, backlineProvided: e.target.checked })} style={{ width: 'auto' }} />
                        Backline
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: '.4rem', cursor: 'pointer', textTransform: 'none', fontSize: '.8rem' }}>
                        <input type="checkbox" checked={form.paProvided} onChange={e => setForm({ ...form, paProvided: e.target.checked })} style={{ width: 'auto' }} />
                        PA Provided
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            )}

            <div className="input-group">
              <label>Notes</label>
              <textarea value={form.notes} onChange={e => setForm({ ...form, notes: e.target.value })} placeholder="Special requests, parking info, dress code..." rows={2} style={{ resize: 'vertical' }} />
            </div>

            <button className="btn btn-primary" onClick={handleCreate} style={{ width: '100%', marginBottom: '1rem' }}>
              Create Gig Profile
            </button>

            <div style={{ maxHeight: '350px', overflowY: 'auto' }}>
              {gigs.length === 0 ? (
                <div style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '1.5rem' }}>
                  No gig profiles yet. Create one above.
                </div>
              ) : (
                gigs.sort((a, b) => {
                  if (a.date && b.date) return a.date.localeCompare(b.date);
                  if (a.date) return -1;
                  if (b.date) return 1;
                  return (b.createdAt || 0) - (a.createdAt || 0);
                }).map(gig => (
                  <div key={gig.id} className="band-row" style={{ flexDirection: 'column', alignItems: 'stretch', gap: '.5rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <div style={{ flex: 1, minWidth: 0 }}>
                        <div style={{ fontWeight: 700 }}>{gig.name}</div>
                        <div style={{ fontSize: '.8rem', color: 'var(--text-muted)' }}>
                          {gig.venue && <span>{gig.venue}</span>}
                          {gig.venueCity && <span>, {gig.venueCity}</span>}
                          {gig.venueState && <span>, {gig.venueState}</span>}
                          {gig.date && <span> | {gig.date}</span>}
                          {gig.eventType && <span> | {gig.eventType.replace(/_/g, ' ')}</span>}
                          {gig.setlists && <span> | {gig.setlists.length} set(s)</span>}
                        </div>
                        {gig.setStartTime && <div style={{ fontSize: '.75rem', color: 'var(--accent)' }}>Start: {gig.setStartTime}</div>}
                        {gig.notes && <div style={{ fontSize: '.75rem', color: 'var(--text-muted)', fontStyle: 'italic', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{gig.notes}</div>}
                      </div>
                      <div style={{ display: 'flex', gap: '.3rem', flexShrink: 0, flexWrap: 'wrap', justifyContent: 'flex-end' }}>
                        {setlists.length > 0 && (
                          <button className="btn btn-small" onClick={() => onSaveToGig(gig.id)} style={{ borderColor: 'var(--success)', color: 'var(--success)' }}>
                            Save
                          </button>
                        )}
                        {gig.setlists && gig.setlists.length > 0 && (
                          <>
                            <button className="btn btn-small" onClick={() => onLoadGig(gig.id)} style={{ borderColor: 'var(--accent)', color: 'var(--accent)' }}>
                              Load
                            </button>
                            <button className="btn btn-small" onClick={() => onExportGigCSV(gig.id)} style={{ borderColor: 'var(--warning)', color: 'var(--warning)' }}>
                              CSV
                            </button>
                          </>
                        )}
                        <button className="btn btn-small" onClick={() => onDeleteGig(gig.id)}>Del</button>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      );
    }

    /******************* MAIN APP *******************/
    function App() {
      const [bands, setBands] = useState([]);
      const [activeBandId, setActiveBandId] = useState(null);

      const [songs, setSongs] = useState([]);
      const [settings, setSettings] = useState({ numSets: 2, setDuration: 45, allowSongReuse: false, useEnergyCurve: true, forceOpener: false, forceCloser: true, lockedOpeners: [], lockedClosers: [], useTonalGravity: false, tonalSmoothness: 70, anchorKey: '', showDetailedDiagnostics: false });
      const [setlists, setSetlists] = useState([]);
      const [locked, setLocked] = useState(new Set());
      // Cross-set drag-and-drop state
      const defaultDragState = { active: false, song: null, fromSetIdx: null, fromSongIdx: null, overSetIdx: null, overSongIdx: null };
      const [dragState, setDragState] = useState(defaultDragState);
      const [originalSetlists, setOriginalSetlists] = useState(null);

      const [bandModal, setBandModal] = useState(false);
      const [importModal, setImportModal] = useState(false);
      const [gigModal, setGigModal] = useState(false);
      const [toast, setToast] = useState(null);
      const [lastGenerationStats, setLastGenerationStats] = useState(null);
      const [imports, setImports] = useState([]);
      const [gigs, setGigs] = useState([]);
      const [watermarkImg, setWatermarkImg] = useState(null);

      // PHASE 3A: active/cold library tab
      const [libraryTab, setLibraryTab] = useState('active');

      const showToast = (message, type = 'success') => setToast({ message, type });

      const activeBand = useMemo(() => bands.find(b => b.id === activeBandId), [bands, activeBandId]);

      // PHASE 3A: derived active/cold
      const activeSongs = useMemo(() => songs.filter(s => (s.status || 'active') === 'active'), [songs]);
      const coldSongs = useMemo(() => songs.filter(s => (s.status || 'active') === 'cold'), [songs]);

      const activeLibraryTime = useMemo(
        () => activeSongs.reduce((sum, s) => sum + parseDuration(s.duration), 0),
        [activeSongs]
      );

      // LOAD BANDS FROM STORAGE
      useEffect(() => {
        const stored = LS.get(LS_KEYS.bands);
        if (stored && Array.isArray(stored) && stored.length > 0) {
          setBands(stored);
          const activeId = LS.get(LS_KEYS.active) || stored[0].id;
          setActiveBandId(activeId);
        } else {
          const defaultBand = {
            id: genId(),
            name: 'Default Band',
            icon: '🎵',
            color: '#ff6b35'
          };
          setBands([defaultBand]);
          setActiveBandId(defaultBand.id);
          LS.set(LS_KEYS.bands, [defaultBand]);
          LS.set(LS_KEYS.active, defaultBand.id);
        }
      }, []);

      // SAVE BANDS TO STORAGE
      useEffect(() => {
        if (bands.length > 0) LS.set(LS_KEYS.bands, bands);
      }, [bands]);

      // LOAD ACTIVE BAND DATA
      useEffect(() => {
        if (!activeBandId) return;

        const storedSongsRaw = LS.get(LS_KEYS.bandSongs(activeBandId)) || [];
        // PHASE 3A: normalize status for older data
        const normalizedSongs = storedSongsRaw.map(s => ({ ...s, status: (s.status || 'active') }));

        const storedSettings = LS.get(LS_KEYS.bandSettings(activeBandId)) || { numSets: 2, setDuration: 45, allowSongReuse: false, useEnergyCurve: true, forceOpener: false, forceCloser: true, lockedOpeners: [], lockedClosers: [], useTonalGravity: false, tonalSmoothness: 70, anchorKey: '', showDetailedDiagnostics: false };
        // Ensure backward compatibility for settings without locked opener/closer arrays
        if (!storedSettings.lockedOpeners) storedSettings.lockedOpeners = [];
        if (!storedSettings.lockedClosers) storedSettings.lockedClosers = [];
        const storedImports = LS.get(LS_KEYS.bandImports(activeBandId)) || [];
        const storedGigs = LS.get(LS_KEYS.bandGigs(activeBandId)) || [];
        const storedWatermark = LS.get(LS_KEYS.bandWatermark(activeBandId)) || null;

        setSongs(normalizedSongs);
        setSettings(storedSettings);
        setImports(storedImports);
        setGigs(storedGigs);
        setWatermarkImg(storedWatermark);

        setSetlists([]);
        setLocked(new Set());
        setLibraryTab('active');
      }, [activeBandId]);

      // SAVE ACTIVE BAND DATA
      useEffect(() => {
        if (activeBandId) LS.set(LS_KEYS.bandSongs(activeBandId), songs);
      }, [songs, activeBandId]);

      useEffect(() => {
        if (activeBandId) LS.set(LS_KEYS.bandSettings(activeBandId), settings);
      }, [settings, activeBandId]);

      // PHASE 2: Build lock plan from current setlists
      const buildLockPlanFromCurrentSetlists = () => {
        if (!setlists || setlists.length === 0 || locked.size === 0) return null;

        const plan = [];
        for (let setIdx = 0; setIdx < setlists.length; setIdx++) {
          const set = setlists[setIdx];
          if (!set) { plan.push([]); continue; }

          const lockedEntries = [];
          set.songs.forEach((song, idx) => {
            if (song && locked.has(`${setIdx}:${song.id}`)) {
              lockedEntries.push({ index: idx, song });
            }
          });
          plan.push(lockedEntries);
        }
        return plan;
      };

      const generate = () => {
        // PHASE 3A: generator uses ACTIVE only
        const lockPlan = buildLockPlanFromCurrentSetlists();
        const generatorFn = settings.useTonalGravity ? generateSetlistsCore_WithTonalGravity : generateSetlistsCore;
        const out = generatorFn(activeSongs, {
          ...settings,
          lockPlan: lockPlan || null
        });
        setSetlists(out);
        setLastGenerationStats(out.stats);

        const history = LS.get(LS_KEYS.bandHistory(activeBandId)) || [];
        const newEntry = { ts: Date.now(), settings, setlists: out };
        LS.set(LS_KEYS.bandHistory(activeBandId), [newEntry, ...history].slice(0, 50));

        if (out.generationWarnings && out.generationWarnings.length) {
          showToast(out.generationWarnings[0], 'warning');
        } else {
          showToast(`Generated ${settings.numSets} set(s)`, 'success');
        }
      };

      const addSong = (songData) => {
        const newSong = { id: genId(), status: 'active', ...songData };
        setSongs([...songs, newSong]);
        showToast('Song added (Active)', 'success');
      };

      const deleteSong = (id) => {
        setSongs(songs.filter(s => s.id !== id));
        showToast('Song deleted', 'warning');
      };

      // PHASE 3A: shelf/restore
      const shelfSong = (id) => {
        setSongs(songs.map(s => s.id === id ? { ...s, status: 'cold' } : s));
        // remove from setlists + locks if it appears (optional safety)
        setLocked(prev => {
          const next = new Set(prev);
          [...next].forEach(k => {
            const [, songId] = k.split(':');
            if (songId === id) next.delete(k);
          });
          return next;
        });
        showToast('Shelved to Cold List', 'success');
      };

      const restoreSong = (id) => {
        setSongs(songs.map(s => s.id === id ? { ...s, status: 'active' } : s));
        showToast('Restored to Active', 'success');
      };

      const clearAllSongs = () => {
        if (!window.confirm('Delete all songs? This cannot be undone.')) return;
        setSongs([]);
        setSetlists([]);
        setLocked(new Set());
        setLastGenerationStats(null);
        showToast('All songs deleted', 'warning');
      };

      // PHASE 2: CSV Export with proper quoting
      const exportSongs = () => {
        const headers = ['Title', 'Artist', 'Duration', 'Style', 'Key', 'BPM', 'Vocalist'];
        const rows = songs.map(s => ([
          csvEscapeCell(s.title),
          csvEscapeCell(s.artist),
          csvEscapeCell(s.duration ?? ''),
          csvEscapeCell(s.style ?? ''),
          csvEscapeCell(s.key ?? ''),
          csvEscapeCell(s.bpm ?? ''),
          csvEscapeCell(s.vocalist ?? '')
        ]));
        const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `songs-${new Date().toISOString().slice(0, 10)}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
      };

      const importCSVRobust = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        // Handle PDF files via Quick Import
        if (file.name.toLowerCase().endsWith('.pdf') || file.type === 'application/pdf') {
          try {
            const arrayBuffer = await file.arrayBuffer();
            const pageTexts = await pdfExtractText(arrayBuffer);
            const pdfSongs = pdfParseAllPages(pageTexts);
            if (pdfSongs.length === 0) return showToast('No song data found in PDF', 'error');

            const imported = pdfSongs.map(s => ({
              id: genId(),
              status: 'active',
              title: sanitizeInput(s.title),
              artist: sanitizeInput(s.artist),
              duration: parseDuration(s.duration),
              style: (s.style && PDF_KNOWN_STYLES.has(s.style.toLowerCase())) ? s.style.toLowerCase() : 'midtempo',
              key: s.key || '',
              bpm: s.bpm || '',
              vocalist: s.vocalist || ''
            }));

            setSongs([...songs, ...imported]);
            const newImport = { ts: Date.now(), count: imported.length, filename: file.name };
            const updatedImports = [newImport, ...imports].slice(0, 10);
            setImports(updatedImports);
            LS.set(LS_KEYS.bandImports(activeBandId), updatedImports);
            showToast(`Imported ${imported.length} songs from PDF`, 'success');
          } catch (err) {
            console.error('PDF parse error:', err);
            showToast('Failed to parse PDF: ' + (err.message || 'Unknown error'), 'error');
          }
          e.target.value = '';
          return;
        }

        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target?.result;
          if (!text) return;

          const lines = String(text).split(/\r?\n/).filter(l => l.trim());
          if (lines.length < 2) return showToast('CSV empty or invalid', 'error');

          const imported = [];
          for (let i = 1; i < lines.length; i++) {
            // NOTE: basic CSV split (kept as-is for this build)
            const parts = lines[i].split(',').map(p => p.trim().replace(/^"|"$/g, ''));
            if (parts.length < 3) continue;

            const [title, artist, duration, style, key, bpm, vocalist] = parts;
            if (!title || !artist || !duration) continue;

            imported.push({
              id: genId(),
              status: 'active',
              title: sanitizeInput(title),
              artist: sanitizeInput(artist),
              duration: parseDuration(duration),
              style: style || 'midtempo',
              key: key || '',
              bpm: bpm || '',
              vocalist: vocalist || ''
            });
          }

          if (imported.length === 0) return showToast('No valid songs found', 'error');

          setSongs([...songs, ...imported]);
          const newImport = { ts: Date.now(), count: imported.length, filename: file.name };
          const updatedImports = [newImport, ...imports].slice(0, 10);
          setImports(updatedImports);
          LS.set(LS_KEYS.bandImports(activeBandId), updatedImports);
          showToast(`Imported ${imported.length} songs`, 'success');
        };
        reader.readAsText(file);
        e.target.value = '';
      };

      const downloadSampleCSV = () => {
        const sample =
`Title,Artist,Duration,Style,Key,BPM,Vocalist
"25 or 6 to 4","Chicago",4.82,uptempo,Am,147,Beau
"Call Me the Breeze","Lynyrd Skynyrd",5.15,midtempo,A,192,Kelly
"Hard To Handle","The Black Crowes",3.13,uptempo,B,103,Kelly
"Hold On Loosely","38 Special",4.68,midtempo,E,128,Beau
"La Grange","ZZ Top",3.83,uptempo,A,162,Chris
"Come Together","The Beatles",4.5,groove,Dm,82,ALL
"Sweet Home Alabama","Lynyrd Skynyrd",4.75,midtempo,D,100,Chris
"Billie Jean","Michael Jackson",4.25,uptempo,F#m,117,ALL`;
        const blob = new Blob([sample], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'sample-setlist.csv';
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
      };

      // Canonical import with dedup
      const importCanonicalRows = (rows, report) => {
        const existingKeys = new Set(
          songs.map(s => (s.title || "").toLowerCase().trim())
        );
        const imported = [];
        let dupeCount = 0;

        for (const row of rows) {
          const dedupKey = (row.title || "").toLowerCase().trim();
          if (existingKeys.has(dedupKey)) {
            // Merge missing fields into existing
            const idx = songs.findIndex(s => (s.title || "").toLowerCase().trim() === dedupKey);
            if (idx >= 0) {
              const existing = songs[idx];
              let updated = false;
              const merged = { ...existing };
              if (!merged.key && row.key) { merged.key = row.key; updated = true; }
              if (!merged.bpm && row.tempo) { merged.bpm = row.tempo; updated = true; }
              if (updated) {
                const newSongs = [...songs];
                newSongs[idx] = merged;
                setSongs(newSongs);
              }
            }
            dupeCount++;
            continue;
          }

          existingKeys.add(dedupKey);
          imported.push({
            id: genId(),
            status: 'active',
            title: sanitizeInput(row.title),
            artist: '',
            duration: 0,
            style: 'midtempo',
            key: row.key || '',
            bpm: row.tempo || '',
            vocalist: row.vocalist || ''
          });
        }

        if (imported.length > 0) {
          setSongs(prev => [...prev, ...imported]);
        }

        const newImport = { ts: Date.now(), count: imported.length, filename: 'canonical-import', dupes: dupeCount };
        const updatedImports = [newImport, ...imports].slice(0, 10);
        setImports(updatedImports);
        LS.set(LS_KEYS.bandImports(activeBandId), updatedImports);

        let msg = `Imported ${imported.length} songs`;
        if (dupeCount > 0) msg += ` (${dupeCount} duplicates merged/skipped)`;
        msg += ` | Parsed: ${report.rowsParsed}, Rejected: ${report.rowsRejected}`;
        showToast(msg, 'success');
      };

      const copyToClipboard = () => {
        const text = setlists.map((set) => {
          const header = `${set.name} (${set.songs.length} songs, ${Math.round(set.totalTime)} min)\n${'='.repeat(50)}`;
          const songList = set.songs.map((s, idx) => {
            const meta = [];
            if (s.key) meta.push(s.key);
            if (s.bpm) meta.push(`${s.bpm} BPM`);
            const metaStr = meta.length > 0 ? ` (${meta.join(' | ')})` : '';
            return `${idx + 1}. ${s.title}${s.artist ? ` - ${s.artist}` : ''}${metaStr}`;
          }).join('\n');
          return `${header}\n${songList}`;
        }).join('\n\n');

        navigator.clipboard.writeText(text).then(() => showToast('Copied to clipboard', 'success'));
      };

      const handleWatermarkUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const dataUrl = ev.target.result;
          setWatermarkImg(dataUrl);
          if (activeBandId) LS.set(LS_KEYS.bandWatermark(activeBandId), dataUrl);
          showToast('Watermark image set', 'success');
        };
        reader.readAsDataURL(file);
      };

      const clearWatermark = () => {
        setWatermarkImg(null);
        if (activeBandId) LS.set(LS_KEYS.bandWatermark(activeBandId), null);
        showToast('Watermark removed', 'success');
      };

      const exportPDF = () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
        const pageW = doc.internal.pageSize.getWidth(); // 612pt
        const pageH = doc.internal.pageSize.getHeight(); // 792pt
        // Narrow margins: ~0.25in = 18pt
        const margin = 18;
        const contentWidth = pageW - (margin * 2);

        // Register Oswald font fallback - jsPDF uses helvetica as base,
        // we set font size to 20pt per spec
        const HEADER_SIZE = 20;
        const BODY_SIZE = 20;
        const LINE_HEIGHT = 20; // 1.00 line spacing at 20pt = 20pt

        const addWatermark = () => {
          if (!watermarkImg) return;
          doc.saveGraphicsState();
          doc.setGState(new doc.GState({ opacity: 0.12 }));
          try {
            // Fill entire page, portrait orientation aligned
            doc.addImage(watermarkImg, 'AUTO', 0, 0, pageW, pageH);
          } catch (err) {
            console.warn('Watermark image error:', err);
          }
          doc.restoreGraphicsState();
        };

        const drawSetHeader = (set, yPos) => {
          const heading = set.name.toUpperCase();

          doc.setFont('helvetica', 'bold');
          doc.setFontSize(HEADER_SIZE);
          doc.setTextColor(0, 0, 0);
          doc.text(heading, margin, yPos);

          const headingWidth = doc.getTextWidth(heading);
          doc.setLineWidth(1);
          doc.line(margin, yPos + 3, margin + headingWidth, yPos + 3);

          yPos += HEADER_SIZE + 6;
          doc.setFontSize(BODY_SIZE - 4);
          doc.text(`${set.songs.length} songs  |  ${Math.round(set.totalTime)} minutes`, margin, yPos);
          return yPos + HEADER_SIZE + 4;
        };

        const formatSongLine = (song, idx) => {
          // PDF setlist shows what the performer needs on stage: #, title, key, BPM
          // Duration is excluded (internal-only for set planning). Artist included if available.
          const parts = [`${idx + 1}. ${song.title}`];
          if (song.artist) parts.push(` - ${song.artist}`);
          const meta = [];
          if (song.key) meta.push(song.key);
          if (song.bpm) meta.push(`${song.bpm} BPM`);
          if (meta.length > 0) parts.push(` (${meta.join(' | ')})`);
          return parts.join('');
        };

        setlists.forEach((set, setIdx) => {
          if (setIdx > 0) doc.addPage();
          addWatermark();

          let yPos = drawSetHeader(set, margin + HEADER_SIZE);

          doc.setFont('helvetica', 'bold');
          doc.setFontSize(BODY_SIZE);

          set.songs.forEach((song, songIdx) => {
            const lines = doc.splitTextToSize(formatSongLine(song, songIdx), contentWidth);
            const itemHeight = lines.length * LINE_HEIGHT;

            if (yPos + itemHeight > pageH - margin) {
              doc.addPage();
              addWatermark();
              yPos = margin + HEADER_SIZE;

              doc.setFont('helvetica', 'bold');
              doc.setFontSize(BODY_SIZE);
            }

            lines.forEach((line) => {
              doc.text(line, margin, yPos);
              yPos += LINE_HEIGHT;
            });

            yPos += 4;
          });
        });

        doc.save(`setlist-${new Date().toISOString().slice(0, 10)}.pdf`);
      };

      const toggleLock = (setIdx, songId) => {
        const key = `${setIdx}:${songId}`;
        const newLocked = new Set(locked);
        if (newLocked.has(key)) newLocked.delete(key);
        else newLocked.add(key);
        setLocked(newLocked);
      };

      // PHASE 2: Swap with closest-duration fallback
      const swapSong = (setIdx, songIdx) => {
        const set = setlists[setIdx];
        if (!set) return;

        const songToReplace = set.songs[songIdx];
        if (locked.has(`${setIdx}:${songToReplace.id}`)) return showToast('Cannot swap locked song', 'warning');

        // PHASE 3A: candidates should come from ACTIVE songs only
        const candidatePool = activeSongs;

        const globalUsedSongKeys = new Set();
        setlists.forEach((s, i) => {
          if (i !== setIdx || !settings.allowSongReuse) {
            s.songs.forEach(song => {
              globalUsedSongKeys.add(`id:${song.id}`);
              if (song.title && song.artist) {
                globalUsedSongKeys.add(`ta:${song.title.toLowerCase().trim()}|${song.artist.toLowerCase().trim()}`);
              }
            });
          }
        });

        const getSongDedupKeys = (s) => {
          const k = [];
          if (s.id) k.push(`id:${s.id}`);
          if (s.title && s.artist) k.push(`ta:${s.title.toLowerCase().trim()}|${s.artist.toLowerCase().trim()}`);
          return k;
        };

        let candidates = candidatePool.filter(s =>
          s.id !== songToReplace.id &&
          !set.songs.some(x => x.id === s.id) &&
          (settings.allowSongReuse ? true : !getSongDedupKeys(s).some(key => globalUsedSongKeys.has(key)))
        );

        candidates = candidates
          .map(s => ({ s, diff: Math.abs((Number(parseDuration(s.duration)) || 0) - (Number(parseDuration(songToReplace.duration)) || 0)) }))
          .sort((a, b) => a.diff - b.diff)
          .slice(0, 20)
          .map(x => x.s);

        const pick = candidates.length ? candidates[Math.floor(Math.random() * Math.min(6, candidates.length))] : null;
        if (!pick) return showToast('No suitable replacement', 'warning');

        const newSetlists = [...setlists];
        const newSongsArr = set.songs.map((s, i) => i === songIdx ? pick : s);
        newSetlists[setIdx] = {
          ...set,
          songs: newSongsArr,
          totalTime: newSongsArr.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0)
        };
        setSetlists(newSetlists);
        showToast('Song swapped', 'success');
      };

      const moveSong = (setIdx, fromIdx, toIdx) => {
        const set = setlists[setIdx];
        if (!set || toIdx < 0 || toIdx >= set.songs.length) return;

        const newSongs = [...set.songs];
        const [moved] = newSongs.splice(fromIdx, 1);
        newSongs.splice(toIdx, 0, moved);

        const newSetlists = [...setlists];
        newSetlists[setIdx] = { ...set, songs: newSongs };
        setSetlists(newSetlists);
      };

      // Remove song from setlist and send to Cold List
      const removeSongFromSetlist = (setIdx, songIdx) => {
        const set = setlists[setIdx];
        if (!set) return;

        const song = set.songs[songIdx];
        if (!song) return;

        // Remove from setlist
        const newSongs = set.songs.filter((_, i) => i !== songIdx);
        const newSetlists = [...setlists];
        newSetlists[setIdx] = {
          ...set,
          songs: newSongs,
          totalTime: newSongs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0)
        };
        setSetlists(newSetlists);

        // Remove any lock for this song
        const lockKey = `${setIdx}:${song.id}`;
        if (locked.has(lockKey)) {
          const newLocked = new Set(locked);
          newLocked.delete(lockKey);
          setLocked(newLocked);
        }

        // Move song to cold list
        setSongs(prev => prev.map(s => s.id === song.id ? { ...s, status: 'cold' } : s));
        showToast(`"${song.title}" removed and shelved to Cold List`, 'success');
      };

      // Lock or unlock all songs in a set
      const lockEntireSet = (setIdx, lock) => {
        const set = setlists[setIdx];
        if (!set) return;

        const newLocked = new Set(locked);
        set.songs.forEach(song => {
          const key = `${setIdx}:${song.id}`;
          if (lock) newLocked.add(key);
          else newLocked.delete(key);
        });
        setLocked(newLocked);
        showToast(lock ? 'Set locked' : 'Set unlocked', 'success');
      };

      // --- Cross-Set Drag-and-Drop Handlers ---
      // Ref to throttle dragover state updates (prevents excessive re-renders that cause "stuck" feeling)
      const dragOverRef = React.useRef({ setIdx: null, songIdx: null });

      const handleDragStart = (e, song, setIdx, songIdx) => {
        if (locked.has(`${setIdx}:${song.id}`)) { e.preventDefault(); return; }
        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }
        // Set effectAllowed BEFORE setData for cross-browser compat (Firefox requires this order)
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain', song.title); } catch (_) {}
        // Some browsers (Safari) need a brief delay before visual state updates during drag
        requestAnimationFrame(() => {
          setDragState({ active: true, song, fromSetIdx: setIdx, fromSongIdx: songIdx, overSetIdx: null, overSongIdx: null });
        });
      };

      const handleDragEnd = () => {
        dragOverRef.current = { setIdx: null, songIdx: null };
        setDragState(defaultDragState);
        // Clean up any lingering drag-over CSS classes that may get stuck
        document.querySelectorAll('.drag-over, .drag-over-bottom, .drag-over-top').forEach(el => {
          el.classList.remove('drag-over', 'drag-over-bottom', 'drag-over-top');
        });
      };

      const handleDragOverSong = (e, setIdx, songIdx) => {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'move';
        // Throttle: only update React state if the target actually changed
        if (dragOverRef.current.setIdx === setIdx && dragOverRef.current.songIdx === songIdx) return;
        dragOverRef.current = { setIdx, songIdx };
        setDragState(prev => {
          if (prev.overSetIdx === setIdx && prev.overSongIdx === songIdx) return prev;
          return { ...prev, overSetIdx: setIdx, overSongIdx: songIdx };
        });
      };

      const handleDragOverSet = (e, setIdx) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        setDragState(prev => {
          if (prev.overSongIdx !== null) return prev;
          if (prev.overSetIdx === setIdx && prev.overSongIdx === null) return prev;
          return { ...prev, overSetIdx: setIdx, overSongIdx: null };
        });
      };

      const reorderSongWithinSet = (setIdx, fromIdx, toIdx) => {
        const set = setlists[setIdx];
        if (!set || fromIdx === toIdx) return;
        const newSongs = [...set.songs];
        const [moved] = newSongs.splice(fromIdx, 1);
        newSongs.splice(toIdx, 0, moved);
        const newSetlists = [...setlists];
        newSetlists[setIdx] = { ...set, songs: newSongs, totalTime: newSongs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0) };
        setSetlists(newSetlists);
      };

      const moveSongBetweenSets = (fromSetIdx, toSetIdx, fromSongIdx, toSongIdx) => {
        const newSetlists = JSON.parse(JSON.stringify(setlists));
        const fromSet = newSetlists[fromSetIdx];
        const toSet = newSetlists[toSetIdx];
        if (!fromSet || !toSet) return;

        const [movedSong] = fromSet.songs.splice(fromSongIdx, 1);
        const insertIdx = (toSongIdx !== null && toSongIdx !== undefined) ? Math.min(toSongIdx, toSet.songs.length) : toSet.songs.length;
        toSet.songs.splice(insertIdx, 0, movedSong);

        fromSet.totalTime = fromSet.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);
        toSet.totalTime = toSet.songs.reduce((sum, s) => sum + (Number(parseDuration(s.duration)) || 0), 0);

        // Migrate lock from source set to destination set
        const oldKey = `${fromSetIdx}:${movedSong.id}`;
        if (locked.has(oldKey)) {
          const newLocked = new Set(locked);
          newLocked.delete(oldKey);
          newLocked.add(`${toSetIdx}:${movedSong.id}`);
          setLocked(newLocked);
        }

        setSetlists(newSetlists);
        showToast(`Moved "${movedSong.title}" to ${toSet.name}`, 'success');
      };

      const handleDropOnSong = (e, toSetIdx, toSongIdx) => {
        e.preventDefault();
        e.stopPropagation();
        if (!dragState.active) return;
        const { fromSetIdx, fromSongIdx } = dragState;
        if (fromSetIdx === toSetIdx) {
          reorderSongWithinSet(toSetIdx, fromSongIdx, toSongIdx);
        } else {
          moveSongBetweenSets(fromSetIdx, toSetIdx, fromSongIdx, toSongIdx);
        }
        handleDragEnd();
      };

      const handleDropOnSet = (e, toSetIdx) => {
        e.preventDefault();
        if (!dragState.active) return;
        const { fromSetIdx, fromSongIdx } = dragState;
        if (fromSetIdx !== toSetIdx) {
          moveSongBetweenSets(fromSetIdx, toSetIdx, fromSongIdx, null);
        }
        handleDragEnd();
      };

      const moveToSetDropdown = (fromSetIdx, songIdx, toSetIdx) => {
        if (fromSetIdx === toSetIdx) return;
        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }
        moveSongBetweenSets(fromSetIdx, toSetIdx, songIdx, null);
      };

      const resetToOriginal = () => {
        if (!originalSetlists) return;
        setSetlists(originalSetlists);
        setLocked(new Set());
        setOriginalSetlists(null);
        showToast('Order reset to original', 'success');
      };

      const shuffleSets = () => {
        if (setlists.length < 2) return;
        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }
        // Fisher-Yates shuffle of the set order
        const shuffled = [...setlists];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        // Rename sets to reflect new order and remap locks
        const newLocked = new Set();
        const newSetlists = shuffled.map((set, newIdx) => {
          const oldIdx = setlists.indexOf(set);
          // Migrate locks from old index to new index
          set.songs.forEach(song => {
            if (locked.has(`${oldIdx}:${song.id}`)) {
              newLocked.add(`${newIdx}:${song.id}`);
            }
          });
          return { ...set, name: `Set ${newIdx + 1}` };
        });
        setSetlists(newSetlists);
        setLocked(newLocked);
        showToast('Sets shuffled', 'success');
      };

      const balanceSets = () => {
        if (setlists.length < 2) return;
        const allSongs = setlists.flatMap(s => s.songs);
        const sorted = [...allSongs].sort((a, b) => (Number(parseDuration(b.duration)) || 0) - (Number(parseDuration(a.duration)) || 0));
        const buckets = setlists.map(() => []);
        const totals = setlists.map(() => 0);

        sorted.forEach(song => {
          let minIdx = 0;
          for (let i = 1; i < totals.length; i++) {
            if (totals[i] < totals[minIdx]) minIdx = i;
          }
          buckets[minIdx].push(song);
          totals[minIdx] += Number(parseDuration(song.duration)) || 0;
        });

        if (!originalSetlists) {
          setOriginalSetlists(JSON.parse(JSON.stringify(setlists)));
        }

        const newSetlists = setlists.map((set, i) => ({
          ...set,
          songs: buckets[i],
          totalTime: totals[i]
        }));
        setSetlists(newSetlists);
        setLocked(new Set());

        const times = totals.map(t => Math.round(t));
        const spread = Math.max(...times) - Math.min(...times);
        showToast(`Sets balanced (spread: ${spread} min)`, 'success');
      };

      const switchBand = (bandId) => {
        setActiveBandId(bandId);
        LS.set(LS_KEYS.active, bandId);
      };

      const createBand = (form) => {
        const newBand = { id: genId(), ...form };
        setBands([...bands, newBand]);
        setActiveBandId(newBand.id);
        LS.set(LS_KEYS.active, newBand.id);
        showToast('Band created', 'success');
      };

      // Band deletion cleanup
      const deleteBand = (band) => {
        if (bands.length === 1) return showToast('Cannot delete the last band', 'error');
        if (!window.confirm(`Delete "${band.name}"? This cannot be undone.`)) return;

        const next = bands.filter(b => b.id !== band.id);
        setBands(next);

        LS.remove(LS_KEYS.bandSongs(band.id));
        LS.remove(LS_KEYS.bandSettings(band.id));
        LS.remove(LS_KEYS.bandHistory(band.id));
        LS.remove(LS_KEYS.bandImports(band.id));
        LS.remove(LS_KEYS.bandGigs(band.id));

        if (activeBandId === band.id && next.length) {
          setActiveBandId(next[0].id);
          LS.set(LS_KEYS.active, next[0].id);
        }

        showToast('Band deleted', 'warning');
      };

      const duplicateBand = (band) => {
        const newBand = {
          id: genId(),
          name: `${band.name} (Copy)`,
          icon: band.icon,
          color: band.color
        };
        setBands([...bands, newBand]);
        // note: songs/settings are stored per-band in localStorage and will load based on activeBandId
        showToast('Band duplicated (band profile only)', 'success');
      };

      // Gig Profile functions
      const createGig = (form) => {
        // Store all venue/gig fields from the form
        const newGig = {
          id: genId(),
          name: form.name,
          venue: form.venue || '',
          date: form.date || '',
          notes: form.notes || '',
          venueCity: form.venueCity || '',
          venueState: form.venueState || '',
          venueZip: form.venueZip || '',
          venueType: form.venueType || '',
          venueCapacity: form.venueCapacity || '',
          contactName: form.contactName || '',
          contactEmail: form.contactEmail || '',
          contactPhone: form.contactPhone || '',
          loadInTime: form.loadInTime || '',
          soundCheckTime: form.soundCheckTime || '',
          setStartTime: form.setStartTime || '',
          compensation: form.compensation || '',
          eventType: form.eventType || '',
          ageRestriction: form.ageRestriction || '',
          backlineProvided: !!form.backlineProvided,
          paProvided: !!form.paProvided,
          setlists: null,
          createdAt: Date.now()
        };
        const updated = [...gigs, newGig];
        setGigs(updated);
        LS.set(LS_KEYS.bandGigs(activeBandId), updated);
        showToast('Gig profile created', 'success');
      };

      const deleteGig = (gigId) => {
        if (!window.confirm('Delete this gig profile?')) return;
        const updated = gigs.filter(g => g.id !== gigId);
        setGigs(updated);
        LS.set(LS_KEYS.bandGigs(activeBandId), updated);
        showToast('Gig profile deleted', 'warning');
      };

      const saveSetlistsToGig = (gigId) => {
        if (!setlists.length) return;
        const updated = gigs.map(g =>
          g.id === gigId ? { ...g, setlists: JSON.parse(JSON.stringify(setlists)), savedAt: Date.now() } : g
        );
        setGigs(updated);
        LS.set(LS_KEYS.bandGigs(activeBandId), updated);
        showToast('Setlists saved to gig profile', 'success');
      };

      const exportGigCSV = (gigId) => {
        const gig = gigs.find(g => g.id === gigId);
        if (!gig || !gig.setlists || gig.setlists.length === 0) return showToast('No setlists saved for this gig', 'warning');

        const headers = ['Set', 'Order', 'Title', 'Artist', 'Duration', 'Style', 'Key', 'BPM', 'Vocalist'];
        const rows = [];
        gig.setlists.forEach((set, setIdx) => {
          set.songs.forEach((song, songIdx) => {
            rows.push([
              csvEscapeCell(set.name || `Set ${setIdx + 1}`),
              csvEscapeCell(songIdx + 1),
              csvEscapeCell(song.title),
              csvEscapeCell(song.artist),
              csvEscapeCell(parseDuration(song.duration)),
              csvEscapeCell(song.style || ''),
              csvEscapeCell(song.key || ''),
              csvEscapeCell(song.bpm || ''),
              csvEscapeCell(song.vocalist || '')
            ]);
          });
        });

        // Add gig metadata as footer rows
        rows.push([]);
        rows.push([csvEscapeCell('Gig Info')]);
        rows.push([csvEscapeCell('Gig Name'), csvEscapeCell(gig.name || '')]);
        rows.push([csvEscapeCell('Venue'), csvEscapeCell(gig.venue || '')]);
        rows.push([csvEscapeCell('Date'), csvEscapeCell(gig.date || '')]);
        if (gig.venueCity) rows.push([csvEscapeCell('City'), csvEscapeCell(gig.venueCity)]);
        if (gig.venueState) rows.push([csvEscapeCell('State'), csvEscapeCell(gig.venueState)]);
        if (gig.eventType) rows.push([csvEscapeCell('Event Type'), csvEscapeCell(gig.eventType.replace(/_/g, ' '))]);
        if (gig.contactName) rows.push([csvEscapeCell('Contact'), csvEscapeCell(gig.contactName)]);
        if (gig.contactEmail) rows.push([csvEscapeCell('Email'), csvEscapeCell(gig.contactEmail)]);
        if (gig.notes) rows.push([csvEscapeCell('Notes'), csvEscapeCell(gig.notes)]);

        const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const safeName = (gig.name || 'gig').replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        const dateStr = gig.date || new Date().toISOString().slice(0, 10);
        a.download = `setlist-${safeName}-${dateStr}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 3000);
        showToast('Gig setlist exported as CSV', 'success');
      };

      const loadSetlistsFromGig = (gigId) => {
        const gig = gigs.find(g => g.id === gigId);
        if (!gig || !gig.setlists) return showToast('No saved setlists for this gig', 'warning');
        setSetlists(gig.setlists);
        setLocked(new Set());
        setOriginalSetlists(null);
        setLastGenerationStats(null);
        showToast(`Loaded setlists from "${gig.name}"`, 'success');
        setGigModal(false);
      };

      return (
        <>
          <div className="app-container no-print">
            {toast && (
              <div className="toast-container">
                <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />
              </div>
            )}

            <header className="header">
              <h1>SETLIST GENERATOR</h1>
              <div className="subtitle">v3.6.0 — Locked Openers/Closers • Venue Integration • Enhanced PDF Export</div>
            </header>

            <div className="band-bar">
              <div className="band-left">
                <div className="band-pill">
                  <span style={{ fontSize: '1.2rem' }}>{activeBand?.icon || '🎵'}</span>
                  <strong>{activeBand?.name || 'No Band'}</strong>
                  <span className="swatch" style={{ background: activeBand?.color || '#ff6b35' }}></span>
                </div>
                <button className="btn btn-small" onClick={() => setBandModal(true)}>Manage Bands</button>
                <button className="btn btn-small" onClick={() => setGigModal(true)} style={{ borderColor: 'var(--accent)', color: 'var(--accent)' }}>Gig Profiles</button>
              </div>
              <div className="toolbar">
                <select value={activeBandId || ''} onChange={(e) => switchBand(e.target.value)}>
                  {bands.map(b => <option key={b.id} value={b.id}>{b.icon || '🎵'} {b.name}</option>)}
                </select>
              </div>
            </div>

            <div className="main-grid">
              <SongLibrary
                songs={songs}
                activeCount={activeSongs.length}
                coldCount={coldSongs.length}
                libraryTab={libraryTab}
                onSetLibraryTab={setLibraryTab}
                onAddSong={addSong}
                onDeleteSong={deleteSong}
                onShelfSong={shelfSong}
                onRestoreSong={restoreSong}
                onExportCSV={exportSongs}
                onImportCSVRobust={importCSVRobust}
                onOpenImportModal={() => setImportModal(true)}
                onDownloadSampleCSV={downloadSampleCSV}
                onClearAll={clearAllSongs}
                latestImport={imports[0] || null}
              />

              <SetConfiguration
                settings={settings}
                onChange={setSettings}
                onGenerate={generate}
                onCopy={copyToClipboard}
                onExportPDF={exportPDF}
                songCount={activeSongs.length}
                libraryTime={activeLibraryTime}
                watermarkImg={watermarkImg}
                onWatermarkUpload={handleWatermarkUpload}
                onClearWatermark={clearWatermark}
                activeSongs={activeSongs}
              />
            </div>

            {setlists.length === 0 ? (
              <div className="panel" style={{ marginTop: '1rem' }}>
                <div className="alert alert-warning">
                  No setlists yet. Configure your settings and click <strong>Generate Setlists</strong>.
                  <div style={{ marginTop: '.4rem', color: 'var(--text-muted)', fontSize: '.85rem' }}>
                    Note: Generator uses <strong>Active</strong> songs only (Cold List excluded).
                  </div>
                </div>
              </div>
            ) : (
              <>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '1rem' }}>
                  <h3 className="panel-title">Generated Setlists</h3>
                  <div className="toolbar">
                    <div className="reset-balance-bar">
                      {originalSetlists && (
                        <button className="btn btn-small" onClick={resetToOriginal} title="Reset to original generated order">&#8617; Reset Order</button>
                      )}
                      {setlists.length > 1 && (
                        <>
                          <button className="btn btn-small" onClick={shuffleSets} title="Randomly reorder entire sets (keeps songs within each set)">&#8645; Shuffle Sets</button>
                          <button className="btn btn-small" onClick={balanceSets} title="Evenly redistribute songs across sets">&#9878; Balance Sets</button>
                        </>
                      )}
                    </div>
                    <button className="btn btn-small" onClick={generate}>Regenerate</button>
                    <button className="btn btn-small" onClick={() => { setSetlists([]); setLocked(new Set()); setOriginalSetlists(null); setLastGenerationStats(null); }}>Clear</button>
                  </div>
                </div>

                {lastGenerationStats && (
                  <div className="generation-stats">
                    <strong>{lastGenerationStats.songsUsed}</strong> songs used •
                    <strong> {lastGenerationStats.attempts}</strong> selection attempts
                  </div>
                )}

                <div className="setlists-container">
                  {setlists.map((set, i) => (
                    <SetlistView
                      key={set.id}
                      setIdx={i}
                      setlist={set}
                      locked={locked}
                      setLocked={setLocked}
                      onToggleLock={toggleLock}
                      onSwap={swapSong}
                      onMoveSong={moveSong}
                      onRemoveSong={removeSongFromSetlist}
                      onLockEntireSet={lockEntireSet}
                      onDragStart={handleDragStart}
                      onDragEnd={handleDragEnd}
                      onDragOverSong={handleDragOverSong}
                      onDragOverSet={handleDragOverSet}
                      onDropOnSong={handleDropOnSong}
                      onDropOnSet={handleDropOnSet}
                      onMoveToSet={moveToSetDropdown}
                      dragState={dragState}
                      totalSets={setlists.length}
                    />
                  ))}
                </div>
              </>
            )}

            <BandModal
              open={bandModal}
              onClose={() => setBandModal(false)}
              bands={bands}
              onCreate={createBand}
              onDelete={deleteBand}
              onDuplicate={duplicateBand}
            />

            <ImportSongsModal
              open={importModal}
              onClose={() => setImportModal(false)}
              onImport={importCanonicalRows}
              existingSongs={songs}
            />

            <GigProfileModal
              open={gigModal}
              onClose={() => setGigModal(false)}
              gigs={gigs}
              onCreateGig={createGig}
              onDeleteGig={deleteGig}
              onLoadGig={loadSetlistsFromGig}
              onSaveToGig={saveSetlistsToGig}
              onExportGigCSV={exportGigCSV}
              setlists={setlists}
              bandName={activeBand?.name || 'Band'}
            />
          </div>

          <PrintView setlists={setlists} watermarkImg={watermarkImg} />
        </>
      );
    }

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ErrorBoundary><App /></ErrorBoundary>);
  </script>
</body>
</html>
